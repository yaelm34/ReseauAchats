{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AACA,SAASC,UAAT,QAAS,eAAT;AACA,SAASC,uBAAT,QAAsB,iCAAtB;AAkDA,SAAMC,KAAN,QAAwB,qBAAxB;OACE,SAAOC,IAAP,CAAQC,KAAR,EAA6B;SAC3B,UAASC,MAAT,EAAiB;QACfD,UAAO,GAAK;AACb;WACC;AACD;AACD;AACH;AAED;;IACEE,4BAAiC;WAAbA,aAAKC,OAAQ;AAC/B,SAAIA,KAAJ,GAASA,KAAT;;QACE,aAAU;AACX;AACF;AAED;;cACS,WAAOC,OAAU,UAAIC,UAAJ,EAAmBJ,MAAnB,EAA+B;AACxD;AACH;;AAVA,SAUCC,YAVD;AAiBA,CAhBmC;;IAgBHI,wCAAaC,MAAb,EAAa;AAG3CZ,oCAAYY,MAAZ;;WAAAD,eACEE,aAAML;AADwC,gBAAKI,MAAL,CAAKH,KAAQ,IAAR,EAAQI,WAAR,KAAQ,IAAb;;AAFxCC,kBAAgBN,KAAhB;;AAIP;AAES;;gBACG,WAAQO,QAAM;AACzB,QAAMP,KAAK,GAAG,KAAEA,KAAhB;AACA,QAAIH,KAAK,KAAI,KAAKA,KAAlB;;QACEA,KAAK,WAAW;AAChB,WAAIQ,WAAJ,CAAcG,IAAd,CAAqBC,KAArB;;UACEZ,KAAK,YAAY;AACjB,aAAKQ,WAAL,CAAgBK,QAAhB;AACD;AACF;AACF;AACH;;AAlBgC;CAAA","names":["tslib_1","Subscriber","ArgumentOutOfRangeError","empty","take","count","source","TakeOperator","total","call","subscriber","TakeSubscriber","_super","destination","_this","_next","next","value","complete"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\take.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\r\nimport { empty } from '../observable/empty';\r\nimport { Observable } from '../Observable';\r\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\r\n\r\n/**\r\n * Emits only the first `count` values emitted by the source Observable.\r\n *\r\n * <span class=\"informal\">Takes the first `count` values from the source, then\r\n * completes.</span>\r\n *\r\n * ![](take.png)\r\n *\r\n * `take` returns an Observable that emits only the first `count` values emitted\r\n * by the source Observable. If the source emits fewer than `count` values then\r\n * all of its values are emitted. After that, it completes, regardless if the\r\n * source completes.\r\n *\r\n * ## Example\r\n * Take the first 5 seconds of an infinite 1-second interval Observable\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { take } from 'rxjs/operators';\r\n *\r\n * const intervalCount = interval(1000);\r\n * const takeFive = intervalCount.pipe(take(5));\r\n * takeFive.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * ```\r\n *\r\n * @see {@link takeLast}\r\n * @see {@link takeUntil}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\r\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\r\n *\r\n * @param {number} count The maximum number of `next` values to emit.\r\n * @return {Observable<T>} An Observable that emits only the first `count`\r\n * values emitted by the source Observable, or all of the values from the source\r\n * if the source emits fewer than `count` values.\r\n * @method take\r\n * @owner Observable\r\n */\r\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return (source: Observable<T>) => {\r\n    if (count === 0) {\r\n      return empty();\r\n    } else {\r\n      return source.lift(new TakeOperator(count));\r\n    }\r\n  };\r\n}\r\n\r\nclass TakeOperator<T> implements Operator<T, T> {\r\n  constructor(private total: number) {\r\n    if (this.total < 0) {\r\n      throw new ArgumentOutOfRangeError;\r\n    }\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass TakeSubscriber<T> extends Subscriber<T> {\r\n  private count: number = 0;\r\n\r\n  constructor(destination: Subscriber<T>, private total: number) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    const total = this.total;\r\n    const count = ++this.count;\r\n    if (count <= total) {\r\n      this.destination.next(value);\r\n      if (count === total) {\r\n        this.destination.complete();\r\n        this.unsubscribe();\r\n      }\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}