{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\nvar ConnectableObservable = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableObservable, _super);\n\n  function ConnectableObservable(source, subjectFactory) {\n    var _this = _super.call(this) || this;\n\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    _this._isComplete = false;\n    return _this;\n  }\n\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n\n    return this._subject;\n  };\n\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n\n    return connection;\n  };\n\n  ConnectableObservable.prototype.refCount = function () {\n    return higherOrderRefCount()(this);\n  };\n\n  return ConnectableObservable;\n}(Observable);\n\nexport { ConnectableObservable };\nexport var connectableObservableDescriptor = /*@__PURE__*/function () {\n  var connectableProto = ConnectableObservable.prototype;\n  return {\n    operator: {\n      value: null\n    },\n    _refCount: {\n      value: 0,\n      writable: true\n    },\n    _subject: {\n      value: null,\n      writable: true\n    },\n    _connection: {\n      value: null,\n      writable: true\n    },\n    _subscribe: {\n      value: connectableProto._subscribe\n    },\n    _isComplete: {\n      value: connectableProto._isComplete,\n      writable: true\n    },\n    getSubject: {\n      value: connectableProto.getSubject\n    },\n    connect: {\n      value: connectableProto.connect\n    },\n    refCount: {\n      value: connectableProto.refCount\n    }\n  };\n}();\n\nvar ConnectableSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ConnectableSubscriber, _super);\n\n  function ConnectableSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n\n    _super.prototype._error.call(this, err);\n  };\n\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n\n    this._unsubscribe();\n\n    _super.prototype._complete.call(this);\n  };\n\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\n\nvar RefCountOperator = /*@__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.connectable = connectable;\n    return _this;\n  }\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":"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","names":["tslib_1","SubjectSubscriber","Observable","Subscriber","Subscription","ConnectableObservable","_super","source","subjectFactory","_this","_subscribe","subscriber","prototype","getSubject","subject","_subject","isStopped","connect","connection","_connection","subscribe","refCount","connectableObservableDescriptor","operator","value","_refCount","writable","connectableProto","_isComplete","ConnectableSubscriber","destination","connectable","_error","_complete","_unsubscribe","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\r\nimport { Operator } from '../Operator';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { TeardownLogic } from '../types';\r\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\r\n\r\n/**\r\n * @class ConnectableObservable<T>\r\n */\r\nexport class ConnectableObservable<T> extends Observable<T> {\r\n\r\n  protected _subject: Subject<T>;\r\n  protected _refCount: number = 0;\r\n  protected _connection: Subscription;\r\n  /** @internal */\r\n  _isComplete = false;\r\n\r\n  constructor(public source: Observable<T>,\r\n              protected subjectFactory: () => Subject<T>) {\r\n    super();\r\n  }\r\n\r\n  /** @deprecated This is an internal implementation detail, do not use. */\r\n  _subscribe(subscriber: Subscriber<T>) {\r\n    return this.getSubject().subscribe(subscriber);\r\n  }\r\n\r\n  protected getSubject(): Subject<T> {\r\n    const subject = this._subject;\r\n    if (!subject || subject.isStopped) {\r\n      this._subject = this.subjectFactory();\r\n    }\r\n    return this._subject;\r\n  }\r\n\r\n  connect(): Subscription {\r\n    let connection = this._connection;\r\n    if (!connection) {\r\n      this._isComplete = false;\r\n      connection = this._connection = new Subscription();\r\n      connection.add(this.source\r\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\r\n      if (connection.closed) {\r\n        this._connection = null;\r\n        connection = Subscription.EMPTY;\r\n      }\r\n    }\r\n    return connection;\r\n  }\r\n\r\n  refCount(): Observable<T> {\r\n    return higherOrderRefCount()(this) as Observable<T>;\r\n  }\r\n}\r\n\r\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\r\n  const connectableProto = <any>ConnectableObservable.prototype;\r\n  return {\r\n    operator: { value: null as null },\r\n    _refCount: { value: 0, writable: true },\r\n    _subject: { value: null as null, writable: true },\r\n    _connection: { value: null as null, writable: true },\r\n    _subscribe: { value: connectableProto._subscribe },\r\n    _isComplete: { value: connectableProto._isComplete, writable: true },\r\n    getSubject: { value: connectableProto.getSubject },\r\n    connect: { value: connectableProto.connect },\r\n    refCount: { value: connectableProto.refCount }\r\n  };\r\n})();\r\n\r\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\r\n  constructor(destination: Subject<T>,\r\n              private connectable: ConnectableObservable<T>) {\r\n    super(destination);\r\n  }\r\n  protected _error(err: any): void {\r\n    this._unsubscribe();\r\n    super._error(err);\r\n  }\r\n  protected _complete(): void {\r\n    this.connectable._isComplete = true;\r\n    this._unsubscribe();\r\n    super._complete();\r\n  }\r\n  protected _unsubscribe() {\r\n    const connectable = <any>this.connectable;\r\n    if (connectable) {\r\n      this.connectable = null;\r\n      const connection = connectable._connection;\r\n      connectable._refCount = 0;\r\n      connectable._subject = null;\r\n      connectable._connection = null;\r\n      if (connection) {\r\n        connection.unsubscribe();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass RefCountOperator<T> implements Operator<T, T> {\r\n  constructor(private connectable: ConnectableObservable<T>) {\r\n  }\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n\r\n    const { connectable } = this;\r\n    (<any> connectable)._refCount++;\r\n\r\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\r\n    const subscription = source.subscribe(refCounter);\r\n\r\n    if (!refCounter.closed) {\r\n      (<any> refCounter).connection = connectable.connect();\r\n    }\r\n\r\n    return subscription;\r\n  }\r\n}\r\n\r\nclass RefCountSubscriber<T> extends Subscriber<T> {\r\n\r\n  private connection: Subscription;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private connectable: ConnectableObservable<T>) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _unsubscribe() {\r\n\r\n    const { connectable } = this;\r\n    if (!connectable) {\r\n      this.connection = null;\r\n      return;\r\n    }\r\n\r\n    this.connectable = null;\r\n    const refCount = (<any> connectable)._refCount;\r\n    if (refCount <= 0) {\r\n      this.connection = null;\r\n      return;\r\n    }\r\n\r\n    (<any> connectable)._refCount = refCount - 1;\r\n    if (refCount > 1) {\r\n      this.connection = null;\r\n      return;\r\n    }\r\n\r\n    ///\r\n    // Compare the local RefCountSubscriber's connection Subscription to the\r\n    // connection Subscription on the shared ConnectableObservable. In cases\r\n    // where the ConnectableObservable source synchronously emits values, and\r\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\r\n    // execution continues to here before the RefCountOperator has a chance to\r\n    // supply the RefCountSubscriber with the shared connection Subscription.\r\n    // For example:\r\n    // ```\r\n    // range(0, 10).pipe(\r\n    //   publish(),\r\n    //   refCount(),\r\n    //   take(5),\r\n    // ).subscribe();\r\n    // ```\r\n    // In order to account for this case, RefCountSubscriber should only dispose\r\n    // the ConnectableObservable's shared connection Subscription if the\r\n    // connection Subscription exists, *and* either:\r\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\r\n    //      Subscription yet, or,\r\n    //   b. RefCountSubscriber's connection Subscription reference is identical\r\n    //      to the shared connection Subscription\r\n    ///\r\n    const { connection } = this;\r\n    const sharedConnection = (<any> connectable)._connection;\r\n    this.connection = null;\r\n\r\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\r\n      sharedConnection.unsubscribe();\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}