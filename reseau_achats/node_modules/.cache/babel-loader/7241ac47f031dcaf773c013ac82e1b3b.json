{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WRITE = exports.READ = exports.Driver = void 0;\n\nvar bookmark_1 = require(\"./internal/bookmark\");\n\nvar connectivity_verifier_1 = require(\"./internal/connectivity-verifier\");\n\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\n\nvar constants_1 = require(\"./internal/constants\");\n\nvar logger_1 = require(\"./internal/logger\");\n\nvar session_1 = __importDefault(require(\"./session\"));\n\nvar util_1 = require(\"./internal/util\");\n\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n\n/**\r\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\r\n * @type {number}\r\n */\n\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\r\n * Constant that represents read session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\r\n * @type {string}\r\n */\n\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\r\n * Constant that represents write session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\r\n * @type {string}\r\n */\n\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\r\n * A driver maintains one or more {@link Session}s with a remote\r\n * Neo4j instance. Through the {@link Session}s you can send queries\r\n * and retrieve results from the database.\r\n *\r\n * Drivers are reasonably expensive to create - you should strive to keep one\r\n * driver instance around per Neo4j Instance you connect to.\r\n *\r\n * @access public\r\n */\n\nvar Driver =\n/** @class */\nfunction () {\n  /**\r\n   * You should not be calling this directly, instead use {@link driver}.\r\n   * @constructor\r\n   * @protected\r\n   * @param {Object} meta Metainformation about the driver\r\n   * @param {Object} config\r\n   * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectonProvider Creates the connection provider\r\n   * @param {function(args): Session } createSession Creates the a session\r\n  */\n  function Driver(meta, config, createConnectonProvider, createSession) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    if (createSession === void 0) {\n      createSession = function (args) {\n        return new session_1.default(args);\n      };\n    }\n\n    sanitizeConfig(config);\n    validateConfig(config);\n    this._id = idGenerator++;\n    this._meta = meta;\n    this._config = config;\n    this._log = logger_1.Logger.create(config);\n    this._createConnectionProvider = createConnectonProvider;\n    this._createSession = createSession;\n    /**\r\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\r\n     * @type {ConnectionProvider}\r\n     * @protected\r\n     */\n\n    this._connectionProvider = null;\n\n    this._afterConstruction();\n  }\n  /**\r\n   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\r\n   *\r\n   * @public\r\n   * @param {Object} param - The object parameter\r\n   * @param {string} param.database - The target database to verify connectivity for.\r\n   * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\r\n   */\n\n\n  Driver.prototype.verifyConnectivity = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.database,\n        database = _c === void 0 ? '' : _c;\n\n    var connectionProvider = this._getOrCreateConnectionProvider();\n\n    var connectivityVerifier = new connectivity_verifier_1.ConnectivityVerifier(connectionProvider);\n    return connectivityVerifier.verify({\n      database: database\n    });\n  };\n  /**\r\n   * Returns whether the server supports multi database capabilities based on the protocol\r\n   * version negotiated via handshake.\r\n   *\r\n   * Note that this function call _always_ causes a round-trip to the server.\r\n   *\r\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n   */\n\n\n  Driver.prototype.supportsMultiDb = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n\n    return connectionProvider.supportsMultiDb();\n  };\n  /**\r\n   * Returns whether the server supports transaction config capabilities based on the protocol\r\n   * version negotiated via handshake.\r\n   *\r\n   * Note that this function call _always_ causes a round-trip to the server.\r\n   *\r\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n   */\n\n\n  Driver.prototype.supportsTransactionConfig = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n\n    return connectionProvider.supportsTransactionConfig();\n  };\n  /**\r\n   * Returns whether the server supports user impersonation capabilities based on the protocol\r\n   * version negotiated via handshake.\r\n   *\r\n   * Note that this function call _always_ causes a round-trip to the server.\r\n   *\r\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n   */\n\n\n  Driver.prototype.supportsUserImpersonation = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n\n    return connectionProvider.supportsUserImpersonation();\n  };\n  /**\r\n   * @protected\r\n   * @returns {boolean}\r\n   */\n\n\n  Driver.prototype._supportsRouting = function () {\n    return this._meta.routing;\n  };\n  /**\r\n   * Returns boolean to indicate if driver has been configured with encryption enabled.\r\n   *\r\n   * @protected\r\n   * @returns {boolean}\r\n   */\n\n\n  Driver.prototype._isEncrypted = function () {\n    return this._config.encrypted === util_1.ENCRYPTION_ON;\n  };\n  /**\r\n   * Returns the configured trust strategy that the driver has been configured with.\r\n   *\r\n   * @protected\r\n   * @returns {TrustStrategy}\r\n   */\n\n\n  Driver.prototype._getTrust = function () {\n    return this._config.trust;\n  };\n  /**\r\n   * Acquire a session to communicate with the database. The session will\r\n   * borrow connections from the underlying connection pool as required and\r\n   * should be considered lightweight and disposable.\r\n   *\r\n   * This comes with some responsibility - make sure you always call\r\n   * {@link close} when you are done using a session, and likewise,\r\n   * make sure you don't close your session before you are done using it. Once\r\n   * it is closed, the underlying connection will be released to the connection\r\n   * pool and made available for others to use.\r\n   *\r\n   * @public\r\n   * @param {Object} param - The object parameter\r\n   * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n   * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\r\n   * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\r\n   * @param {number} param.fetchSize - The record fetch size of each batch of this session.\r\n   * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\r\n   * @param {string} param.database - The database this session will operate on.\r\n   * @param {string} param.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\r\n   * @return {Session} new session.\r\n   */\n\n\n  Driver.prototype.session = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n        _c = _b.defaultAccessMode,\n        defaultAccessMode = _c === void 0 ? WRITE : _c,\n        bookmarkOrBookmarks = _b.bookmarks,\n        _d = _b.database,\n        database = _d === void 0 ? '' : _d,\n        impersonatedUser = _b.impersonatedUser,\n        fetchSize = _b.fetchSize;\n\n    return this._newSession({\n      defaultAccessMode: defaultAccessMode,\n      bookmarkOrBookmarks: bookmarkOrBookmarks,\n      database: database,\n      reactive: false,\n      impersonatedUser: impersonatedUser,\n      fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\n    });\n  };\n  /**\r\n   * Close all open sessions and other associated resources. You should\r\n   * make sure to use this when you are done with this driver instance.\r\n   * @public\r\n   * @return {Promise<void>} promise resolved when the driver is closed.\r\n   */\n\n\n  Driver.prototype.close = function () {\n    this._log.info(\"Driver \" + this._id + \" closing\");\n\n    if (this._connectionProvider) {\n      return this._connectionProvider.close();\n    }\n\n    return Promise.resolve();\n  };\n  /**\r\n   * @protected\r\n   */\n\n\n  Driver.prototype._afterConstruction = function () {\n    this._log.info(this._meta.typename + \" driver \" + this._id + \" created for server address \" + this._meta.address);\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  Driver.prototype._newSession = function (_a) {\n    var defaultAccessMode = _a.defaultAccessMode,\n        bookmarkOrBookmarks = _a.bookmarkOrBookmarks,\n        database = _a.database,\n        reactive = _a.reactive,\n        impersonatedUser = _a.impersonatedUser,\n        fetchSize = _a.fetchSize;\n\n    var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n\n    var connectionProvider = this._getOrCreateConnectionProvider();\n\n    var bookmark = bookmarkOrBookmarks ? new bookmark_1.Bookmark(bookmarkOrBookmarks) : bookmark_1.Bookmark.empty();\n    return this._createSession({\n      mode: sessionMode,\n      database: database || '',\n      connectionProvider: connectionProvider,\n      bookmark: bookmark,\n      config: this._config,\n      reactive: reactive,\n      impersonatedUser: impersonatedUser,\n      fetchSize: fetchSize\n    });\n  };\n  /**\r\n   * @private\r\n   */\n\n\n  Driver.prototype._getOrCreateConnectionProvider = function () {\n    if (!this._connectionProvider) {\n      this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n    }\n\n    return this._connectionProvider;\n  };\n\n  return Driver;\n}();\n\nexports.Driver = Driver;\n/**\r\n * @private\r\n * @returns {Object} the given config.\r\n */\n\nfunction validateConfig(config) {\n  var resolver = config.resolver;\n\n  if (resolver && typeof resolver !== 'function') {\n    throw new TypeError(\"Configured resolver should be a function. Got: \" + resolver);\n  }\n\n  return config;\n}\n/**\r\n * @private\r\n */\n\n\nfunction sanitizeConfig(config) {\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n}\n/**\r\n * @private\r\n */\n\n\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n  var sanitizedValue = parseInt(rawValue, 10);\n\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\n    return sanitizedValue;\n  } else if (sanitizedValue < 0) {\n    return Number.MAX_SAFE_INTEGER;\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\r\n * @private\r\n */\n\n\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n  var fetchSize = parseInt(rawValue, 10);\n\n  if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n    return fetchSize;\n  } else if (fetchSize === 0 || fetchSize < 0) {\n    throw new Error(\"The fetch size can only be a positive value or \" + constants_1.FETCH_ALL + \" for ALL. However fetchSize = \" + fetchSize);\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\r\n * @private\r\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\r\n *              If resolved function is not specified, it defaults to an identity resolver.\r\n */\n\n\nfunction createHostNameResolver(config) {\n  return new configured_custom_resolver_1.default(config.resolver);\n}\n\nexports.default = Driver;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/driver.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WRITE","READ","Driver","bookmark_1","require","connectivity_verifier_1","configured_custom_resolver_1","constants_1","logger_1","session_1","util_1","DEFAULT_MAX_CONNECTION_LIFETIME","DEFAULT_FETCH_SIZE","ACCESS_MODE_READ","ACCESS_MODE_WRITE","idGenerator","meta","config","createConnectonProvider","createSession","args","default","sanitizeConfig","validateConfig","_id","_meta","_config","_log","Logger","create","_createConnectionProvider","_createSession","_connectionProvider","_afterConstruction","prototype","verifyConnectivity","_a","_b","_c","database","connectionProvider","_getOrCreateConnectionProvider","connectivityVerifier","ConnectivityVerifier","verify","supportsMultiDb","supportsTransactionConfig","supportsUserImpersonation","_supportsRouting","routing","_isEncrypted","encrypted","ENCRYPTION_ON","_getTrust","trust","session","defaultAccessMode","bookmarkOrBookmarks","bookmarks","_d","impersonatedUser","fetchSize","_newSession","reactive","validateFetchSizeValue","close","info","Promise","resolve","typename","address","sessionMode","_validateSessionMode","bookmark","Bookmark","empty","mode","createHostNameResolver","resolver","TypeError","maxConnectionLifetime","sanitizeIntValue","maxConnectionPoolSize","DEFAULT_POOL_MAX_SIZE","connectionAcquisitionTimeout","DEFAULT_POOL_ACQUISITION_TIMEOUT","rawValue","defaultWhenAbsent","sanitizedValue","parseInt","Number","MAX_SAFE_INTEGER","FETCH_ALL","Error"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,KAAR,GAAgBF,OAAO,CAACG,IAAR,GAAeH,OAAO,CAACI,MAAR,GAAiB,KAAK,CAArD;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,qBAAD,CAAxB;;AACA,IAAIC,uBAAuB,GAAGD,OAAO,CAAC,kCAAD,CAArC;;AACA,IAAIE,4BAA4B,GAAGb,eAAe,CAACW,OAAO,CAAC,gDAAD,CAAR,CAAlD;;AACA,IAAIG,WAAW,GAAGH,OAAO,CAAC,sBAAD,CAAzB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,mBAAD,CAAtB;;AACA,IAAIK,SAAS,GAAGhB,eAAe,CAACW,OAAO,CAAC,WAAD,CAAR,CAA/B;;AACA,IAAIM,MAAM,GAAGN,OAAO,CAAC,iBAAD,CAApB;;AACA,IAAIO,+BAA+B,GAAG,KAAK,EAAL,GAAU,IAAhD,C,CAAsD;;AACtD;AACA;AACA;AACA;;AACA,IAAIC,kBAAkB,GAAG,IAAzB;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIX,IAAI,GAAGM,WAAW,CAACM,gBAAvB;AACAf,OAAO,CAACG,IAAR,GAAeA,IAAf;AACA;AACA;AACA;AACA;AACA;;AACA,IAAID,KAAK,GAAGO,WAAW,CAACO,iBAAxB;AACAhB,OAAO,CAACE,KAAR,GAAgBA,KAAhB;AACA,IAAIe,WAAW,GAAG,CAAlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIb,MAAM;AAAG;AAAe,YAAY;AACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAASA,MAAT,CAAgBc,IAAhB,EAAsBC,MAAtB,EAA8BC,uBAA9B,EAAuDC,aAAvD,EAAsE;AAClE,QAAIF,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,EAAT;AAAc;;AACvC,QAAIE,aAAa,KAAK,KAAK,CAA3B,EAA8B;AAAEA,MAAAA,aAAa,GAAG,UAAUC,IAAV,EAAgB;AAAE,eAAO,IAAIX,SAAS,CAACY,OAAd,CAAsBD,IAAtB,CAAP;AAAqC,OAAvE;AAA0E;;AAC1GE,IAAAA,cAAc,CAACL,MAAD,CAAd;AACAM,IAAAA,cAAc,CAACN,MAAD,CAAd;AACA,SAAKO,GAAL,GAAWT,WAAW,EAAtB;AACA,SAAKU,KAAL,GAAaT,IAAb;AACA,SAAKU,OAAL,GAAeT,MAAf;AACA,SAAKU,IAAL,GAAYnB,QAAQ,CAACoB,MAAT,CAAgBC,MAAhB,CAAuBZ,MAAvB,CAAZ;AACA,SAAKa,yBAAL,GAAiCZ,uBAAjC;AACA,SAAKa,cAAL,GAAsBZ,aAAtB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKa,mBAAL,GAA2B,IAA3B;;AACA,SAAKC,kBAAL;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/B,EAAAA,MAAM,CAACgC,SAAP,CAAiBC,kBAAjB,GAAsC,UAAUC,EAAV,EAAc;AAChD,QAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkCE,EAAE,GAAGD,EAAE,CAACE,QAA1C;AAAA,QAAoDA,QAAQ,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAApF;;AACA,QAAIE,kBAAkB,GAAG,KAAKC,8BAAL,EAAzB;;AACA,QAAIC,oBAAoB,GAAG,IAAIrC,uBAAuB,CAACsC,oBAA5B,CAAiDH,kBAAjD,CAA3B;AACA,WAAOE,oBAAoB,CAACE,MAArB,CAA4B;AAAEL,MAAAA,QAAQ,EAAEA;AAAZ,KAA5B,CAAP;AACH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIrC,EAAAA,MAAM,CAACgC,SAAP,CAAiBW,eAAjB,GAAmC,YAAY;AAC3C,QAAIL,kBAAkB,GAAG,KAAKC,8BAAL,EAAzB;;AACA,WAAOD,kBAAkB,CAACK,eAAnB,EAAP;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI3C,EAAAA,MAAM,CAACgC,SAAP,CAAiBY,yBAAjB,GAA6C,YAAY;AACrD,QAAIN,kBAAkB,GAAG,KAAKC,8BAAL,EAAzB;;AACA,WAAOD,kBAAkB,CAACM,yBAAnB,EAAP;AACH,GAHD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI5C,EAAAA,MAAM,CAACgC,SAAP,CAAiBa,yBAAjB,GAA6C,YAAY;AACrD,QAAIP,kBAAkB,GAAG,KAAKC,8BAAL,EAAzB;;AACA,WAAOD,kBAAkB,CAACO,yBAAnB,EAAP;AACH,GAHD;AAIA;AACJ;AACA;AACA;;;AACI7C,EAAAA,MAAM,CAACgC,SAAP,CAAiBc,gBAAjB,GAAoC,YAAY;AAC5C,WAAO,KAAKvB,KAAL,CAAWwB,OAAlB;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACI/C,EAAAA,MAAM,CAACgC,SAAP,CAAiBgB,YAAjB,GAAgC,YAAY;AACxC,WAAO,KAAKxB,OAAL,CAAayB,SAAb,KAA2BzC,MAAM,CAAC0C,aAAzC;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACIlD,EAAAA,MAAM,CAACgC,SAAP,CAAiBmB,SAAjB,GAA6B,YAAY;AACrC,WAAO,KAAK3B,OAAL,CAAa4B,KAApB;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIpD,EAAAA,MAAM,CAACgC,SAAP,CAAiBqB,OAAjB,GAA2B,UAAUnB,EAAV,EAAc;AACrC,QAAIC,EAAE,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAA9B;AAAA,QAAkCE,EAAE,GAAGD,EAAE,CAACmB,iBAA1C;AAAA,QAA6DA,iBAAiB,GAAGlB,EAAE,KAAK,KAAK,CAAZ,GAAgBtC,KAAhB,GAAwBsC,EAAzG;AAAA,QAA6GmB,mBAAmB,GAAGpB,EAAE,CAACqB,SAAtI;AAAA,QAAiJC,EAAE,GAAGtB,EAAE,CAACE,QAAzJ;AAAA,QAAmKA,QAAQ,GAAGoB,EAAE,KAAK,KAAK,CAAZ,GAAgB,EAAhB,GAAqBA,EAAnM;AAAA,QAAuMC,gBAAgB,GAAGvB,EAAE,CAACuB,gBAA7N;AAAA,QAA+OC,SAAS,GAAGxB,EAAE,CAACwB,SAA9P;;AACA,WAAO,KAAKC,WAAL,CAAiB;AACpBN,MAAAA,iBAAiB,EAAEA,iBADC;AAEpBC,MAAAA,mBAAmB,EAAEA,mBAFD;AAGpBlB,MAAAA,QAAQ,EAAEA,QAHU;AAIpBwB,MAAAA,QAAQ,EAAE,KAJU;AAKpBH,MAAAA,gBAAgB,EAAEA,gBALE;AAMpBC,MAAAA,SAAS,EAAEG,sBAAsB,CAACH,SAAD,EAAY,KAAKnC,OAAL,CAAamC,SAAzB;AANb,KAAjB,CAAP;AAQH,GAVD;AAWA;AACJ;AACA;AACA;AACA;AACA;;;AACI3D,EAAAA,MAAM,CAACgC,SAAP,CAAiB+B,KAAjB,GAAyB,YAAY;AACjC,SAAKtC,IAAL,CAAUuC,IAAV,CAAe,YAAY,KAAK1C,GAAjB,GAAuB,UAAtC;;AACA,QAAI,KAAKQ,mBAAT,EAA8B;AAC1B,aAAO,KAAKA,mBAAL,CAAyBiC,KAAzB,EAAP;AACH;;AACD,WAAOE,OAAO,CAACC,OAAR,EAAP;AACH,GAND;AAOA;AACJ;AACA;;;AACIlE,EAAAA,MAAM,CAACgC,SAAP,CAAiBD,kBAAjB,GAAsC,YAAY;AAC9C,SAAKN,IAAL,CAAUuC,IAAV,CAAe,KAAKzC,KAAL,CAAW4C,QAAX,GAAsB,UAAtB,GAAmC,KAAK7C,GAAxC,GAA8C,8BAA9C,GAA+E,KAAKC,KAAL,CAAW6C,OAAzG;AACH,GAFD;AAGA;AACJ;AACA;;;AACIpE,EAAAA,MAAM,CAACgC,SAAP,CAAiB4B,WAAjB,GAA+B,UAAU1B,EAAV,EAAc;AACzC,QAAIoB,iBAAiB,GAAGpB,EAAE,CAACoB,iBAA3B;AAAA,QAA8CC,mBAAmB,GAAGrB,EAAE,CAACqB,mBAAvE;AAAA,QAA4FlB,QAAQ,GAAGH,EAAE,CAACG,QAA1G;AAAA,QAAoHwB,QAAQ,GAAG3B,EAAE,CAAC2B,QAAlI;AAAA,QAA4IH,gBAAgB,GAAGxB,EAAE,CAACwB,gBAAlK;AAAA,QAAoLC,SAAS,GAAGzB,EAAE,CAACyB,SAAnM;;AACA,QAAIU,WAAW,GAAG9D,SAAS,CAACY,OAAV,CAAkBmD,oBAAlB,CAAuChB,iBAAvC,CAAlB;;AACA,QAAIhB,kBAAkB,GAAG,KAAKC,8BAAL,EAAzB;;AACA,QAAIgC,QAAQ,GAAGhB,mBAAmB,GAC5B,IAAItD,UAAU,CAACuE,QAAf,CAAwBjB,mBAAxB,CAD4B,GAE5BtD,UAAU,CAACuE,QAAX,CAAoBC,KAApB,EAFN;AAGA,WAAO,KAAK5C,cAAL,CAAoB;AACvB6C,MAAAA,IAAI,EAAEL,WADiB;AAEvBhC,MAAAA,QAAQ,EAAEA,QAAQ,IAAI,EAFC;AAGvBC,MAAAA,kBAAkB,EAAEA,kBAHG;AAIvBiC,MAAAA,QAAQ,EAAEA,QAJa;AAKvBxD,MAAAA,MAAM,EAAE,KAAKS,OALU;AAMvBqC,MAAAA,QAAQ,EAAEA,QANa;AAOvBH,MAAAA,gBAAgB,EAAEA,gBAPK;AAQvBC,MAAAA,SAAS,EAAEA;AARY,KAApB,CAAP;AAUH,GAjBD;AAkBA;AACJ;AACA;;;AACI3D,EAAAA,MAAM,CAACgC,SAAP,CAAiBO,8BAAjB,GAAkD,YAAY;AAC1D,QAAI,CAAC,KAAKT,mBAAV,EAA+B;AAC3B,WAAKA,mBAAL,GAA2B,KAAKF,yBAAL,CAA+B,KAAKN,GAApC,EAAyC,KAAKE,OAA9C,EAAuD,KAAKC,IAA5D,EAAkEkD,sBAAsB,CAAC,KAAKnD,OAAN,CAAxF,CAA3B;AACH;;AACD,WAAO,KAAKM,mBAAZ;AACH,GALD;;AAMA,SAAO9B,MAAP;AACH,CA3L2B,EAA5B;;AA4LAJ,OAAO,CAACI,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;AACA;;AACA,SAASqB,cAAT,CAAwBN,MAAxB,EAAgC;AAC5B,MAAI6D,QAAQ,GAAG7D,MAAM,CAAC6D,QAAtB;;AACA,MAAIA,QAAQ,IAAI,OAAOA,QAAP,KAAoB,UAApC,EAAgD;AAC5C,UAAM,IAAIC,SAAJ,CAAc,oDAAoDD,QAAlE,CAAN;AACH;;AACD,SAAO7D,MAAP;AACH;AACD;AACA;AACA;;;AACA,SAASK,cAAT,CAAwBL,MAAxB,EAAgC;AAC5BA,EAAAA,MAAM,CAAC+D,qBAAP,GAA+BC,gBAAgB,CAAChE,MAAM,CAAC+D,qBAAR,EAA+BrE,+BAA/B,CAA/C;AACAM,EAAAA,MAAM,CAACiE,qBAAP,GAA+BD,gBAAgB,CAAChE,MAAM,CAACiE,qBAAR,EAA+B3E,WAAW,CAAC4E,qBAA3C,CAA/C;AACAlE,EAAAA,MAAM,CAACmE,4BAAP,GAAsCH,gBAAgB,CAAChE,MAAM,CAACmE,4BAAR,EAAsC7E,WAAW,CAAC8E,gCAAlD,CAAtD;AACApE,EAAAA,MAAM,CAAC4C,SAAP,GAAmBG,sBAAsB,CAAC/C,MAAM,CAAC4C,SAAR,EAAmBjD,kBAAnB,CAAzC;AACH;AACD;AACA;AACA;;;AACA,SAASqE,gBAAT,CAA0BK,QAA1B,EAAoCC,iBAApC,EAAuD;AACnD,MAAIC,cAAc,GAAGC,QAAQ,CAACH,QAAD,EAAW,EAAX,CAA7B;;AACA,MAAIE,cAAc,GAAG,CAAjB,IAAsBA,cAAc,KAAK,CAA7C,EAAgD;AAC5C,WAAOA,cAAP;AACH,GAFD,MAGK,IAAIA,cAAc,GAAG,CAArB,EAAwB;AACzB,WAAOE,MAAM,CAACC,gBAAd;AACH,GAFI,MAGA;AACD,WAAOJ,iBAAP;AACH;AACJ;AACD;AACA;AACA;;;AACA,SAASvB,sBAAT,CAAgCsB,QAAhC,EAA0CC,iBAA1C,EAA6D;AACzD,MAAI1B,SAAS,GAAG4B,QAAQ,CAACH,QAAD,EAAW,EAAX,CAAxB;;AACA,MAAIzB,SAAS,GAAG,CAAZ,IAAiBA,SAAS,KAAKtD,WAAW,CAACqF,SAA/C,EAA0D;AACtD,WAAO/B,SAAP;AACH,GAFD,MAGK,IAAIA,SAAS,KAAK,CAAd,IAAmBA,SAAS,GAAG,CAAnC,EAAsC;AACvC,UAAM,IAAIgC,KAAJ,CAAU,oDAAoDtF,WAAW,CAACqF,SAAhE,GAA4E,gCAA5E,GAA+G/B,SAAzH,CAAN;AACH,GAFI,MAGA;AACD,WAAO0B,iBAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASV,sBAAT,CAAgC5D,MAAhC,EAAwC;AACpC,SAAO,IAAIX,4BAA4B,CAACe,OAAjC,CAAyCJ,MAAM,CAAC6D,QAAhD,CAAP;AACH;;AACDhF,OAAO,CAACuB,OAAR,GAAkBnB,MAAlB","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WRITE = exports.READ = exports.Driver = void 0;\r\nvar bookmark_1 = require(\"./internal/bookmark\");\r\nvar connectivity_verifier_1 = require(\"./internal/connectivity-verifier\");\r\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\r\nvar constants_1 = require(\"./internal/constants\");\r\nvar logger_1 = require(\"./internal/logger\");\r\nvar session_1 = __importDefault(require(\"./session\"));\r\nvar util_1 = require(\"./internal/util\");\r\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\r\n/**\r\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\r\n * @type {number}\r\n */\r\nvar DEFAULT_FETCH_SIZE = 1000;\r\n/**\r\n * Constant that represents read session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\r\n * @type {string}\r\n */\r\nvar READ = constants_1.ACCESS_MODE_READ;\r\nexports.READ = READ;\r\n/**\r\n * Constant that represents write session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\r\n * @type {string}\r\n */\r\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\r\nexports.WRITE = WRITE;\r\nvar idGenerator = 0;\r\n/**\r\n * A driver maintains one or more {@link Session}s with a remote\r\n * Neo4j instance. Through the {@link Session}s you can send queries\r\n * and retrieve results from the database.\r\n *\r\n * Drivers are reasonably expensive to create - you should strive to keep one\r\n * driver instance around per Neo4j Instance you connect to.\r\n *\r\n * @access public\r\n */\r\nvar Driver = /** @class */ (function () {\r\n    /**\r\n     * You should not be calling this directly, instead use {@link driver}.\r\n     * @constructor\r\n     * @protected\r\n     * @param {Object} meta Metainformation about the driver\r\n     * @param {Object} config\r\n     * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectonProvider Creates the connection provider\r\n     * @param {function(args): Session } createSession Creates the a session\r\n    */\r\n    function Driver(meta, config, createConnectonProvider, createSession) {\r\n        if (config === void 0) { config = {}; }\r\n        if (createSession === void 0) { createSession = function (args) { return new session_1.default(args); }; }\r\n        sanitizeConfig(config);\r\n        validateConfig(config);\r\n        this._id = idGenerator++;\r\n        this._meta = meta;\r\n        this._config = config;\r\n        this._log = logger_1.Logger.create(config);\r\n        this._createConnectionProvider = createConnectonProvider;\r\n        this._createSession = createSession;\r\n        /**\r\n         * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\r\n         * @type {ConnectionProvider}\r\n         * @protected\r\n         */\r\n        this._connectionProvider = null;\r\n        this._afterConstruction();\r\n    }\r\n    /**\r\n     * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\r\n     *\r\n     * @public\r\n     * @param {Object} param - The object parameter\r\n     * @param {string} param.database - The target database to verify connectivity for.\r\n     * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\r\n     */\r\n    Driver.prototype.verifyConnectivity = function (_a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\r\n        var connectionProvider = this._getOrCreateConnectionProvider();\r\n        var connectivityVerifier = new connectivity_verifier_1.ConnectivityVerifier(connectionProvider);\r\n        return connectivityVerifier.verify({ database: database });\r\n    };\r\n    /**\r\n     * Returns whether the server supports multi database capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\r\n    Driver.prototype.supportsMultiDb = function () {\r\n        var connectionProvider = this._getOrCreateConnectionProvider();\r\n        return connectionProvider.supportsMultiDb();\r\n    };\r\n    /**\r\n     * Returns whether the server supports transaction config capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\r\n    Driver.prototype.supportsTransactionConfig = function () {\r\n        var connectionProvider = this._getOrCreateConnectionProvider();\r\n        return connectionProvider.supportsTransactionConfig();\r\n    };\r\n    /**\r\n     * Returns whether the server supports user impersonation capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\r\n    Driver.prototype.supportsUserImpersonation = function () {\r\n        var connectionProvider = this._getOrCreateConnectionProvider();\r\n        return connectionProvider.supportsUserImpersonation();\r\n    };\r\n    /**\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\r\n    Driver.prototype._supportsRouting = function () {\r\n        return this._meta.routing;\r\n    };\r\n    /**\r\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\r\n     *\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\r\n    Driver.prototype._isEncrypted = function () {\r\n        return this._config.encrypted === util_1.ENCRYPTION_ON;\r\n    };\r\n    /**\r\n     * Returns the configured trust strategy that the driver has been configured with.\r\n     *\r\n     * @protected\r\n     * @returns {TrustStrategy}\r\n     */\r\n    Driver.prototype._getTrust = function () {\r\n        return this._config.trust;\r\n    };\r\n    /**\r\n     * Acquire a session to communicate with the database. The session will\r\n     * borrow connections from the underlying connection pool as required and\r\n     * should be considered lightweight and disposable.\r\n     *\r\n     * This comes with some responsibility - make sure you always call\r\n     * {@link close} when you are done using a session, and likewise,\r\n     * make sure you don't close your session before you are done using it. Once\r\n     * it is closed, the underlying connection will be released to the connection\r\n     * pool and made available for others to use.\r\n     *\r\n     * @public\r\n     * @param {Object} param - The object parameter\r\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\r\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\r\n     * @param {number} param.fetchSize - The record fetch size of each batch of this session.\r\n     * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\r\n     * @param {string} param.database - The database this session will operate on.\r\n     * @param {string} param.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\r\n     * @return {Session} new session.\r\n     */\r\n    Driver.prototype.session = function (_a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultAccessMode, defaultAccessMode = _c === void 0 ? WRITE : _c, bookmarkOrBookmarks = _b.bookmarks, _d = _b.database, database = _d === void 0 ? '' : _d, impersonatedUser = _b.impersonatedUser, fetchSize = _b.fetchSize;\r\n        return this._newSession({\r\n            defaultAccessMode: defaultAccessMode,\r\n            bookmarkOrBookmarks: bookmarkOrBookmarks,\r\n            database: database,\r\n            reactive: false,\r\n            impersonatedUser: impersonatedUser,\r\n            fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\r\n        });\r\n    };\r\n    /**\r\n     * Close all open sessions and other associated resources. You should\r\n     * make sure to use this when you are done with this driver instance.\r\n     * @public\r\n     * @return {Promise<void>} promise resolved when the driver is closed.\r\n     */\r\n    Driver.prototype.close = function () {\r\n        this._log.info(\"Driver \" + this._id + \" closing\");\r\n        if (this._connectionProvider) {\r\n            return this._connectionProvider.close();\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    /**\r\n     * @protected\r\n     */\r\n    Driver.prototype._afterConstruction = function () {\r\n        this._log.info(this._meta.typename + \" driver \" + this._id + \" created for server address \" + this._meta.address);\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    Driver.prototype._newSession = function (_a) {\r\n        var defaultAccessMode = _a.defaultAccessMode, bookmarkOrBookmarks = _a.bookmarkOrBookmarks, database = _a.database, reactive = _a.reactive, impersonatedUser = _a.impersonatedUser, fetchSize = _a.fetchSize;\r\n        var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\r\n        var connectionProvider = this._getOrCreateConnectionProvider();\r\n        var bookmark = bookmarkOrBookmarks\r\n            ? new bookmark_1.Bookmark(bookmarkOrBookmarks)\r\n            : bookmark_1.Bookmark.empty();\r\n        return this._createSession({\r\n            mode: sessionMode,\r\n            database: database || '',\r\n            connectionProvider: connectionProvider,\r\n            bookmark: bookmark,\r\n            config: this._config,\r\n            reactive: reactive,\r\n            impersonatedUser: impersonatedUser,\r\n            fetchSize: fetchSize\r\n        });\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    Driver.prototype._getOrCreateConnectionProvider = function () {\r\n        if (!this._connectionProvider) {\r\n            this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\r\n        }\r\n        return this._connectionProvider;\r\n    };\r\n    return Driver;\r\n}());\r\nexports.Driver = Driver;\r\n/**\r\n * @private\r\n * @returns {Object} the given config.\r\n */\r\nfunction validateConfig(config) {\r\n    var resolver = config.resolver;\r\n    if (resolver && typeof resolver !== 'function') {\r\n        throw new TypeError(\"Configured resolver should be a function. Got: \" + resolver);\r\n    }\r\n    return config;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction sanitizeConfig(config) {\r\n    config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\r\n    config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\r\n    config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\r\n    config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\r\n    var sanitizedValue = parseInt(rawValue, 10);\r\n    if (sanitizedValue > 0 || sanitizedValue === 0) {\r\n        return sanitizedValue;\r\n    }\r\n    else if (sanitizedValue < 0) {\r\n        return Number.MAX_SAFE_INTEGER;\r\n    }\r\n    else {\r\n        return defaultWhenAbsent;\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\r\n    var fetchSize = parseInt(rawValue, 10);\r\n    if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\r\n        return fetchSize;\r\n    }\r\n    else if (fetchSize === 0 || fetchSize < 0) {\r\n        throw new Error(\"The fetch size can only be a positive value or \" + constants_1.FETCH_ALL + \" for ALL. However fetchSize = \" + fetchSize);\r\n    }\r\n    else {\r\n        return defaultWhenAbsent;\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\r\n *              If resolved function is not specified, it defaults to an identity resolver.\r\n */\r\nfunction createHostNameResolver(config) {\r\n    return new configured_custom_resolver_1.default(config.resolver);\r\n}\r\nexports.default = Driver;\r\n"]},"metadata":{},"sourceType":"script"}