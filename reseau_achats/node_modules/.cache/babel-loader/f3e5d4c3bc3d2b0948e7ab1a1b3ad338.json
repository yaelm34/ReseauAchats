{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\n\nvar v1 = __importStar(require(\"./packstream-v1\"));\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar temporal_factory_1 = require(\"./temporal-factory\");\n\nvar _a = neo4j_driver_core_1.internal.temporalUtil,\n    dateToEpochDay = _a.dateToEpochDay,\n    localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond,\n    localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nvar Packer =\n/** @class */\nfunction (_super) {\n  __extends(Packer, _super);\n\n  function Packer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Packer.prototype.disableByteArrays = function () {\n    throw new Error('Bolt V2 should always support byte arrays');\n  };\n\n  Packer.prototype.packable = function (obj) {\n    var _this = this;\n\n    if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n      return function () {\n        return packPoint(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n      return function () {\n        return packDuration(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n      return function () {\n        return packLocalTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n      return function () {\n        return packTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n      return function () {\n        return packDate(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n      return function () {\n        return packLocalDateTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\n      return function () {\n        return packDateTime(obj, _this);\n      };\n    } else {\n      return _super.prototype.packable.call(this, obj);\n    }\n  };\n\n  return Packer;\n}(v1.Packer);\n\nexports.Packer = Packer;\n\nvar Unpacker =\n/** @class */\nfunction (_super) {\n  __extends(Unpacker, _super);\n  /**\r\n   * @constructor\r\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\r\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\r\n   */\n\n\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n\n    return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n  }\n\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    if (signature === POINT_2D) {\n      return unpackPoint2D(this, structSize, buffer);\n    } else if (signature === POINT_3D) {\n      return unpackPoint3D(this, structSize, buffer);\n    } else if (signature === DURATION) {\n      return unpackDuration(this, structSize, buffer);\n    } else if (signature === LOCAL_TIME) {\n      return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === TIME) {\n      return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE) {\n      return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === LOCAL_DATE_TIME) {\n      return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n      return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n      return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else {\n      return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    }\n  };\n\n  return Unpacker;\n}(v1.Unpacker);\n\nexports.Unpacker = Unpacker;\n/**\r\n * Pack given 2D or 3D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\r\n * Pack given 2D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\r\n * Pack given 3D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\r\n * Unpack 2D point value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Point} the unpacked 2D point value.\r\n */\n\n\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  undefined // z\n  );\n}\n/**\r\n * Unpack 3D point value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Point} the unpacked 3D point value.\r\n */\n\n\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\r\n * Pack given duration.\r\n * @param {Duration} value the duration value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packDuration(value, packer) {\n  var months = (0, neo4j_driver_core_1.int)(value.months);\n  var days = (0, neo4j_driver_core_1.int)(value.days);\n  var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n  var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\r\n * Unpack duration value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Duration} the unpacked duration value.\r\n */\n\n\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\r\n * Pack given local time.\r\n * @param {LocalTime} value the local time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\r\n * Unpack local time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\r\n * @return {LocalTime} the unpacked local time value.\r\n */\n\n\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\r\n * Pack given time.\r\n * @param {Time} value the time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\r\n * Unpack time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\r\n * @return {Time} the unpacked time value.\r\n */\n\n\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\r\n * Pack given neo4j date.\r\n * @param {Date} value the date value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packDate(value, packer) {\n  var epochDay = dateToEpochDay(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\r\n * Unpack neo4j date value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\r\n * @return {Date} the unpacked neo4j date value.\r\n */\n\n\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\r\n * Pack given local date time.\r\n * @param {LocalDateTime} value the local date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\r\n * Unpack local date time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\r\n * @return {LocalDateTime} the unpacked local date time value.\r\n */\n\n\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\r\n * Pack given date time.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\r\n * Pack given date time with zone offset.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\r\n * Unpack date time with zone offset value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\r\n * @return {DateTime} the unpacked date time with zone offset value.\r\n */\n\n\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\r\n * Pack given date time with zone id.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\n\n\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\r\n * Unpack date time with zone id value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\r\n * @return {DateTime} the unpacked date time with zone id value.\r\n */\n\n\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n\n  var convert = function (value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v2.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__createBinding","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","exports","Unpacker","Packer","v1","require","neo4j_driver_core_1","temporal_factory_1","_a","internal","temporalUtil","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","POINT_2D","POINT_2D_STRUCT_SIZE","POINT_3D","POINT_3D_STRUCT_SIZE","DURATION","DURATION_STRUCT_SIZE","LOCAL_TIME","LOCAL_TIME_STRUCT_SIZE","TIME","TIME_STRUCT_SIZE","DATE","DATE_STRUCT_SIZE","LOCAL_DATE_TIME","LOCAL_DATE_TIME_STRUCT_SIZE","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","_super","apply","arguments","disableByteArrays","Error","packable","obj","_this","isPoint","packPoint","isDuration","packDuration","isLocalTime","packLocalTime","isTime","packTime","isDate","packDate","isLocalDateTime","packLocalDateTime","isDateTime","packDateTime","disableLosslessIntegers","useBigInt","_unpackUnknownStruct","signature","structSize","buffer","unpackPoint2D","unpackPoint3D","unpackDuration","unpackLocalTime","_disableLosslessIntegers","_useBigInt","unpackTime","unpackDate","unpackLocalDateTime","unpackDateTimeWithZoneOffset","unpackDateTimeWithZoneId","point","packer","is2DPoint","z","packPoint2D","packPoint3D","packableStructFields","int","srid","x","y","packStruct","unpacker","_verifyStructSize","Point","unpack","months","days","seconds","nanoseconds","Duration","nanoOfDay","hour","minute","second","nanosecond","unpackInteger","nanoOfDayToLocalTime","convertIntegerPropsIfNeeded","offsetSeconds","timeZoneOffsetSeconds","localTime","Time","epochDay","year","month","day","epochDayToDate","epochSecond","nano","epochSecondAndNanoToLocalDateTime","timeZoneId","packDateTimeWithZoneId","packDateTimeWithZoneOffset","localDateTime","DateTime","convert","toBigInt","toNumberOrInfinity","clone","getPrototypeOf","prop","isInt","freeze"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Unpacker = exports.Packer = void 0;\r\nvar v1 = __importStar(require(\"./packstream-v1\"));\r\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\r\nvar temporal_factory_1 = require(\"./temporal-factory\");\r\nvar _a = neo4j_driver_core_1.internal.temporalUtil, dateToEpochDay = _a.dateToEpochDay, localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond, localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\r\nvar POINT_2D = 0x58;\r\nvar POINT_2D_STRUCT_SIZE = 3;\r\nvar POINT_3D = 0x59;\r\nvar POINT_3D_STRUCT_SIZE = 4;\r\nvar DURATION = 0x45;\r\nvar DURATION_STRUCT_SIZE = 4;\r\nvar LOCAL_TIME = 0x74;\r\nvar LOCAL_TIME_STRUCT_SIZE = 1;\r\nvar TIME = 0x54;\r\nvar TIME_STRUCT_SIZE = 2;\r\nvar DATE = 0x44;\r\nvar DATE_STRUCT_SIZE = 1;\r\nvar LOCAL_DATE_TIME = 0x64;\r\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\r\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\r\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\r\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\r\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\r\nvar Packer = /** @class */ (function (_super) {\r\n    __extends(Packer, _super);\r\n    function Packer() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Packer.prototype.disableByteArrays = function () {\r\n        throw new Error('Bolt V2 should always support byte arrays');\r\n    };\r\n    Packer.prototype.packable = function (obj) {\r\n        var _this = this;\r\n        if ((0, neo4j_driver_core_1.isPoint)(obj)) {\r\n            return function () { return packPoint(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\r\n            return function () { return packDuration(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\r\n            return function () { return packLocalTime(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isTime)(obj)) {\r\n            return function () { return packTime(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isDate)(obj)) {\r\n            return function () { return packDate(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\r\n            return function () { return packLocalDateTime(obj, _this); };\r\n        }\r\n        else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\r\n            return function () { return packDateTime(obj, _this); };\r\n        }\r\n        else {\r\n            return _super.prototype.packable.call(this, obj);\r\n        }\r\n    };\r\n    return Packer;\r\n}(v1.Packer));\r\nexports.Packer = Packer;\r\nvar Unpacker = /** @class */ (function (_super) {\r\n    __extends(Unpacker, _super);\r\n    /**\r\n     * @constructor\r\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\r\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\r\n     */\r\n    function Unpacker(disableLosslessIntegers, useBigInt) {\r\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\r\n        if (useBigInt === void 0) { useBigInt = false; }\r\n        return _super.call(this, disableLosslessIntegers, useBigInt) || this;\r\n    }\r\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\r\n        if (signature === POINT_2D) {\r\n            return unpackPoint2D(this, structSize, buffer);\r\n        }\r\n        else if (signature === POINT_3D) {\r\n            return unpackPoint3D(this, structSize, buffer);\r\n        }\r\n        else if (signature === DURATION) {\r\n            return unpackDuration(this, structSize, buffer);\r\n        }\r\n        else if (signature === LOCAL_TIME) {\r\n            return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else if (signature === TIME) {\r\n            return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else if (signature === DATE) {\r\n            return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else if (signature === LOCAL_DATE_TIME) {\r\n            return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\r\n            return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else if (signature === DATE_TIME_WITH_ZONE_ID) {\r\n            return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n        else {\r\n            return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\r\n        }\r\n    };\r\n    return Unpacker;\r\n}(v1.Unpacker));\r\nexports.Unpacker = Unpacker;\r\n/**\r\n * Pack given 2D or 3D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packPoint(point, packer) {\r\n    var is2DPoint = point.z === null || point.z === undefined;\r\n    if (is2DPoint) {\r\n        packPoint2D(point, packer);\r\n    }\r\n    else {\r\n        packPoint3D(point, packer);\r\n    }\r\n}\r\n/**\r\n * Pack given 2D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packPoint2D(point, packer) {\r\n    var packableStructFields = [\r\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\r\n        packer.packable(point.x),\r\n        packer.packable(point.y)\r\n    ];\r\n    packer.packStruct(POINT_2D, packableStructFields);\r\n}\r\n/**\r\n * Pack given 3D point.\r\n * @param {Point} point the point value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packPoint3D(point, packer) {\r\n    var packableStructFields = [\r\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\r\n        packer.packable(point.x),\r\n        packer.packable(point.y),\r\n        packer.packable(point.z)\r\n    ];\r\n    packer.packStruct(POINT_3D, packableStructFields);\r\n}\r\n/**\r\n * Unpack 2D point value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Point} the unpacked 2D point value.\r\n */\r\nfunction unpackPoint2D(unpacker, structSize, buffer) {\r\n    unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\r\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\r\n    unpacker.unpack(buffer), // x\r\n    unpacker.unpack(buffer), // y\r\n    undefined // z\r\n    );\r\n}\r\n/**\r\n * Unpack 3D point value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Point} the unpacked 3D point value.\r\n */\r\nfunction unpackPoint3D(unpacker, structSize, buffer) {\r\n    unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\r\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\r\n    unpacker.unpack(buffer), // x\r\n    unpacker.unpack(buffer), // y\r\n    unpacker.unpack(buffer) // z\r\n    );\r\n}\r\n/**\r\n * Pack given duration.\r\n * @param {Duration} value the duration value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packDuration(value, packer) {\r\n    var months = (0, neo4j_driver_core_1.int)(value.months);\r\n    var days = (0, neo4j_driver_core_1.int)(value.days);\r\n    var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\r\n    var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\r\n    var packableStructFields = [\r\n        packer.packable(months),\r\n        packer.packable(days),\r\n        packer.packable(seconds),\r\n        packer.packable(nanoseconds)\r\n    ];\r\n    packer.packStruct(DURATION, packableStructFields);\r\n}\r\n/**\r\n * Unpack duration value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @return {Duration} the unpacked duration value.\r\n */\r\nfunction unpackDuration(unpacker, structSize, buffer) {\r\n    unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\r\n    var months = unpacker.unpack(buffer);\r\n    var days = unpacker.unpack(buffer);\r\n    var seconds = unpacker.unpack(buffer);\r\n    var nanoseconds = unpacker.unpack(buffer);\r\n    return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\r\n}\r\n/**\r\n * Pack given local time.\r\n * @param {LocalTime} value the local time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packLocalTime(value, packer) {\r\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\r\n    var packableStructFields = [packer.packable(nanoOfDay)];\r\n    packer.packStruct(LOCAL_TIME, packableStructFields);\r\n}\r\n/**\r\n * Unpack local time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\r\n * @return {LocalTime} the unpacked local time value.\r\n */\r\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\r\n    unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\r\n    var nanoOfDay = unpacker.unpackInteger(buffer);\r\n    var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\r\n}\r\n/**\r\n * Pack given time.\r\n * @param {Time} value the time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packTime(value, packer) {\r\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\r\n    var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\r\n    var packableStructFields = [\r\n        packer.packable(nanoOfDay),\r\n        packer.packable(offsetSeconds)\r\n    ];\r\n    packer.packStruct(TIME, packableStructFields);\r\n}\r\n/**\r\n * Unpack time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\r\n * @return {Time} the unpacked time value.\r\n */\r\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\r\n    unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\r\n    var nanoOfDay = unpacker.unpackInteger(buffer);\r\n    var offsetSeconds = unpacker.unpackInteger(buffer);\r\n    var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\r\n    var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\r\n}\r\n/**\r\n * Pack given neo4j date.\r\n * @param {Date} value the date value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packDate(value, packer) {\r\n    var epochDay = dateToEpochDay(value.year, value.month, value.day);\r\n    var packableStructFields = [packer.packable(epochDay)];\r\n    packer.packStruct(DATE, packableStructFields);\r\n}\r\n/**\r\n * Unpack neo4j date value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\r\n * @return {Date} the unpacked neo4j date value.\r\n */\r\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\r\n    unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\r\n    var epochDay = unpacker.unpackInteger(buffer);\r\n    var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\r\n}\r\n/**\r\n * Pack given local date time.\r\n * @param {LocalDateTime} value the local date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packLocalDateTime(value, packer) {\r\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\r\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\r\n    var packableStructFields = [\r\n        packer.packable(epochSecond),\r\n        packer.packable(nano)\r\n    ];\r\n    packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\r\n}\r\n/**\r\n * Unpack local date time value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\r\n * @return {LocalDateTime} the unpacked local date time value.\r\n */\r\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\r\n    unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\r\n    var epochSecond = unpacker.unpackInteger(buffer);\r\n    var nano = unpacker.unpackInteger(buffer);\r\n    var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\r\n}\r\n/**\r\n * Pack given date time.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packDateTime(value, packer) {\r\n    if (value.timeZoneId) {\r\n        packDateTimeWithZoneId(value, packer);\r\n    }\r\n    else {\r\n        packDateTimeWithZoneOffset(value, packer);\r\n    }\r\n}\r\n/**\r\n * Pack given date time with zone offset.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packDateTimeWithZoneOffset(value, packer) {\r\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\r\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\r\n    var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\r\n    var packableStructFields = [\r\n        packer.packable(epochSecond),\r\n        packer.packable(nano),\r\n        packer.packable(timeZoneOffsetSeconds)\r\n    ];\r\n    packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\r\n}\r\n/**\r\n * Unpack date time with zone offset value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\r\n * @return {DateTime} the unpacked date time with zone offset value.\r\n */\r\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\r\n    unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\r\n    var epochSecond = unpacker.unpackInteger(buffer);\r\n    var nano = unpacker.unpackInteger(buffer);\r\n    var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\r\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\r\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\r\n}\r\n/**\r\n * Pack given date time with zone id.\r\n * @param {DateTime} value the date time value to pack.\r\n * @param {Packer} packer the packer to use.\r\n */\r\nfunction packDateTimeWithZoneId(value, packer) {\r\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\r\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\r\n    var timeZoneId = value.timeZoneId;\r\n    var packableStructFields = [\r\n        packer.packable(epochSecond),\r\n        packer.packable(nano),\r\n        packer.packable(timeZoneId)\r\n    ];\r\n    packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\r\n}\r\n/**\r\n * Unpack date time with zone id value using the given unpacker.\r\n * @param {Unpacker} unpacker the unpacker to use.\r\n * @param {number} structSize the retrieved struct size.\r\n * @param {BaseBuffer} buffer the buffer to unpack from.\r\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\r\n * @return {DateTime} the unpacked date time with zone id value.\r\n */\r\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\r\n    unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\r\n    var epochSecond = unpacker.unpackInteger(buffer);\r\n    var nano = unpacker.unpackInteger(buffer);\r\n    var timeZoneId = unpacker.unpack(buffer);\r\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\r\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\r\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\r\n}\r\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\r\n    if (!disableLosslessIntegers && !useBigInt) {\r\n        return obj;\r\n    }\r\n    var convert = function (value) {\r\n        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\r\n    };\r\n    var clone = Object.create(Object.getPrototypeOf(obj));\r\n    for (var prop in obj) {\r\n        if (obj.hasOwnProperty(prop)) {\r\n            var value = obj[prop];\r\n            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\r\n        }\r\n    }\r\n    Object.freeze(clone);\r\n    return clone;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}