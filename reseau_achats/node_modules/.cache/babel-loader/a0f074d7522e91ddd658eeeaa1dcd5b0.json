{"ast":null,"code":"/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}","map":{"version":3,"mappings":"AAAA;AAoEA,SAAMA,UAAN,QAA2B,eAA3B;OACE,SAAKC,UAAL,CAAgBC,KAAhB,EAAgBC,SAAhB,EAAgB;MACd,YAAW;AACZ;AAAA;AAAA;SACC;AACD;AAAA;AAAAD;AAAAE;AAAA;AAAA;AACF;AAOD;;SAAoBC;AAClB,cAAWC,QAAX;AAAA,MAAsBF,UAAE,gBAAxB;AACDA","names":["Observable","throwError","error","scheduler","subscriber","dispatch","_a"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\throwError.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { Subscriber } from '../Subscriber';\r\n\r\n/**\r\n * Creates an Observable that emits no items to the Observer and immediately\r\n * emits an error notification.\r\n *\r\n * <span class=\"informal\">Just emits 'error', and nothing else.\r\n * </span>\r\n *\r\n * ![](throw.png)\r\n *\r\n * This static operator is useful for creating a simple Observable that only\r\n * emits the error notification. It can be used for composing with other\r\n * Observables, such as in a {@link mergeMap}.\r\n *\r\n * ## Examples\r\n * ### Emit the number 7, then emit an error\r\n * ```ts\r\n * import { throwError, concat, of } from 'rxjs';\r\n *\r\n * const result = concat(of(7), throwError(new Error('oops!')));\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n *\r\n * // Logs:\r\n * // 7\r\n * // Error: oops!\r\n * ```\r\n *\r\n * ---\r\n *\r\n * ### Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 2\r\n * ```ts\r\n * import { throwError, interval, of } from 'rxjs';\r\n * import { mergeMap } from 'rxjs/operators';\r\n *\r\n * interval(1000).pipe(\r\n *   mergeMap(x => x === 2\r\n *     ? throwError('Twos are bad')\r\n *     : of('a', 'b', 'c')\r\n *   ),\r\n * ).subscribe(x => console.log(x), e => console.error(e));\r\n *\r\n * // Logs:\r\n * // a\r\n * // b\r\n * // c\r\n * // a\r\n * // b\r\n * // c\r\n * // Twos are bad\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link empty}\r\n * @see {@link never}\r\n * @see {@link of}\r\n *\r\n * @param {any} error The particular Error to pass to the error notification.\r\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\r\n * the emission of the error notification.\r\n * @return {Observable} An error Observable: emits only the error notification\r\n * using the given error argument.\r\n * @static true\r\n * @name throwError\r\n * @owner Observable\r\n */\r\nexport function throwError(error: any, scheduler?: SchedulerLike): Observable<never> {\r\n  if (!scheduler) {\r\n    return new Observable(subscriber => subscriber.error(error));\r\n  } else {\r\n    return new Observable(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\r\n  }\r\n}\r\n\r\ninterface DispatchArg {\r\n  error: any;\r\n  subscriber: Subscriber<any>;\r\n}\r\n\r\nfunction dispatch({ error, subscriber }: DispatchArg) {\r\n  subscriber.error(error);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}