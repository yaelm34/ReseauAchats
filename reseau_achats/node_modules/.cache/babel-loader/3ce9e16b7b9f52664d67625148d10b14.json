{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidRoutingTable = void 0;\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar _a = neo4j_driver_core_1.internal.constants,\n    WRITE = _a.ACCESS_MODE_WRITE,\n    READ = _a.ACCESS_MODE_READ,\n    ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\r\n * The routing table object used to determine the role of the servers in the driver.\r\n */\n\nvar RoutingTable =\n/** @class */\nfunction () {\n  function RoutingTable(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        database = _b.database,\n        routers = _b.routers,\n        readers = _b.readers,\n        writers = _b.writers,\n        expirationTime = _b.expirationTime,\n        ttl = _b.ttl;\n\n    this.database = database || null;\n    this.databaseName = database || 'default database';\n    this.routers = routers || [];\n    this.readers = readers || [];\n    this.writers = writers || [];\n    this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n    this.ttl = ttl;\n  }\n  /**\r\n   * Create a valid routing table from a raw object\r\n   *\r\n   * @param {string} database the database name. It is used for logging purposes\r\n   * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\r\n   * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\r\n   * @param {RoutingTable} The valid Routing Table\r\n   */\n\n\n  RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n    return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n  };\n\n  RoutingTable.prototype.forget = function (address) {\n    // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n    // just remove it from the set of readers and writers, so that we don't use it for actual work without\n    // performing discovery first.\n    this.readers = removeFromArray(this.readers, address);\n    this.writers = removeFromArray(this.writers, address);\n  };\n\n  RoutingTable.prototype.forgetRouter = function (address) {\n    this.routers = removeFromArray(this.routers, address);\n  };\n\n  RoutingTable.prototype.forgetWriter = function (address) {\n    this.writers = removeFromArray(this.writers, address);\n  };\n  /**\r\n   * Check if this routing table is fresh to perform the required operation.\r\n   * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\r\n   * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\r\n   */\n\n\n  RoutingTable.prototype.isStaleFor = function (accessMode) {\n    return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === READ && this.readers.length === 0 || accessMode === WRITE && this.writers.length === 0;\n  };\n  /**\r\n   * Check if this routing table is expired for specified amount of duration\r\n   *\r\n   * @param {Integer} duration amount of duration in milliseconds to check for expiration\r\n   * @returns {boolean}\r\n   */\n\n\n  RoutingTable.prototype.isExpiredFor = function (duration) {\n    return this.expirationTime.add(duration).lessThan(Date.now());\n  };\n\n  RoutingTable.prototype.allServers = function () {\n    return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n  };\n\n  RoutingTable.prototype.toString = function () {\n    return 'RoutingTable[' + (\"database=\" + this.databaseName + \", \") + (\"expirationTime=\" + this.expirationTime + \", \") + (\"currentTime=\" + Date.now() + \", \") + (\"routers=[\" + this.routers + \"], \") + (\"readers=[\" + this.readers + \"], \") + (\"writers=[\" + this.writers + \"]]\");\n  };\n\n  return RoutingTable;\n}();\n\nexports.default = RoutingTable;\n/**\r\n * Remove all occurrences of the element in the array.\r\n * @param {Array} array the array to filter.\r\n * @param {Object} element the element to remove.\r\n * @return {Array} new filtered array.\r\n */\n\nfunction removeFromArray(array, element) {\n  return array.filter(function (item) {\n    return item.asKey() !== element.asKey();\n  });\n}\n/**\r\n * Create a valid routing table from a raw object\r\n *\r\n * @param {string} db the database name. It is used for logging purposes\r\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\r\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\r\n * @param {RoutingTable} The valid Routing Table\r\n */\n\n\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n  var ttl = rawRoutingTable.ttl;\n  var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n\n  var _a = parseServers(rawRoutingTable, routerAddress),\n      routers = _a.routers,\n      readers = _a.readers,\n      writers = _a.writers;\n\n  assertNonEmpty(routers, 'routers', routerAddress);\n  assertNonEmpty(readers, 'readers', routerAddress);\n  return new RoutingTable({\n    database: database || rawRoutingTable.db,\n    routers: routers,\n    readers: readers,\n    writers: writers,\n    expirationTime: expirationTime,\n    ttl: ttl\n  });\n}\n\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\r\n * Parse server from the RawRoutingTable.\r\n *\r\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\r\n * @param {string} routerAddress the router address\r\n * @returns {Object} The object with the list of routers, readers and writers\r\n */\n\nfunction parseServers(rawRoutingTable, routerAddress) {\n  try {\n    var routers_1 = [];\n    var readers_1 = [];\n    var writers_1 = [];\n    rawRoutingTable.servers.forEach(function (server) {\n      var role = server.role;\n      var addresses = server.addresses;\n\n      if (role === 'ROUTE') {\n        routers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'WRITE') {\n        writers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'READ') {\n        readers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      }\n    });\n    return {\n      routers: routers_1,\n      readers: readers_1,\n      writers: writers_1\n    };\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\r\n * Call the expiration time using the ttls from the raw routing table and return it\r\n *\r\n * @param {RawRoutingTable} rawRoutingTable the routing table\r\n * @param {string} routerAddress the router address\r\n * @returns {number} the ttl\r\n */\n\n\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n  try {\n    var now = (0, neo4j_driver_core_1.int)(Date.now());\n    var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n\n    if (expires.lessThan(now)) {\n      return neo4j_driver_core_1.Integer.MAX_VALUE;\n    }\n\n    return expires;\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\r\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\r\n *\r\n * @param {string[]} serverAddressesArray array of addresses\r\n * @param {string} serversName the server name\r\n * @param {string} routerAddress the router address\r\n */\n\n\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n  if (serverAddressesArray.length === 0) {\n    throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n  }\n}\n\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n\n  return Array.from(addresses);\n}","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/rediscovery/routing-table.js"],"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","prototype","slice","concat","Object","defineProperty","exports","createValidRoutingTable","neo4j_driver_core_1","require","_a","internal","constants","WRITE","ACCESS_MODE_WRITE","READ","ACCESS_MODE_READ","ServerAddress","serverAddress","PROTOCOL_ERROR","MIN_ROUTERS","RoutingTable","_b","database","routers","readers","writers","expirationTime","ttl","databaseName","int","fromRawRoutingTable","routerAddress","rawRoutingTable","forget","address","removeFromArray","forgetRouter","forgetWriter","isStaleFor","accessMode","lessThan","Date","now","isExpiredFor","duration","add","allServers","toString","default","array","element","filter","item","asKey","calculateExpirationTime","parseServers","assertNonEmpty","db","routers_1","readers_1","writers_1","servers","forEach","server","role","addresses","parseArray","map","fromUrl","newError","json","stringify","message","expires","multiply","Integer","MAX_VALUE","serverAddressesArray","serversName","isArray","TypeError"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createValidRoutingTable = void 0;\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\r\nvar _a = neo4j_driver_core_1.internal.constants, WRITE = _a.ACCESS_MODE_WRITE, READ = _a.ACCESS_MODE_READ, ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\r\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\r\nvar MIN_ROUTERS = 1;\r\n/**\r\n * The routing table object used to determine the role of the servers in the driver.\r\n */\r\nvar RoutingTable = /** @class */ (function () {\r\n    function RoutingTable(_a) {\r\n        var _b = _a === void 0 ? {} : _a, database = _b.database, routers = _b.routers, readers = _b.readers, writers = _b.writers, expirationTime = _b.expirationTime, ttl = _b.ttl;\r\n        this.database = database || null;\r\n        this.databaseName = database || 'default database';\r\n        this.routers = routers || [];\r\n        this.readers = readers || [];\r\n        this.writers = writers || [];\r\n        this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\r\n        this.ttl = ttl;\r\n    }\r\n    /**\r\n     * Create a valid routing table from a raw object\r\n     *\r\n     * @param {string} database the database name. It is used for logging purposes\r\n     * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\r\n     * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\r\n     * @param {RoutingTable} The valid Routing Table\r\n     */\r\n    RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\r\n        return createValidRoutingTable(database, routerAddress, rawRoutingTable);\r\n    };\r\n    RoutingTable.prototype.forget = function (address) {\r\n        // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\r\n        // just remove it from the set of readers and writers, so that we don't use it for actual work without\r\n        // performing discovery first.\r\n        this.readers = removeFromArray(this.readers, address);\r\n        this.writers = removeFromArray(this.writers, address);\r\n    };\r\n    RoutingTable.prototype.forgetRouter = function (address) {\r\n        this.routers = removeFromArray(this.routers, address);\r\n    };\r\n    RoutingTable.prototype.forgetWriter = function (address) {\r\n        this.writers = removeFromArray(this.writers, address);\r\n    };\r\n    /**\r\n     * Check if this routing table is fresh to perform the required operation.\r\n     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\r\n     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\r\n     */\r\n    RoutingTable.prototype.isStaleFor = function (accessMode) {\r\n        return (this.expirationTime.lessThan(Date.now()) ||\r\n            this.routers.length < MIN_ROUTERS ||\r\n            (accessMode === READ && this.readers.length === 0) ||\r\n            (accessMode === WRITE && this.writers.length === 0));\r\n    };\r\n    /**\r\n     * Check if this routing table is expired for specified amount of duration\r\n     *\r\n     * @param {Integer} duration amount of duration in milliseconds to check for expiration\r\n     * @returns {boolean}\r\n     */\r\n    RoutingTable.prototype.isExpiredFor = function (duration) {\r\n        return this.expirationTime.add(duration).lessThan(Date.now());\r\n    };\r\n    RoutingTable.prototype.allServers = function () {\r\n        return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\r\n    };\r\n    RoutingTable.prototype.toString = function () {\r\n        return ('RoutingTable[' +\r\n            (\"database=\" + this.databaseName + \", \") +\r\n            (\"expirationTime=\" + this.expirationTime + \", \") +\r\n            (\"currentTime=\" + Date.now() + \", \") +\r\n            (\"routers=[\" + this.routers + \"], \") +\r\n            (\"readers=[\" + this.readers + \"], \") +\r\n            (\"writers=[\" + this.writers + \"]]\"));\r\n    };\r\n    return RoutingTable;\r\n}());\r\nexports.default = RoutingTable;\r\n/**\r\n * Remove all occurrences of the element in the array.\r\n * @param {Array} array the array to filter.\r\n * @param {Object} element the element to remove.\r\n * @return {Array} new filtered array.\r\n */\r\nfunction removeFromArray(array, element) {\r\n    return array.filter(function (item) { return item.asKey() !== element.asKey(); });\r\n}\r\n/**\r\n * Create a valid routing table from a raw object\r\n *\r\n * @param {string} db the database name. It is used for logging purposes\r\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\r\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\r\n * @param {RoutingTable} The valid Routing Table\r\n */\r\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\r\n    var ttl = rawRoutingTable.ttl;\r\n    var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\r\n    var _a = parseServers(rawRoutingTable, routerAddress), routers = _a.routers, readers = _a.readers, writers = _a.writers;\r\n    assertNonEmpty(routers, 'routers', routerAddress);\r\n    assertNonEmpty(readers, 'readers', routerAddress);\r\n    return new RoutingTable({\r\n        database: database || rawRoutingTable.db,\r\n        routers: routers,\r\n        readers: readers,\r\n        writers: writers,\r\n        expirationTime: expirationTime,\r\n        ttl: ttl\r\n    });\r\n}\r\nexports.createValidRoutingTable = createValidRoutingTable;\r\n/**\r\n * Parse server from the RawRoutingTable.\r\n *\r\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\r\n * @param {string} routerAddress the router address\r\n * @returns {Object} The object with the list of routers, readers and writers\r\n */\r\nfunction parseServers(rawRoutingTable, routerAddress) {\r\n    try {\r\n        var routers_1 = [];\r\n        var readers_1 = [];\r\n        var writers_1 = [];\r\n        rawRoutingTable.servers.forEach(function (server) {\r\n            var role = server.role;\r\n            var addresses = server.addresses;\r\n            if (role === 'ROUTE') {\r\n                routers_1 = parseArray(addresses).map(function (address) {\r\n                    return ServerAddress.fromUrl(address);\r\n                });\r\n            }\r\n            else if (role === 'WRITE') {\r\n                writers_1 = parseArray(addresses).map(function (address) {\r\n                    return ServerAddress.fromUrl(address);\r\n                });\r\n            }\r\n            else if (role === 'READ') {\r\n                readers_1 = parseArray(addresses).map(function (address) {\r\n                    return ServerAddress.fromUrl(address);\r\n                });\r\n            }\r\n        });\r\n        return {\r\n            routers: routers_1,\r\n            readers: readers_1,\r\n            writers: writers_1\r\n        };\r\n    }\r\n    catch (error) {\r\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\r\n    }\r\n}\r\n/**\r\n * Call the expiration time using the ttls from the raw routing table and return it\r\n *\r\n * @param {RawRoutingTable} rawRoutingTable the routing table\r\n * @param {string} routerAddress the router address\r\n * @returns {number} the ttl\r\n */\r\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\r\n    try {\r\n        var now = (0, neo4j_driver_core_1.int)(Date.now());\r\n        var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl)\r\n            .multiply(1000)\r\n            .add(now);\r\n        // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\r\n        if (expires.lessThan(now)) {\r\n            return neo4j_driver_core_1.Integer.MAX_VALUE;\r\n        }\r\n        return expires;\r\n    }\r\n    catch (error) {\r\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\r\n    }\r\n}\r\n/**\r\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\r\n *\r\n * @param {string[]} serverAddressesArray array of addresses\r\n * @param {string} serversName the server name\r\n * @param {string} routerAddress the router address\r\n */\r\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\r\n    if (serverAddressesArray.length === 0) {\r\n        throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\r\n    }\r\n}\r\nfunction parseArray(addresses) {\r\n    if (!Array.isArray(addresses)) {\r\n        throw new TypeError('Array expected but got: ' + addresses);\r\n    }\r\n    return Array.from(addresses);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}