{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function sampleTime(period, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    return source.lift(new SampleTimeOperator(period, scheduler));\n  };\n}\n\nvar SampleTimeOperator = /*@__PURE__*/function () {\n  function SampleTimeOperator(period, scheduler) {\n    this.period = period;\n    this.scheduler = scheduler;\n  }\n\n  SampleTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n  };\n\n  return SampleTimeOperator;\n}();\n\nvar SampleTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(SampleTimeSubscriber, _super);\n\n  function SampleTimeSubscriber(destination, period, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.period = period;\n    _this.scheduler = scheduler;\n    _this.hasValue = false;\n\n    _this.add(scheduler.schedule(dispatchNotification, period, {\n      subscriber: _this,\n      period: period\n    }));\n\n    return _this;\n  }\n\n  SampleTimeSubscriber.prototype._next = function (value) {\n    this.lastValue = value;\n    this.hasValue = true;\n  };\n\n  SampleTimeSubscriber.prototype.notifyNext = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.lastValue);\n    }\n  };\n\n  return SampleTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchNotification(state) {\n  var subscriber = state.subscriber,\n      period = state.period;\n  subscriber.notifyNext();\n  this.schedule(state, period);\n}","map":{"version":3,"mappings":";AAEA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AACA,SAASC,UAAT,QAAsB,eAAtB;AA6CA,SAAMC,KAAN,QAAgB,oBAAhB;OAA8C;AAC5C,eAAO,KAAC,KAAqB,CAA7B,EAA6B;AAC9BC;AAED;;AACE;AAAA,WAAkCC,MACd,KADc,CACU,yCADV,CAAlC;AAC4C,GAD5C;;;sBAC6B,GAAT,aAAwB;AAC5C,WAACC,kBAAD,CAACC,MAAD,EAACH,SAAD,EAAC;AAED;AACE,qBAAcA,SAAd;AACD;;AACHE,+BAACE,IAAD,GAAC;AAAA;AAOD,GAPA;;AAOsC;CAbQ;;wBAoB1C,gBAAM,UAAYC,MAAZ,EAEP;SAJmB,WAAMC,sBAAQD;;WACdC,kCAAwBH;AAJ5C,sBAAoB,KAApB,CAA0B,IAA1B,EAA0BI,WAA1B,KAA0B,IAA1B;;AAMEC,SAAI,CAACL,MAAL,GAASA,MAAT;;AACDK;;AAESA,uDAAcL,MAAd,EAAc;AAAAM;AAAAN;AAAA,KAAd;;AACR,WAAKK,KAAL;;;AAEFF,sBAAC,UAAD,CAACI,KAAD,GAAC;AAED;AACE,SAAIC,QAAJ,GAAS,IAAT;GAHF;;sBAKS,WAAiBC,aAAc,YAAE;QACvC;AACF;AACH,4BAAC,cAAD;AAtBsC;AAwBtC;;AACQ;CAlBE;;SAoBHC,qBAAgBC,OAAQ;AAC9B;AAAA","names":["tslib_1","Subscriber","async","scheduler","source","SampleTimeOperator","period","call","_super","SampleTimeSubscriber","destination","_this","subscriber","_next","hasValue","notifyNext","dispatchNotification","state"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\sampleTime.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { async } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\r\n\r\n/**\r\n * Emits the most recently emitted value from the source Observable within\r\n * periodic time intervals.\r\n *\r\n * <span class=\"informal\">Samples the source Observable at periodic time\r\n * intervals, emitting what it samples.</span>\r\n *\r\n * ![](sampleTime.png)\r\n *\r\n * `sampleTime` periodically looks at the source Observable and emits whichever\r\n * value it has most recently emitted since the previous sampling, unless the\r\n * source has not emitted anything since the previous sampling. The sampling\r\n * happens periodically in time every `period` milliseconds (or the time unit\r\n * defined by the optional `scheduler` argument). The sampling starts as soon as\r\n * the output Observable is subscribed.\r\n *\r\n * ## Example\r\n * Every second, emit the most recent click at most once\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { sampleTime } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(sampleTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounceTime}\r\n * @see {@link delay}\r\n * @see {@link sample}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} period The sampling period expressed in milliseconds or the\r\n * time unit determined internally by the optional `scheduler`.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the sampling.\r\n * @return {Observable<T>} An Observable that emits the results of sampling the\r\n * values emitted by the source Observable at the specified time interval.\r\n * @method sampleTime\r\n * @owner Observable\r\n */\r\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\r\n  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));\r\n}\r\n\r\nclass SampleTimeOperator<T> implements Operator<T, T> {\r\n  constructor(private period: number,\r\n              private scheduler: SchedulerLike) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass SampleTimeSubscriber<T> extends Subscriber<T> {\r\n  lastValue: T;\r\n  hasValue: boolean = false;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private period: number,\r\n              private scheduler: SchedulerLike) {\r\n    super(destination);\r\n    this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\r\n  }\r\n\r\n  protected _next(value: T) {\r\n    this.lastValue = value;\r\n    this.hasValue = true;\r\n  }\r\n\r\n  notifyNext() {\r\n    if (this.hasValue) {\r\n      this.hasValue = false;\r\n      this.destination.next(this.lastValue);\r\n    }\r\n  }\r\n}\r\n\r\nfunction dispatchNotification<T>(this: SchedulerAction<any>, state: any) {\r\n  let { subscriber, period } = state;\r\n  subscriber.notifyNext();\r\n  this.schedule(state, period);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}