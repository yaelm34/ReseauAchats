{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function exhaust() {\n  return function (source) {\n    return source.lift(new SwitchFirstOperator());\n  };\n}\n\nvar SwitchFirstOperator = /*@__PURE__*/function () {\n  function SwitchFirstOperator() {}\n\n  SwitchFirstOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\n  };\n\n  return SwitchFirstOperator;\n}();\n\nvar SwitchFirstSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(SwitchFirstSubscriber, _super);\n\n  function SwitchFirstSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.hasCompleted = false;\n    _this.hasSubscription = false;\n    return _this;\n  }\n\n  SwitchFirstSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.hasSubscription = true;\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\n    }\n  };\n\n  SwitchFirstSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstSubscriber.prototype.notifyComplete = function () {\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstSubscriber;\n}(SimpleOuterSubscriber);","map":{"version":3,"mappings":";AAIA,OAAO,KAAEA,OAAT,MAAS,OAAT;AAiDA,SAAMC,qBAAN,EAAuBC,cAAvB,EAAuBC,qBAAvB,QAAuB,mBAAvB;OACE,SAAOC,OAAP,GAAQ;AACT;AAAA;AAAA;AAED;;IAAAC;AAIA,WAACA,mBAAD,GAAC,CAHC;;qBACgB,WAAUC,OAAI,sBAAsBC,MAAtB,EAAmC;AAChE;AACH;;AAJA,SAICF,mBAJD;AAWA,CAXA;;IAWuCG,+CAA2BC,MAA3B,EAA2B;AAIhET,2CAAYS,MAAZ;;WAAAD,sBACEE,aAAM;AAJA,sBAAY,KAAZ,CAAwB,IAAxB,EAA8BA,WAA9B,KAA8B,IAA9B;;AACAC,yBAAe,KAAf;;AAIP;AAES;;uBACE,WAAiBC;QACzB,MAAKC,iBAAkB;AACvB,WAAKA,eAAL,GAAuB,IAAvB;AACD;AACF;AAES;;uBACS,WAAQC;AACzB,SAAKC,YAAL,GAAU,IAAV;;QACE,MAAKF,iBAAY;AAClB;AACF;AAED;;uBACO,WAAuBG,iBAAC;AAC7B,SAAIH,eAAJ,GAAuB,KAAvB;;QACE,KAAKE,cAAY;AAClB;AACF;AACH;;AA5BuC;CAAA","names":["tslib_1","SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","exhaust","SwitchFirstOperator","call","source","SwitchFirstSubscriber","_super","destination","_this","_next","hasSubscription","_complete","hasCompleted","notifyComplete"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\exhaust.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ObservableInput, OperatorFunction, TeardownLogic } from '../types';\r\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\r\n\r\nexport function exhaust<T>(): OperatorFunction<ObservableInput<T>, T>;\r\nexport function exhaust<R>(): OperatorFunction<any, R>;\r\n\r\n/**\r\n * Converts a higher-order Observable into a first-order Observable by dropping\r\n * inner Observables while the previous inner Observable has not yet completed.\r\n *\r\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\r\n * next inner Observables while the current inner is still executing.</span>\r\n *\r\n * ![](exhaust.png)\r\n *\r\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\r\n * higher-order Observable. Each time it observes one of these emitted inner\r\n * Observables, the output Observable begins emitting the items emitted by that\r\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\r\n * `exhaust` ignores every new inner Observable if the previous Observable has\r\n * not yet completed. Once that one completes, it will accept and flatten the\r\n * next inner Observable and repeat this process.\r\n *\r\n * ## Example\r\n * Run a finite timer for each click, only if there is no currently active timer\r\n * ```ts\r\n * import { fromEvent, interval } from 'rxjs';\r\n * import { exhaust, map, take } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const higherOrder = clicks.pipe(\r\n *   map((ev) => interval(1000).pipe(take(5))),\r\n * );\r\n * const result = higherOrder.pipe(exhaust());\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link combineAll}\r\n * @see {@link concatAll}\r\n * @see {@link switchAll}\r\n * @see {@link switchMap}\r\n * @see {@link mergeAll}\r\n * @see {@link exhaustMap}\r\n * @see {@link zipAll}\r\n *\r\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\r\n * exclusively until it completes before subscribing to the next.\r\n * @method exhaust\r\n * @owner Observable\r\n */\r\nexport function exhaust<T>(): OperatorFunction<any, T> {\r\n  return (source: Observable<T>) => source.lift(new SwitchFirstOperator<T>());\r\n}\r\n\r\nclass SwitchFirstOperator<T> implements Operator<T, T> {\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new SwitchFirstSubscriber(subscriber));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass SwitchFirstSubscriber<T> extends SimpleOuterSubscriber<T, T> {\r\n  private hasCompleted: boolean = false;\r\n  private hasSubscription: boolean = false;\r\n\r\n  constructor(destination: Subscriber<T>) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    if (!this.hasSubscription) {\r\n      this.hasSubscription = true;\r\n      this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));\r\n    }\r\n  }\r\n\r\n  protected _complete(): void {\r\n    this.hasCompleted = true;\r\n    if (!this.hasSubscription) {\r\n      this.destination.complete!();\r\n    }\r\n  }\r\n\r\n  notifyComplete(): void {\r\n    this.hasSubscription = false;\r\n    if (this.hasCompleted) {\r\n      this.destination.complete!();\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}