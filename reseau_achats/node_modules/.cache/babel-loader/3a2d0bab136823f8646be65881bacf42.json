{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n\nvar TimeoutWithSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(SimpleOuterSubscriber);","map":{"version":3,"mappings":";AAEA,OAAO,KAAEA,OAAT,MAAsB,OAAtB;AAEA,SAASC,KAAT,QAAiB,oBAAjB;AAEA,SAASC,MAAT,QAAS,gBAAT;AA2DA,SAAMC,qBAAN,EAAoDC,cAApD,EACoEC,qBADpE,QAEkE,mBAFlE;OAEkC,0CAAgCC,SAAhC,EAAgC;AAChE,eAAO,KAAC,KAAqB,CAA7B,EAA6B;AAC3BA,aAAI,QAAJ;;;SAEA,UAAaC,MAAb,EAAmB;AACnB;AACH;AAED;AACE;;;uBACoB,4BAAwB;WACxBC,8CAAoCC;AACpC,mBAASC,OAAT;AACnB;AAED;AACE,qBAAcJ,SAAd;AAGD;;AACHE,gCAACG,IAAD,GAAC;AAAA;AAOD,GAPA;;AAO0C;CAjBpB;;yBA0BlB,gBAAM,UAAYC,MAAZ,EAEP;SANmB;;WACAC,sBAAeC;AACf,kDAAoC,IAApC;;AACAC;AAElBA,SAAI,CAACL,OAAL,GAAKA,OAAL;;AACDK;;AAEcA;;AACL;;;uBAEO,mBAAe,UAAgBC,UAAhB,EAAoB;AACnD;;AAEOA;;AACEA,iCAAgB,uDAAhB;;;uBAOK,CAAmDC,UAAOC,kBAAoB,YAAU;QACpGC;;gBAAM;AACL,WAAKA,MAAL,GAAcA,MAAM,SAAN,CAA8D,IAA9D,EAA8D,KAAUT,OAAxE,CAAd;AAGD,WACF;AAES,4CAAVU,QAAU,CAAcP,qCAAd,EAAc,YAAd,EAAc,IAAd;AACR;;;uBAEC;AACD,+BAAW;AACZ;AAGD;;AACED,UAAK,UAAL,CAAcS,KAAd,CAAuBV,IAAvB,CAAwB,IAAxB,EAAwBW,KAAxB;;;uBAEK,WAAuBC;AAC7B;AACH;AAhD0C,0BAgDzC,IAhDyC;;;;CAShC","names":["tslib_1","async","isDate","SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","scheduler","source","TimeoutWithOperator","withObservable","waitFor","call","_super","TimeoutWithSubscriber","destination","_this","subscriber","prototype","scheduleTimeout","action","schedule","_next","value","_unsubscribe"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\timeoutWith.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { async } from '../scheduler/async';\r\nimport { Observable } from '../Observable';\r\nimport { isDate } from '../util/isDate';\r\nimport { ObservableInput, OperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\r\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span, in case of which\r\n * subscribes to the second Observable.\r\n *\r\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\r\n *\r\n * ![](timeoutWith.png)\r\n *\r\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\r\n * still accepting as a first argument either a number or a Date, which control - respectively -\r\n * when values of source Observable should be emitted or when it should complete.\r\n *\r\n * The only difference is that it accepts a second, required parameter. This parameter\r\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\r\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\r\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\r\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\r\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\r\n * stream completes, it completes as well.\r\n *\r\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\r\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\r\n * as a consequence - when second Observable will be subscribed, since subscription happens\r\n * immediately after failing check.\r\n *\r\n * ## Example\r\n * Add fallback observable\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { timeoutWith } from 'rxjs/operators';\r\n *\r\n * const seconds = interval(1000);\r\n * const minutes = interval(60 * 1000);\r\n *\r\n * seconds.pipe(timeoutWith(900, minutes))\r\n *   .subscribe(\r\n *     value => console.log(value), // After 900ms, will start emitting `minutes`,\r\n *                                  // since first value of `seconds` will not arrive fast enough.\r\n *     err => console.log(err),     // Would be called after 900ms in case of `timeout`,\r\n *                                  // but here will never be called.\r\n *   );\r\n * ```\r\n *\r\n * @param {number|Date} due Number specifying period within which Observable must emit values\r\n *                          or Date specifying before when Observable should complete\r\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\r\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\r\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\r\n *                          passed as a second parameter.\r\n * @method timeoutWith\r\n * @owner Observable\r\n */\r\nexport function timeoutWith<T, R>(due: number | Date,\r\n                                  withObservable: ObservableInput<R>,\r\n                                  scheduler: SchedulerLike = async): OperatorFunction<T, T | R> {\r\n  return (source: Observable<T>) => {\r\n    let absoluteTimeout = isDate(due);\r\n    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);\r\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\r\n  };\r\n}\r\n\r\nclass TimeoutWithOperator<T> implements Operator<T, T> {\r\n  constructor(private waitFor: number,\r\n              private absoluteTimeout: boolean,\r\n              private withObservable: ObservableInput<any>,\r\n              private scheduler: SchedulerLike) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new TimeoutWithSubscriber(\r\n      subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler\r\n    ));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass TimeoutWithSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\r\n\r\n  private action?: SchedulerAction<TimeoutWithSubscriber<T, R>>;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private absoluteTimeout: boolean,\r\n              private waitFor: number,\r\n              private withObservable: ObservableInput<any>,\r\n              private scheduler: SchedulerLike) {\r\n    super(destination);\r\n    this.scheduleTimeout();\r\n  }\r\n\r\n  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {\r\n    const { withObservable } = subscriber;\r\n    subscriber._unsubscribeAndRecycle();\r\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\r\n  }\r\n\r\n  private scheduleTimeout(): void {\r\n    const { action } = this;\r\n    if (action) {\r\n      // Recycle the action if we've already scheduled one. All the production\r\n      // Scheduler Actions mutate their state/delay time and return themeselves.\r\n      // VirtualActions are immutable, so they create and return a clone. In this\r\n      // case, we need to set the action reference to the most recent VirtualAction,\r\n      // to ensure that's the one we clone from next time.\r\n      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));\r\n    } else {\r\n      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(\r\n        TimeoutWithSubscriber.dispatchTimeout as any, this.waitFor, this\r\n      )));\r\n    }\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    if (!this.absoluteTimeout) {\r\n      this.scheduleTimeout();\r\n    }\r\n    super._next(value);\r\n  }\r\n\r\n  /** @deprecated This is an internal implementation detail, do not use. */\r\n  _unsubscribe() {\r\n    this.action = undefined;\r\n    this.scheduler = null!;\r\n    this.withObservable = null!;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}