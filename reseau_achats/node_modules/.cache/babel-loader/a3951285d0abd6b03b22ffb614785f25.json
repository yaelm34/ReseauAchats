{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar result_summary_1 = __importDefault(require(\"./result-summary\"));\n\nvar internal_1 = require(\"./internal\");\n\nvar EMPTY_CONNECTION_HOLDER = internal_1.connectionHolder.EMPTY_CONNECTION_HOLDER;\n/**\r\n * @private\r\n * @param {Error} error The error\r\n * @returns {void}\r\n */\n\nvar DEFAULT_ON_ERROR = function (error) {\n  console.log('Uncaught error when processing result: ' + error);\n};\n/**\r\n * @private\r\n * @param {ResultSummary} summary\r\n * @returns {void}\r\n */\n\n\nvar DEFAULT_ON_COMPLETED = function (summary) {};\n/**\r\n * A stream of {@link Record} representing the result of a query.\r\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\r\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\r\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\r\n * @access public\r\n */\n\n\nvar Result =\n/** @class */\nfunction () {\n  /**\r\n   * Inject the observer to be used.\r\n   * @constructor\r\n   * @access private\r\n   * @param {Promise<observer.ResultStreamObserver>} streamObserverPromise\r\n   * @param {mixed} query - Cypher query to execute\r\n   * @param {Object} parameters - Map with parameters to use in query\r\n   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\r\n   */\n  function Result(streamObserverPromise, query, parameters, connectionHolder) {\n    this._stack = captureStacktrace();\n    this._streamObserverPromise = streamObserverPromise;\n    this._p = null;\n    this._query = query;\n    this._parameters = parameters || {};\n    this._connectionHolder = connectionHolder || EMPTY_CONNECTION_HOLDER;\n  }\n  /**\r\n   * Returns a promise for the field keys.\r\n   *\r\n   * *Should not be combined with {@link Result#subscribe} function.*\r\n   *\r\n   * @public\r\n   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\r\n   }\r\n   */\n\n\n  Result.prototype.keys = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._streamObserverPromise.then(function (observer) {\n        return observer.subscribe({\n          onKeys: function (keys) {\n            return resolve(keys);\n          },\n          onError: function (err) {\n            return reject(err);\n          }\n        });\n      }).catch(reject);\n    });\n  };\n  /**\r\n   * Returns a promise for the result summary.\r\n   *\r\n   * *Should not be combined with {@link Result#subscribe} function.*\r\n   *\r\n   * @public\r\n   * @returns {Promise<ResultSummary>} - Result summary.\r\n   *\r\n   */\n\n\n  Result.prototype.summary = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._streamObserverPromise.then(function (o) {\n        o.cancel();\n        o.subscribe({\n          onCompleted: function (metadata) {\n            return _this._createSummary(metadata).then(resolve, reject);\n          },\n          onError: function (err) {\n            return reject(err);\n          }\n        });\n      }).catch(reject);\n    });\n  };\n  /**\r\n   * Create and return new Promise\r\n   *\r\n   * @private\r\n   * @return {Promise} new Promise.\r\n   */\n\n\n  Result.prototype._getOrCreatePromise = function () {\n    var _this = this;\n\n    if (!this._p) {\n      this._p = new Promise(function (resolve, reject) {\n        var records = [];\n        var observer = {\n          onNext: function (record) {\n            records.push(record);\n          },\n          onCompleted: function (summary) {\n            resolve({\n              records: records,\n              summary: summary\n            });\n          },\n          onError: function (error) {\n            reject(error);\n          }\n        };\n\n        _this.subscribe(observer);\n      });\n    }\n\n    return this._p;\n  };\n  /**\r\n   * Waits for all results and calls the passed in function with the results.\r\n   *\r\n   * *Should not be combined with {@link Result#subscribe} function.*\r\n   *\r\n   * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\r\n   * when finished.\r\n   * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\r\n   * @return {Promise} promise.\r\n   */\n\n\n  Result.prototype.then = function (onFulfilled, onRejected) {\n    return this._getOrCreatePromise().then(onFulfilled, onRejected);\n  };\n  /**\r\n   * Catch errors when using promises.\r\n   *\r\n   * *Should not be combined with {@link Result#subscribe} function.*\r\n   *\r\n   * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\r\n   * @return {Promise} promise.\r\n   */\n\n\n  Result.prototype.catch = function (onRejected) {\n    return this._getOrCreatePromise().catch(onRejected);\n  };\n\n  Result.prototype.finally = function (onfinally) {\n    return this._getOrCreatePromise().finally(onfinally);\n  };\n  /**\r\n   * Stream records to observer as they come in, this is a more efficient method\r\n   * of handling the results, and allows you to handle arbitrarily large results.\r\n   *\r\n   * @param {Object} observer - Observer object\r\n   * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\r\n   * @param {function(record: Record)} observer.onNext - handle records, one by one.\r\n   * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\r\n   * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\r\n   * @return {void}\r\n   */\n\n\n  Result.prototype.subscribe = function (observer) {\n    var _this = this;\n\n    var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n\n    var onCompletedWrapper = function (metadata) {\n      _this._createSummary(metadata).then(function (summary) {\n        return onCompletedOriginal.call(observer, summary);\n      });\n    };\n\n    observer.onCompleted = onCompletedWrapper;\n    var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n\n    var onErrorWrapper = function (error) {\n      // notify connection holder that the used connection is not needed any more because error happened\n      // and result can't bee consumed any further; call the original onError callback after that\n      _this._connectionHolder.releaseConnection().then(function () {\n        replaceStacktrace(error, _this._stack);\n        onErrorOriginal.call(observer, error);\n      });\n    };\n\n    observer.onError = onErrorWrapper;\n\n    this._streamObserverPromise.then(function (o) {\n      return o.subscribe(observer);\n    }).catch(function (error) {\n      return observer.onError(error);\n    });\n  };\n  /**\r\n   * Signals the stream observer that the future records should be discarded on the server.\r\n   *\r\n   * @protected\r\n   * @since 4.0.0\r\n   * @returns {void}\r\n   */\n\n\n  Result.prototype._cancel = function () {\n    this._streamObserverPromise.then(function (o) {\n      return o.cancel();\n    });\n  };\n\n  Result.prototype._createSummary = function (metadata) {\n    var _a = internal_1.util.validateQueryAndParameters(this._query, this._parameters, {\n      skipAsserts: true\n    }),\n        query = _a.validatedQuery,\n        parameters = _a.params;\n\n    var connectionHolder = this._connectionHolder;\n    return connectionHolder.getConnection().then( // onFulfilled:\n    function (connection) {\n      return connectionHolder.releaseConnection().then(function () {\n        return connection ? connection.protocol().version : undefined;\n      });\n    }, // onRejected:\n    function (_) {\n      return undefined;\n    }).then(function (protocolVersion) {\n      return new result_summary_1.default(query, parameters, metadata, protocolVersion);\n    });\n  };\n\n  return Result;\n}();\n\nSymbol.toStringTag;\n\nfunction captureStacktrace() {\n  var error = new Error('');\n\n  if (error.stack) {\n    return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n  }\n\n  return null;\n}\n/**\r\n * @private\r\n * @param {Error} error The error\r\n * @param {string| null} newStack The newStack\r\n * @returns {void}\r\n */\n\n\nfunction replaceStacktrace(error, newStack) {\n  if (newStack) {\n    // Error.prototype.toString() concatenates error.name and error.message nicely\n    // then we add the rest of the stack trace\n    error.stack = error.toString() + '\\n' + newStack;\n  }\n}\n\nexports.default = Result;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/result.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","result_summary_1","require","internal_1","EMPTY_CONNECTION_HOLDER","connectionHolder","DEFAULT_ON_ERROR","error","console","log","DEFAULT_ON_COMPLETED","summary","Result","streamObserverPromise","query","parameters","_stack","captureStacktrace","_streamObserverPromise","_p","_query","_parameters","_connectionHolder","prototype","keys","_this","Promise","resolve","reject","then","observer","subscribe","onKeys","onError","err","catch","o","cancel","onCompleted","metadata","_createSummary","_getOrCreatePromise","records","onNext","record","push","onFulfilled","onRejected","finally","onfinally","onCompletedOriginal","onCompletedWrapper","call","onErrorOriginal","onErrorWrapper","releaseConnection","replaceStacktrace","_cancel","_a","util","validateQueryAndParameters","skipAsserts","validatedQuery","params","getConnection","connection","protocol","version","undefined","_","protocolVersion","default","Symbol","toStringTag","Error","stack","replace","newStack","toString"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar result_summary_1 = __importDefault(require(\"./result-summary\"));\r\nvar internal_1 = require(\"./internal\");\r\nvar EMPTY_CONNECTION_HOLDER = internal_1.connectionHolder.EMPTY_CONNECTION_HOLDER;\r\n/**\r\n * @private\r\n * @param {Error} error The error\r\n * @returns {void}\r\n */\r\nvar DEFAULT_ON_ERROR = function (error) {\r\n    console.log('Uncaught error when processing result: ' + error);\r\n};\r\n/**\r\n * @private\r\n * @param {ResultSummary} summary\r\n * @returns {void}\r\n */\r\nvar DEFAULT_ON_COMPLETED = function (summary) { };\r\n/**\r\n * A stream of {@link Record} representing the result of a query.\r\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\r\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\r\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\r\n * @access public\r\n */\r\nvar Result = /** @class */ (function () {\r\n    /**\r\n     * Inject the observer to be used.\r\n     * @constructor\r\n     * @access private\r\n     * @param {Promise<observer.ResultStreamObserver>} streamObserverPromise\r\n     * @param {mixed} query - Cypher query to execute\r\n     * @param {Object} parameters - Map with parameters to use in query\r\n     * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\r\n     */\r\n    function Result(streamObserverPromise, query, parameters, connectionHolder) {\r\n        this._stack = captureStacktrace();\r\n        this._streamObserverPromise = streamObserverPromise;\r\n        this._p = null;\r\n        this._query = query;\r\n        this._parameters = parameters || {};\r\n        this._connectionHolder = connectionHolder || EMPTY_CONNECTION_HOLDER;\r\n    }\r\n    /**\r\n     * Returns a promise for the field keys.\r\n     *\r\n     * *Should not be combined with {@link Result#subscribe} function.*\r\n     *\r\n     * @public\r\n     * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\r\n     }\r\n     */\r\n    Result.prototype.keys = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this._streamObserverPromise\r\n                .then(function (observer) {\r\n                return observer.subscribe({\r\n                    onKeys: function (keys) { return resolve(keys); },\r\n                    onError: function (err) { return reject(err); }\r\n                });\r\n            })\r\n                .catch(reject);\r\n        });\r\n    };\r\n    /**\r\n     * Returns a promise for the result summary.\r\n     *\r\n     * *Should not be combined with {@link Result#subscribe} function.*\r\n     *\r\n     * @public\r\n     * @returns {Promise<ResultSummary>} - Result summary.\r\n     *\r\n     */\r\n    Result.prototype.summary = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this._streamObserverPromise\r\n                .then(function (o) {\r\n                o.cancel();\r\n                o.subscribe({\r\n                    onCompleted: function (metadata) {\r\n                        return _this._createSummary(metadata).then(resolve, reject);\r\n                    },\r\n                    onError: function (err) { return reject(err); }\r\n                });\r\n            })\r\n                .catch(reject);\r\n        });\r\n    };\r\n    /**\r\n     * Create and return new Promise\r\n     *\r\n     * @private\r\n     * @return {Promise} new Promise.\r\n     */\r\n    Result.prototype._getOrCreatePromise = function () {\r\n        var _this = this;\r\n        if (!this._p) {\r\n            this._p = new Promise(function (resolve, reject) {\r\n                var records = [];\r\n                var observer = {\r\n                    onNext: function (record) {\r\n                        records.push(record);\r\n                    },\r\n                    onCompleted: function (summary) {\r\n                        resolve({ records: records, summary: summary });\r\n                    },\r\n                    onError: function (error) {\r\n                        reject(error);\r\n                    }\r\n                };\r\n                _this.subscribe(observer);\r\n            });\r\n        }\r\n        return this._p;\r\n    };\r\n    /**\r\n     * Waits for all results and calls the passed in function with the results.\r\n     *\r\n     * *Should not be combined with {@link Result#subscribe} function.*\r\n     *\r\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\r\n     * when finished.\r\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\r\n     * @return {Promise} promise.\r\n     */\r\n    Result.prototype.then = function (onFulfilled, onRejected) {\r\n        return this._getOrCreatePromise().then(onFulfilled, onRejected);\r\n    };\r\n    /**\r\n     * Catch errors when using promises.\r\n     *\r\n     * *Should not be combined with {@link Result#subscribe} function.*\r\n     *\r\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\r\n     * @return {Promise} promise.\r\n     */\r\n    Result.prototype.catch = function (onRejected) {\r\n        return this._getOrCreatePromise().catch(onRejected);\r\n    };\r\n    Result.prototype.finally = function (onfinally) {\r\n        return this._getOrCreatePromise().finally(onfinally);\r\n    };\r\n    /**\r\n     * Stream records to observer as they come in, this is a more efficient method\r\n     * of handling the results, and allows you to handle arbitrarily large results.\r\n     *\r\n     * @param {Object} observer - Observer object\r\n     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\r\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\r\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\r\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\r\n     * @return {void}\r\n     */\r\n    Result.prototype.subscribe = function (observer) {\r\n        var _this = this;\r\n        var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\r\n        var onCompletedWrapper = function (metadata) {\r\n            _this._createSummary(metadata).then(function (summary) {\r\n                return onCompletedOriginal.call(observer, summary);\r\n            });\r\n        };\r\n        observer.onCompleted = onCompletedWrapper;\r\n        var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\r\n        var onErrorWrapper = function (error) {\r\n            // notify connection holder that the used connection is not needed any more because error happened\r\n            // and result can't bee consumed any further; call the original onError callback after that\r\n            _this._connectionHolder.releaseConnection().then(function () {\r\n                replaceStacktrace(error, _this._stack);\r\n                onErrorOriginal.call(observer, error);\r\n            });\r\n        };\r\n        observer.onError = onErrorWrapper;\r\n        this._streamObserverPromise\r\n            .then(function (o) {\r\n            return o.subscribe(observer);\r\n        })\r\n            .catch(function (error) { return observer.onError(error); });\r\n    };\r\n    /**\r\n     * Signals the stream observer that the future records should be discarded on the server.\r\n     *\r\n     * @protected\r\n     * @since 4.0.0\r\n     * @returns {void}\r\n     */\r\n    Result.prototype._cancel = function () {\r\n        this._streamObserverPromise.then(function (o) { return o.cancel(); });\r\n    };\r\n    Result.prototype._createSummary = function (metadata) {\r\n        var _a = internal_1.util.validateQueryAndParameters(this._query, this._parameters, {\r\n            skipAsserts: true\r\n        }), query = _a.validatedQuery, parameters = _a.params;\r\n        var connectionHolder = this._connectionHolder;\r\n        return connectionHolder\r\n            .getConnection()\r\n            .then(\r\n        // onFulfilled:\r\n        function (connection) {\r\n            return connectionHolder\r\n                .releaseConnection()\r\n                .then(function () {\r\n                return connection ? connection.protocol().version : undefined;\r\n            });\r\n        }, \r\n        // onRejected:\r\n        function (_) { return undefined; })\r\n            .then(function (protocolVersion) {\r\n            return new result_summary_1.default(query, parameters, metadata, protocolVersion);\r\n        });\r\n    };\r\n    return Result;\r\n}());\r\nSymbol.toStringTag;\r\nfunction captureStacktrace() {\r\n    var error = new Error('');\r\n    if (error.stack) {\r\n        return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * @private\r\n * @param {Error} error The error\r\n * @param {string| null} newStack The newStack\r\n * @returns {void}\r\n */\r\nfunction replaceStacktrace(error, newStack) {\r\n    if (newStack) {\r\n        // Error.prototype.toString() concatenates error.name and error.message nicely\r\n        // then we add the rest of the stack trace\r\n        error.stack = error.toString() + '\\n' + newStack;\r\n    }\r\n}\r\nexports.default = Result;\r\n"]},"metadata":{},"sourceType":"script"}