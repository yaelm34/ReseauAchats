{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar observers_1 = require(\"./internal/observers\");\n\nvar util_1 = require(\"./internal/util\");\n\nvar error_1 = require(\"./error\");\n\nvar result_1 = __importDefault(require(\"./result\"));\n\nvar transaction_1 = __importDefault(require(\"./transaction\"));\n\nvar connection_holder_1 = require(\"./internal/connection-holder\");\n\nvar constants_1 = require(\"./internal/constants\");\n\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\n\nvar bookmark_1 = require(\"./internal/bookmark\");\n\nvar tx_config_1 = require(\"./internal/tx-config\");\n/**\r\n * A Session instance is used for handling the connection and\r\n * sending queries through the connection.\r\n * In a single session, multiple queries will be executed serially.\r\n * In order to execute parallel queries, multiple sessions are required.\r\n * @access public\r\n */\n\n\nvar Session =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Object} args\r\n   * @param {string} args.mode the default access mode for this session.\r\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\r\n   * @param {Bookmark} args.bookmark - The initial bookmark for this session.\r\n   * @param {string} args.database the database name\r\n   * @param {Object} args.config={} - This driver configuration.\r\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\r\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\r\n   * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\r\n   */\n  function Session(_a) {\n    var mode = _a.mode,\n        connectionProvider = _a.connectionProvider,\n        bookmark = _a.bookmark,\n        database = _a.database,\n        config = _a.config,\n        reactive = _a.reactive,\n        fetchSize = _a.fetchSize,\n        impersonatedUser = _a.impersonatedUser;\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n    this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_READ,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_WRITE,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._impersonatedUser = impersonatedUser;\n    this._lastBookmark = bookmark || bookmark_1.Bookmark.empty();\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._databaseNameResolved = this._database !== '';\n  }\n  /**\r\n   * Run Cypher query\r\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\r\n   * or with the query and parameters as separate arguments.\r\n   *\r\n   * @public\r\n   * @param {mixed} query - Cypher query to execute\r\n   * @param {Object} parameters - Map with parameters to use in query\r\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\r\n   * @return {Result} New Result.\r\n   */\n\n\n  Session.prototype.run = function (query, parameters, transactionConfig) {\n    var _this = this;\n\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n        validatedQuery = _a.validatedQuery,\n        params = _a.params;\n\n    var autoCommitTxConfig = transactionConfig ? new tx_config_1.TxConfig(transactionConfig) : tx_config_1.TxConfig.empty();\n    return this._run(validatedQuery, params, function (connection) {\n      _this._assertSessionIsOpen();\n\n      return connection.protocol().run(validatedQuery, params, {\n        bookmark: _this._lastBookmark,\n        txConfig: autoCommitTxConfig,\n        mode: _this._mode,\n        database: _this._database,\n        impersonatedUser: _this._impersonatedUser,\n        afterComplete: _this._onComplete,\n        reactive: _this._reactive,\n        fetchSize: _this._fetchSize\n      });\n    });\n  };\n\n  Session.prototype._run = function (query, parameters, customRunner) {\n    var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n    var observerPromise;\n\n    if (!this._open) {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in a closed session.')\n      }));\n    } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n      observerPromise = connectionHolder.getConnection().then(function (connection) {\n        return customRunner(connection);\n      }).catch(function (error) {\n        return Promise.resolve(new observers_1.FailedObserver({\n          error: error\n        }));\n      });\n    } else {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')\n      }));\n    }\n\n    return new result_1.default(observerPromise, query, parameters, connectionHolder);\n  };\n\n  Session.prototype._acquireConnection = function (connectionConsumer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promise, connectionHolder;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        connectionHolder = this._connectionHolderWithMode(this._mode);\n\n        if (!this._open) {\n          promise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n          promise = connectionHolder.getConnection().then(function (connection) {\n            return connectionConsumer(connection);\n          }).then(function (result) {\n            return __awaiter(_this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , connectionHolder.releaseConnection()];\n\n                  case 1:\n                    _a.sent();\n\n                    return [2\n                    /*return*/\n                    , result];\n                }\n              });\n            });\n          });\n        } else {\n          promise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n        }\n\n        return [2\n        /*return*/\n        , promise];\n      });\n    });\n  };\n  /**\r\n   * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\r\n   * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\r\n   *\r\n   * While a transaction is open the session cannot be used to run queries outside the transaction.\r\n   *\r\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\r\n   * @returns {Transaction} New Transaction.\r\n   */\n\n\n  Session.prototype.beginTransaction = function (transactionConfig) {\n    // this function needs to support bookmarks parameter for backwards compatibility\n    // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n    // that's why we need to check parameter type and decide how to interpret the value\n    var arg = transactionConfig;\n    var txConfig = tx_config_1.TxConfig.empty();\n\n    if (arg) {\n      txConfig = new tx_config_1.TxConfig(arg);\n    }\n\n    return this._beginTransaction(this._mode, txConfig);\n  };\n\n  Session.prototype._beginTransaction = function (accessMode, txConfig) {\n    if (!this._open) {\n      throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n    }\n\n    if (this._hasTx) {\n      throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n    }\n\n    var mode = Session._validateSessionMode(accessMode);\n\n    var connectionHolder = this._connectionHolderWithMode(mode);\n\n    connectionHolder.initializeConnection();\n    this._hasTx = true;\n    var tx = new transaction_1.default({\n      connectionHolder: connectionHolder,\n      impersonatedUser: this._impersonatedUser,\n      onClose: this._transactionClosed.bind(this),\n      onBookmark: this._updateBookmark.bind(this),\n      onConnection: this._assertSessionIsOpen.bind(this),\n      reactive: this._reactive,\n      fetchSize: this._fetchSize\n    });\n\n    tx._begin(this._lastBookmark, txConfig);\n\n    return tx;\n  };\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  Session.prototype._assertSessionIsOpen = function () {\n    if (!this._open) {\n      throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n    }\n  };\n  /**\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  Session.prototype._transactionClosed = function () {\n    this._hasTx = false;\n  };\n  /**\r\n   * Return the bookmark received following the last completed {@link Transaction}.\r\n   *\r\n   * @return {string[]} A reference to a previous transaction.\r\n   */\n\n\n  Session.prototype.lastBookmark = function () {\n    return this._lastBookmark.values();\n  };\n  /**\r\n   * Execute given unit of work in a {@link READ} transaction.\r\n   *\r\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\r\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\r\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\r\n   * `maxTransactionRetryTime` property in milliseconds.\r\n   *\r\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\r\n   * a given {@link Transaction}.\r\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\r\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\r\n   * function or commit fails.\r\n   */\n\n\n  Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\r\n   * Execute given unit of work in a {@link WRITE} transaction.\r\n   *\r\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\r\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\r\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\r\n   * `maxTransactionRetryTime` property in milliseconds.\r\n   *\r\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\r\n   * a given {@link Transaction}.\r\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\r\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\r\n   * function or commit fails.\r\n   */\n\n\n  Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n\n  Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n\n    return this._transactionExecutor.execute(function () {\n      return _this._beginTransaction(accessMode, transactionConfig);\n    }, transactionWork);\n  };\n  /**\r\n   * Sets the resolved database name in the session context.\r\n   * @private\r\n   * @param {string|undefined} database The resolved database name\r\n   * @returns {void}\r\n   */\n\n\n  Session.prototype._onDatabaseNameResolved = function (database) {\n    if (!this._databaseNameResolved) {\n      var normalizedDatabase = database || '';\n      this._database = normalizedDatabase;\n\n      this._readConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._writeConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._databaseNameResolved = true;\n    }\n  };\n  /**\r\n   * Update value of the last bookmark.\r\n   * @private\r\n   * @param {Bookmark} newBookmark - The new bookmark.\r\n   * @returns {void}\r\n   */\n\n\n  Session.prototype._updateBookmark = function (newBookmark) {\n    if (newBookmark && !newBookmark.isEmpty()) {\n      this._lastBookmark = newBookmark;\n    }\n  };\n  /**\r\n   * Close this session.\r\n   * @return {Promise}\r\n   */\n\n\n  Session.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._open) return [3\n            /*break*/\n            , 3];\n            this._open = false;\n\n            this._transactionExecutor.close();\n\n            return [4\n            /*yield*/\n            , this._readConnectionHolder.close()];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._writeConnectionHolder.close()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Session.prototype._connectionHolderWithMode = function (mode) {\n    if (mode === constants_1.ACCESS_MODE_READ) {\n      return this._readConnectionHolder;\n    } else if (mode === constants_1.ACCESS_MODE_WRITE) {\n      return this._writeConnectionHolder;\n    } else {\n      throw (0, error_1.newError)('Unknown access mode: ' + mode);\n    }\n  };\n  /**\r\n   * @private\r\n   * @param {Object} meta Connection metadatada\r\n   * @returns {void}\r\n   */\n\n\n  Session.prototype._onCompleteCallback = function (meta) {\n    this._updateBookmark(new bookmark_1.Bookmark(meta.bookmark));\n  };\n  /**\r\n   * @protected\r\n   */\n\n\n  Session._validateSessionMode = function (rawMode) {\n    var mode = rawMode || constants_1.ACCESS_MODE_WRITE;\n\n    if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n      throw (0, error_1.newError)('Illegal session mode ' + mode);\n    }\n\n    return mode;\n  };\n\n  return Session;\n}();\n/**\r\n * @private\r\n * @param {object} config\r\n * @returns {TransactionExecutor} The transaction executor\r\n */\n\n\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\n\nexports.default = Session;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/session.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__importDefault","mod","__esModule","Object","defineProperty","exports","observers_1","require","util_1","error_1","result_1","transaction_1","connection_holder_1","constants_1","transaction_executor_1","bookmark_1","tx_config_1","Session","_a","mode","connectionProvider","bookmark","database","config","reactive","fetchSize","impersonatedUser","_mode","_database","_reactive","_fetchSize","_onDatabaseNameResolved","bind","_readConnectionHolder","ConnectionHolder","ACCESS_MODE_READ","onDatabaseNameResolved","_writeConnectionHolder","ACCESS_MODE_WRITE","_open","_hasTx","_impersonatedUser","_lastBookmark","Bookmark","empty","_transactionExecutor","_createTransactionExecutor","_onComplete","_onCompleteCallback","_databaseNameResolved","prototype","run","query","parameters","transactionConfig","_this","validateQueryAndParameters","validatedQuery","params","autoCommitTxConfig","TxConfig","_run","connection","_assertSessionIsOpen","protocol","txConfig","afterComplete","customRunner","connectionHolder","_connectionHolderWithMode","observerPromise","FailedObserver","error","newError","initializeConnection","getConnection","catch","default","_acquireConnection","connectionConsumer","promise","releaseConnection","beginTransaction","arg","_beginTransaction","accessMode","_validateSessionMode","tx","onClose","_transactionClosed","onBookmark","_updateBookmark","onConnection","_begin","lastBookmark","values","readTransaction","transactionWork","_runTransaction","writeTransaction","execute","normalizedDatabase","setDatabase","newBookmark","isEmpty","close","meta","rawMode","maxRetryTimeMs","maxTransactionRetryTime","TransactionExecutor"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar observers_1 = require(\"./internal/observers\");\r\nvar util_1 = require(\"./internal/util\");\r\nvar error_1 = require(\"./error\");\r\nvar result_1 = __importDefault(require(\"./result\"));\r\nvar transaction_1 = __importDefault(require(\"./transaction\"));\r\nvar connection_holder_1 = require(\"./internal/connection-holder\");\r\nvar constants_1 = require(\"./internal/constants\");\r\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\r\nvar bookmark_1 = require(\"./internal/bookmark\");\r\nvar tx_config_1 = require(\"./internal/tx-config\");\r\n/**\r\n * A Session instance is used for handling the connection and\r\n * sending queries through the connection.\r\n * In a single session, multiple queries will be executed serially.\r\n * In order to execute parallel queries, multiple sessions are required.\r\n * @access public\r\n */\r\nvar Session = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Object} args\r\n     * @param {string} args.mode the default access mode for this session.\r\n     * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\r\n     * @param {Bookmark} args.bookmark - The initial bookmark for this session.\r\n     * @param {string} args.database the database name\r\n     * @param {Object} args.config={} - This driver configuration.\r\n     * @param {boolean} args.reactive - Whether this session should create reactive streams\r\n     * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\r\n     * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\r\n     */\r\n    function Session(_a) {\r\n        var mode = _a.mode, connectionProvider = _a.connectionProvider, bookmark = _a.bookmark, database = _a.database, config = _a.config, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser;\r\n        this._mode = mode;\r\n        this._database = database;\r\n        this._reactive = reactive;\r\n        this._fetchSize = fetchSize;\r\n        this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\r\n        this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\r\n            mode: constants_1.ACCESS_MODE_READ,\r\n            database: database,\r\n            bookmark: bookmark,\r\n            connectionProvider: connectionProvider,\r\n            impersonatedUser: impersonatedUser,\r\n            onDatabaseNameResolved: this._onDatabaseNameResolved\r\n        });\r\n        this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\r\n            mode: constants_1.ACCESS_MODE_WRITE,\r\n            database: database,\r\n            bookmark: bookmark,\r\n            connectionProvider: connectionProvider,\r\n            impersonatedUser: impersonatedUser,\r\n            onDatabaseNameResolved: this._onDatabaseNameResolved\r\n        });\r\n        this._open = true;\r\n        this._hasTx = false;\r\n        this._impersonatedUser = impersonatedUser;\r\n        this._lastBookmark = bookmark || bookmark_1.Bookmark.empty();\r\n        this._transactionExecutor = _createTransactionExecutor(config);\r\n        this._onComplete = this._onCompleteCallback.bind(this);\r\n        this._databaseNameResolved = this._database !== '';\r\n    }\r\n    /**\r\n     * Run Cypher query\r\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\r\n     * or with the query and parameters as separate arguments.\r\n     *\r\n     * @public\r\n     * @param {mixed} query - Cypher query to execute\r\n     * @param {Object} parameters - Map with parameters to use in query\r\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\r\n     * @return {Result} New Result.\r\n     */\r\n    Session.prototype.run = function (query, parameters, transactionConfig) {\r\n        var _this = this;\r\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\r\n        var autoCommitTxConfig = transactionConfig\r\n            ? new tx_config_1.TxConfig(transactionConfig)\r\n            : tx_config_1.TxConfig.empty();\r\n        return this._run(validatedQuery, params, function (connection) {\r\n            _this._assertSessionIsOpen();\r\n            return connection.protocol().run(validatedQuery, params, {\r\n                bookmark: _this._lastBookmark,\r\n                txConfig: autoCommitTxConfig,\r\n                mode: _this._mode,\r\n                database: _this._database,\r\n                impersonatedUser: _this._impersonatedUser,\r\n                afterComplete: _this._onComplete,\r\n                reactive: _this._reactive,\r\n                fetchSize: _this._fetchSize\r\n            });\r\n        });\r\n    };\r\n    Session.prototype._run = function (query, parameters, customRunner) {\r\n        var connectionHolder = this._connectionHolderWithMode(this._mode);\r\n        var observerPromise;\r\n        if (!this._open) {\r\n            observerPromise = Promise.resolve(new observers_1.FailedObserver({\r\n                error: (0, error_1.newError)('Cannot run query in a closed session.')\r\n            }));\r\n        }\r\n        else if (!this._hasTx && connectionHolder.initializeConnection()) {\r\n            observerPromise = connectionHolder\r\n                .getConnection()\r\n                .then(function (connection) { return customRunner(connection); })\r\n                .catch(function (error) { return Promise.resolve(new observers_1.FailedObserver({ error: error })); });\r\n        }\r\n        else {\r\n            observerPromise = Promise.resolve(new observers_1.FailedObserver({\r\n                error: (0, error_1.newError)('Queries cannot be run directly on a ' +\r\n                    'session with an open transaction; either run from within the ' +\r\n                    'transaction or use a different session.')\r\n            }));\r\n        }\r\n        return new result_1.default(observerPromise, query, parameters, connectionHolder);\r\n    };\r\n    Session.prototype._acquireConnection = function (connectionConsumer) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var promise, connectionHolder;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                connectionHolder = this._connectionHolderWithMode(this._mode);\r\n                if (!this._open) {\r\n                    promise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\r\n                }\r\n                else if (!this._hasTx && connectionHolder.initializeConnection()) {\r\n                    promise = connectionHolder\r\n                        .getConnection()\r\n                        .then(function (connection) { return connectionConsumer(connection); })\r\n                        .then(function (result) { return __awaiter(_this, void 0, void 0, function () {\r\n                        return __generator(this, function (_a) {\r\n                            switch (_a.label) {\r\n                                case 0: return [4 /*yield*/, connectionHolder.releaseConnection()];\r\n                                case 1:\r\n                                    _a.sent();\r\n                                    return [2 /*return*/, result];\r\n                            }\r\n                        });\r\n                    }); });\r\n                }\r\n                else {\r\n                    promise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' +\r\n                        'session with an open transaction; either run from within the ' +\r\n                        'transaction or use a different session.'));\r\n                }\r\n                return [2 /*return*/, promise];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\r\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\r\n     *\r\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\r\n     *\r\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\r\n     * @returns {Transaction} New Transaction.\r\n     */\r\n    Session.prototype.beginTransaction = function (transactionConfig) {\r\n        // this function needs to support bookmarks parameter for backwards compatibility\r\n        // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\r\n        // that's why we need to check parameter type and decide how to interpret the value\r\n        var arg = transactionConfig;\r\n        var txConfig = tx_config_1.TxConfig.empty();\r\n        if (arg) {\r\n            txConfig = new tx_config_1.TxConfig(arg);\r\n        }\r\n        return this._beginTransaction(this._mode, txConfig);\r\n    };\r\n    Session.prototype._beginTransaction = function (accessMode, txConfig) {\r\n        if (!this._open) {\r\n            throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\r\n        }\r\n        if (this._hasTx) {\r\n            throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' +\r\n                'either run from within the transaction or use a different session.');\r\n        }\r\n        var mode = Session._validateSessionMode(accessMode);\r\n        var connectionHolder = this._connectionHolderWithMode(mode);\r\n        connectionHolder.initializeConnection();\r\n        this._hasTx = true;\r\n        var tx = new transaction_1.default({\r\n            connectionHolder: connectionHolder,\r\n            impersonatedUser: this._impersonatedUser,\r\n            onClose: this._transactionClosed.bind(this),\r\n            onBookmark: this._updateBookmark.bind(this),\r\n            onConnection: this._assertSessionIsOpen.bind(this),\r\n            reactive: this._reactive,\r\n            fetchSize: this._fetchSize\r\n        });\r\n        tx._begin(this._lastBookmark, txConfig);\r\n        return tx;\r\n    };\r\n    /**\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    Session.prototype._assertSessionIsOpen = function () {\r\n        if (!this._open) {\r\n            throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    Session.prototype._transactionClosed = function () {\r\n        this._hasTx = false;\r\n    };\r\n    /**\r\n     * Return the bookmark received following the last completed {@link Transaction}.\r\n     *\r\n     * @return {string[]} A reference to a previous transaction.\r\n     */\r\n    Session.prototype.lastBookmark = function () {\r\n        return this._lastBookmark.values();\r\n    };\r\n    /**\r\n     * Execute given unit of work in a {@link READ} transaction.\r\n     *\r\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\r\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\r\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\r\n     * `maxTransactionRetryTime` property in milliseconds.\r\n     *\r\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\r\n     * a given {@link Transaction}.\r\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\r\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\r\n     * function or commit fails.\r\n     */\r\n    Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\r\n        var config = new tx_config_1.TxConfig(transactionConfig);\r\n        return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\r\n    };\r\n    /**\r\n     * Execute given unit of work in a {@link WRITE} transaction.\r\n     *\r\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\r\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\r\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\r\n     * `maxTransactionRetryTime` property in milliseconds.\r\n     *\r\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\r\n     * a given {@link Transaction}.\r\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\r\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\r\n     * function or commit fails.\r\n     */\r\n    Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\r\n        var config = new tx_config_1.TxConfig(transactionConfig);\r\n        return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\r\n    };\r\n    Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\r\n        var _this = this;\r\n        return this._transactionExecutor.execute(function () { return _this._beginTransaction(accessMode, transactionConfig); }, transactionWork);\r\n    };\r\n    /**\r\n     * Sets the resolved database name in the session context.\r\n     * @private\r\n     * @param {string|undefined} database The resolved database name\r\n     * @returns {void}\r\n     */\r\n    Session.prototype._onDatabaseNameResolved = function (database) {\r\n        if (!this._databaseNameResolved) {\r\n            var normalizedDatabase = database || '';\r\n            this._database = normalizedDatabase;\r\n            this._readConnectionHolder.setDatabase(normalizedDatabase);\r\n            this._writeConnectionHolder.setDatabase(normalizedDatabase);\r\n            this._databaseNameResolved = true;\r\n        }\r\n    };\r\n    /**\r\n     * Update value of the last bookmark.\r\n     * @private\r\n     * @param {Bookmark} newBookmark - The new bookmark.\r\n     * @returns {void}\r\n     */\r\n    Session.prototype._updateBookmark = function (newBookmark) {\r\n        if (newBookmark && !newBookmark.isEmpty()) {\r\n            this._lastBookmark = newBookmark;\r\n        }\r\n    };\r\n    /**\r\n     * Close this session.\r\n     * @return {Promise}\r\n     */\r\n    Session.prototype.close = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this._open) return [3 /*break*/, 3];\r\n                        this._open = false;\r\n                        this._transactionExecutor.close();\r\n                        return [4 /*yield*/, this._readConnectionHolder.close()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this._writeConnectionHolder.close()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        _a.label = 3;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Session.prototype._connectionHolderWithMode = function (mode) {\r\n        if (mode === constants_1.ACCESS_MODE_READ) {\r\n            return this._readConnectionHolder;\r\n        }\r\n        else if (mode === constants_1.ACCESS_MODE_WRITE) {\r\n            return this._writeConnectionHolder;\r\n        }\r\n        else {\r\n            throw (0, error_1.newError)('Unknown access mode: ' + mode);\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {Object} meta Connection metadatada\r\n     * @returns {void}\r\n     */\r\n    Session.prototype._onCompleteCallback = function (meta) {\r\n        this._updateBookmark(new bookmark_1.Bookmark(meta.bookmark));\r\n    };\r\n    /**\r\n     * @protected\r\n     */\r\n    Session._validateSessionMode = function (rawMode) {\r\n        var mode = rawMode || constants_1.ACCESS_MODE_WRITE;\r\n        if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\r\n            throw (0, error_1.newError)('Illegal session mode ' + mode);\r\n        }\r\n        return mode;\r\n    };\r\n    return Session;\r\n}());\r\n/**\r\n * @private\r\n * @param {object} config\r\n * @returns {TransactionExecutor} The transaction executor\r\n */\r\nfunction _createTransactionExecutor(config) {\r\n    var maxRetryTimeMs = config && config.maxTransactionRetryTime\r\n        ? config.maxTransactionRetryTime\r\n        : null;\r\n    return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\r\n}\r\nexports.default = Session;\r\n"]},"metadata":{},"sourceType":"script"}