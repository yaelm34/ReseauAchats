{"ast":null,"code":"/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { scan } from './scan';\nimport { defer } from '../observable/defer';\nimport { map } from './map';\nexport function timeInterval(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    return defer(function () {\n      return source.pipe(scan(function (_a, value) {\n        var current = _a.current;\n        return {\n          value: value,\n          current: scheduler.now(),\n          last: current\n        };\n      }, {\n        current: scheduler.now(),\n        value: undefined,\n        last: undefined\n      }), map(function (_a) {\n        var current = _a.current,\n            last = _a.last,\n            value = _a.value;\n        return new TimeInterval(value, current - last);\n      }));\n    });\n  };\n}\n\nvar TimeInterval = /*@__PURE__*/function () {\n  function TimeInterval(value, interval) {\n    this.value = value;\n    this.interval = interval;\n  }\n\n  return TimeInterval;\n}();\n\nexport { TimeInterval };","map":{"version":3,"mappings":"AAEA;AAEA,SAASA,KAAT,QAAqB,oBAArB;AACA,SAASC,IAAT,QAAgB,QAAhB;AACA,SAASC,KAAT,QAAoB,qBAApB;AA+CA,SAAMC,GAAN,QAAgB,OAAhB;OAAgC;AAC9B,eAAO,KAAC,KAAqB,CAA7B,EAA6B;AAC3BC,aAAO,QAAP;;;mBAG6BC,QAAO;AAAR,WACtBH,KAAO,aAAY;aAEMG,iBAAO,UAAEC,EAAF,EAAEC,KAAF,EAAQ;AAAY,mBAAI,aAAJ;AACxD;AAAAA;AAAAC;AAAAC;AAAA;AACD,OAF8B,EAE9B;AAAAD;AAAAD;AAAAE;AAAA,OAF8B,GAE9BN;AACJ;AAAA;AAAA;AAQD;AACE,OAVG,CAF8B;AAYd,KAdJ,CADe;;;;IAgBhCO,4BAAC;AAFD,WAECA,YAFD,CAECH,KAFD,EAECI,QAFD,EAEC;;;;;;CAAA","names":["async","scan","defer","map","scheduler","source","_a","value","current","last","TimeInterval","interval"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\timeInterval.ts"],"sourcesContent":["\r\nimport { Observable } from '../Observable';\r\nimport { async } from '../scheduler/async';\r\nimport { SchedulerLike, OperatorFunction } from '../types';\r\nimport { scan } from './scan';\r\nimport { defer } from '../observable/defer';\r\nimport { map } from './map';\r\n\r\n/**\r\n *\r\n * Emits an object containing the current value, and the time that has\r\n * passed between emitting the current value and the previous value, which is\r\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\r\n * the current time at each emission, then calculating the difference. The `scheduler`\r\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\r\n * milliseconds.\r\n *\r\n * <span class=\"informal\">Convert an Observable that emits items into one that\r\n * emits indications of the amount of time elapsed between those emissions.</span>\r\n *\r\n * ![](timeinterval.png)\r\n *\r\n * ## Examples\r\n * Emit inteval between current value with the last value\r\n *\r\n * ```ts\r\n * const seconds = interval(1000);\r\n *\r\n * seconds.pipe(timeInterval())\r\n * .subscribe(\r\n *     value => console.log(value),\r\n *     err => console.log(err),\r\n * );\r\n *\r\n * seconds.pipe(timeout(900))\r\n * .subscribe(\r\n *     value => console.log(value),\r\n *     err => console.log(err),\r\n * );\r\n *\r\n * // NOTE: The values will never be this precise,\r\n * // intervals created with `interval` or `setInterval`\r\n * // are non-deterministic.\r\n *\r\n * // {value: 0, interval: 1000}\r\n * // {value: 1, interval: 1000}\r\n * // {value: 2, interval: 1000}\r\n * ```\r\n *\r\n * @param {SchedulerLike} [scheduler] Scheduler used to get the current time.\r\n * @return {Observable<{ interval: number, value: T }>} Observable that emit infomation about value and interval\r\n * @method timeInterval\r\n */\r\nexport function timeInterval<T>(scheduler: SchedulerLike = async): OperatorFunction<T, TimeInterval<T>> {\r\n  return (source: Observable<T>) => defer(() => {\r\n    return source.pipe(\r\n      // TODO(benlesh): correct these typings.\r\n      scan(\r\n        ({ current }, value) => ({ value, current: scheduler.now(), last: current }),\r\n        { current: scheduler.now(), value: undefined,  last: undefined }\r\n      ) as any,\r\n      map<any, TimeInterval<T>>(({ current, last, value }) => new TimeInterval(value, current - last)),\r\n    );\r\n  });\r\n}\r\n\r\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\r\n// there's no reason users should be manually creating this type.\r\n\r\n/**\r\n * @deprecated exposed API, use as interface only.\r\n */\r\nexport class TimeInterval<T> {\r\n  constructor(public value: T, public interval: number) {}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}