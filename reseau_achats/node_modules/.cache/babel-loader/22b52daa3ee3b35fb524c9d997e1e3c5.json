{"ast":null,"code":"/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */\nimport { connectableObservableDescriptor } from '../observable/ConnectableObservable';\nexport function multicast(subjectOrSubjectFactory, selector) {\n  return function multicastOperatorFunction(source) {\n    var subjectFactory;\n\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    var connectable = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n  };\n}\n\nvar MulticastOperator = /*@__PURE__*/function () {\n  function MulticastOperator(subjectFactory, selector) {\n    this.subjectFactory = subjectFactory;\n    this.selector = selector;\n  }\n\n  MulticastOperator.prototype.call = function (subscriber, source) {\n    var selector = this.selector;\n    var subject = this.subjectFactory();\n    var subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  };\n\n  return MulticastOperator;\n}();\n\nexport { MulticastOperator };","map":{"version":3,"mappings":"AAIA;AA6BA,SAAMA,+BAAN,QAAgC,qCAAhC;OAEE,SAAOC,SAAP,CAAgBC,uBAAhB,EAA0CC,QAA1C,EAA+D;SAC7D,SAAIC,yBAAJ,CAAqCC,MAArC,EAAqC;AACrC,QAAIC,cAAJ;;QACE,mCAAmC,YAAwB;AAC5DA;WACC;oBACqB,6BAAwB;AAC3C;AACH;AAED;;QACE,OAAOH,QAAP,KAAmB,YAAI;AACxB;AAED;;AACA,mBAAY,GAAMI,MAAG,OAAH,CAAUF,MAAV,EAAUL,+BAAV,CAAlB;AACAQ,eAAW,CAACH,MAAZ,GAAYA,MAAZ;AAEAG,eAAkC,eAAlC,GAA8CF,cAA9C;AACA;AACH;AAED;;IACEG,iCAAoB,YACA;WADAA,kCAAgCN;AAChC;AACnB;AACD;;mBACU,kBAAkB;AAC1B,QAAMA,QAAO,GAAG,KAAKA,QAArB;AACA,QAAMO,eAAeJ,cAAf,EAAN;AACA,oBAAgB,GAACH,QAAO,SAAP,CAAiBQ,SAAjB,CAA2BC,UAA3B,CAAjB;AACAC,gBAAO,IAAP,CAAOR,MAAa,UAAb,CAAaK,OAAb,CAAP;AACD;AACH;;AAXA,SAWCD,iBAXD;CACsB","names":["connectableObservableDescriptor","multicast","subjectOrSubjectFactory","selector","multicastOperatorFunction","source","subjectFactory","Object","connectable","MulticastOperator","subject","subscribe","subscriber","subscription"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\multicast.ts"],"sourcesContent":["import { Subject } from '../Subject';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\r\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\r\nexport function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;\r\nexport function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\r\nexport function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Returns an Observable that emits the results of invoking a specified selector on items\r\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\r\n *\r\n * ![](multicast.png)\r\n *\r\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\r\n * which the source sequence's elements will be multicast to the selector function\r\n * or Subject to push source elements into.\r\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\r\n * as many times as needed, without causing multiple subscriptions to the source stream.\r\n * Subscribers to the given source will receive all notifications of the source from the\r\n * time of the subscription forward.\r\n * @return {Observable} An Observable that emits the results of invoking the selector\r\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\r\n * the underlying stream.\r\n * @method multicast\r\n * @owner Observable\r\n */\r\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\r\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\r\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\r\n    let subjectFactory: () => Subject<T>;\r\n    if (typeof subjectOrSubjectFactory === 'function') {\r\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\r\n    } else {\r\n      subjectFactory = function subjectFactory() {\r\n        return <Subject<T>>subjectOrSubjectFactory;\r\n      };\r\n    }\r\n\r\n    if (typeof selector === 'function') {\r\n      return source.lift(new MulticastOperator(subjectFactory, selector));\r\n    }\r\n\r\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\r\n    connectable.source = source;\r\n    connectable.subjectFactory = subjectFactory;\r\n\r\n    return <ConnectableObservable<R>> connectable;\r\n  };\r\n}\r\n\r\nexport class MulticastOperator<T, R> implements Operator<T, R> {\r\n  constructor(private subjectFactory: () => Subject<T>,\r\n              private selector: (source: Observable<T>) => Observable<R>) {\r\n  }\r\n  call(subscriber: Subscriber<R>, source: any): any {\r\n    const { selector } = this;\r\n    const subject = this.subjectFactory();\r\n    const subscription = selector(subject).subscribe(subscriber);\r\n    subscription.add(source.subscribe(subject));\r\n    return subscription;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}