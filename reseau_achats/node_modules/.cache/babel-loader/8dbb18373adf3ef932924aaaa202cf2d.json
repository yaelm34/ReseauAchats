{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\nexport function windowCount(windowSize, startWindowEvery) {\n  if (startWindowEvery === void 0) {\n    startWindowEvery = 0;\n  }\n\n  return function windowCountOperatorFunction(source) {\n    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n  };\n}\n\nvar WindowCountOperator = /*@__PURE__*/function () {\n  function WindowCountOperator(windowSize, startWindowEvery) {\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n  }\n\n  WindowCountOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  };\n\n  return WindowCountOperator;\n}();\n\nvar WindowCountSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(WindowCountSubscriber, _super);\n\n  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.windowSize = windowSize;\n    _this.startWindowEvery = startWindowEvery;\n    _this.windows = [new Subject()];\n    _this.count = 0;\n    destination.next(_this.windows[0]);\n    return _this;\n  }\n\n  WindowCountSubscriber.prototype._next = function (value) {\n    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    var destination = this.destination;\n    var windowSize = this.windowSize;\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n\n    var c = this.count - windowSize + 1;\n\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      var window_1 = new Subject();\n      windows.push(window_1);\n      destination.next(window_1);\n    }\n  };\n\n  WindowCountSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowCountSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowCountSubscriber.prototype._unsubscribe = function () {\n    this.count = 0;\n    this.windows = null;\n  };\n\n  return WindowCountSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAEA,SAASC,UAAT,QAAwB,eAAxB;AAkEA,SAAMC,OAAN,QAAgB,YAAhB;OAC+B;AAC7B,sBAAgB,WAAhB,EAAgB;AACdC,oBAAc,GAAK,CAAnB;AACD;;AACF;AAED;AAEE,GAJD;;;uBAKqB,4BAAwB;AAC5C,WAACC,mBAAD,CAACC,UAAD,EAACF,gBAAD,EAAC;AAED;AACE,4BAAwBA,gBAAxB;AACD;;AACHC,gCAACE,IAAD,GAAC;AAAA;AAOD,GAPA;;AAOuC;CAbjB;;yBAoBlB,gBAAM,UAAYC,MAAZ,EAEP;SALqB,kCAAsCA;;WACxCC,mCAAkBH;AAClB,4BAAgB,IAAhB,kBAAwB,IAAxB;;AALZI,wBAA0BC,WAA1B;AACAD,uBAAkBJ,UAAlB;AAMNI,6BAAsBN,gBAAtB;;AACDM;AAESC;AACR,WAAMD,KAAN;;;uBAEmB,WAAKE,QAAW;AACnC,QAAMR,gBAAe,QAAQA,gBAAR,GAAQ,CAAR,GAAQ,qBAAR,GAAQ,eAA7B;AACA,QAAMO,WAAM,GAAQ,gBAApB;AAEA,kBAAc,GAAG,KAAGL,UAApB;QACEO,OAAO,GAAG,KAAKA;QAChBC;;AACD,SAAO,IAAGC,IAAK,CAAf,EAAeA,IAAKD,GAAL,IAAQ,MAAUE,MAAjC,EAAsCD,GAAtC,EAAsC;AAClCF,aAAM,GAAN,CAAWI,IAAX,CAAcC,KAAd;;;QAEHC;;AACD,QAAIA,KAAE,CAAF,IAAOA,IAAKf,gBAAL,KAAwB,CAA/B,IAAqC,CAAI,KAAKY,MAAlD,EAAyD;AACvDH,aAAM,MAAN,GAAeO,QAAf;;;QAEA,eAAYhB,gBAAZ,KAAyB,CAAzB,IAAyB;AAC1B;AACFS;AAESF;AACR;;;uBAES,CAAOU,UAAUC,SAAM,UAAaC,GAAb,EAAa;eACzC,QAAQV;;iBACT;AACF;AACIA,gBAAWW,KAAX,GAAkBC,KAAlB,CAAuBF,GAAvB;AACN;AAES;;AACR,SAAMZ,WAAN,CAAgBc,KAAhB,CAAqBF,GAArB;;;uBAES,CAAOF,UAAUK,YAAW,YAAQ;eACzC,QAAQb;;iBACT;AACF;AACIA,gBAAWW,KAAX,GAAYJ,QAAZ;AACN;AAES;;AACR,SAAKT,WAAL,CAAeS,QAAf;;;AAEFX,uBAAC,UAAD,CAACkB,YAAD,GAAC;AACH;AAxDuC,SAAUd,OAAV,GAwDtC,IAxDsC;GAuDrC;;;CAhDQ","names":["tslib_1","Subscriber","Subject","startWindowEvery","WindowCountOperator","windowSize","call","_super","WindowCountSubscriber","_this","destination","_next","windows","len","i","closed","next","value","c","complete","prototype","_error","err","shift","error","_complete","_unsubscribe"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\windowCount.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { Subject } from '../Subject';\r\nimport { OperatorFunction } from '../types';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable with each\r\n * nested Observable emitting at most `windowSize` values.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowCount.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable emits windows every `startWindowEvery`\r\n * items, each containing no more than `windowSize` items. When the source\r\n * Observable completes or encounters an error, the output Observable emits\r\n * the current window and propagates the notification from the source\r\n * Observable. If `startWindowEvery` is not provided, then new windows are\r\n * started immediately at the start of the source and when each window completes\r\n * with size `windowSize`.\r\n *\r\n * ## Examples\r\n * Ignore every 3rd click event, starting from the first one\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { windowCount, map, mergeAll, skip } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowCount(3),\r\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\r\n *   mergeAll()                     // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Ignore every 3rd click event, starting from the third one\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { windowCount, mergeAll } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowCount(2, 3),\r\n *   mergeAll(),              // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowTime}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferCount}\r\n *\r\n * @param {number} windowSize The maximum number of values emitted by each\r\n * window.\r\n * @param {number} [startWindowEvery] Interval at which to start a new window.\r\n * For example if `startWindowEvery` is `2`, then a new window will be started\r\n * on every other value from the source. A new window is started at the\r\n * beginning of the source by default.\r\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\r\n * are Observable of values.\r\n * @method windowCount\r\n * @owner Observable\r\n */\r\nexport function windowCount<T>(windowSize: number,\r\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\r\n  return function windowCountOperatorFunction(source: Observable<T>) {\r\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\r\n  };\r\n}\r\n\r\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\r\n\r\n  constructor(private windowSize: number,\r\n              private startWindowEvery: number) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\r\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass WindowCountSubscriber<T> extends Subscriber<T> {\r\n  private windows: Subject<T>[] = [ new Subject<T>() ];\r\n  private count: number = 0;\r\n\r\n  constructor(protected destination: Subscriber<Observable<T>>,\r\n              private windowSize: number,\r\n              private startWindowEvery: number) {\r\n    super(destination);\r\n    destination.next(this.windows[0]);\r\n  }\r\n\r\n  protected _next(value: T) {\r\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\r\n    const destination = this.destination;\r\n    const windowSize = this.windowSize;\r\n    const windows = this.windows;\r\n    const len = windows.length;\r\n\r\n    for (let i = 0; i < len && !this.closed; i++) {\r\n      windows[i].next(value);\r\n    }\r\n    const c = this.count - windowSize + 1;\r\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\r\n      windows.shift().complete();\r\n    }\r\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\r\n      const window = new Subject<T>();\r\n      windows.push(window);\r\n      destination.next(window);\r\n    }\r\n  }\r\n\r\n  protected _error(err: any) {\r\n    const windows = this.windows;\r\n    if (windows) {\r\n      while (windows.length > 0 && !this.closed) {\r\n        windows.shift().error(err);\r\n      }\r\n    }\r\n    this.destination.error(err);\r\n  }\r\n\r\n  protected _complete() {\r\n    const windows = this.windows;\r\n    if (windows) {\r\n      while (windows.length > 0 && !this.closed) {\r\n        windows.shift().complete();\r\n      }\r\n    }\r\n    this.destination.complete();\r\n  }\r\n\r\n  protected _unsubscribe() {\r\n    this.count = 0;\r\n    this.windows = null;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}