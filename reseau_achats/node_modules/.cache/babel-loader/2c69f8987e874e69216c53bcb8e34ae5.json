{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function mapTo(value) {\n  return function (source) {\n    return source.lift(new MapToOperator(value));\n  };\n}\n\nvar MapToOperator = /*@__PURE__*/function () {\n  function MapToOperator(value) {\n    this.value = value;\n  }\n\n  MapToOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\n  };\n\n  return MapToOperator;\n}();\n\nvar MapToSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(MapToSubscriber, _super);\n\n  function MapToSubscriber(destination, value) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.value = value;\n    return _this;\n  }\n\n  MapToSubscriber.prototype._next = function (x) {\n    this.destination.next(this.value);\n  };\n\n  return MapToSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAoCA,SAAMC,UAAN,QAAoC,eAApC;OACE,SAAOC,KAAP,CAAQC,KAAR,EAA6B;AAC9B;AAAA;AAAA;AAED;;IAIEC,6BAAoB;WACbA,cAAcD;AACpB;AAED;;eACS,WAAOE,OAAU,UAAIC,UAAJ,EAAoBC,MAApB,EAAgC;AACzD;AACH;;AAXA,SAWCH,aAXD;AAkBA,CAdsB;;IAccI,yCAAaC,MAAb,EAAa;AAI/CT,qCAAYS,MAAZ;;WAAAD,gBACEE,aAAMP,OAAW;AACjB,aAAK,GAAKM,MAAG,CAAKJ,IAAR,CAAS,IAAT,EAASK,WAAT,KAAS,IAAnB;;;AACD;AAES;;iBACH,WAAiBC,QAAK,UAAOC,CAAP,EAAO;AACnC;AACH;;AAZoC;CAAA","names":["tslib_1","Subscriber","mapTo","value","MapToOperator","call","subscriber","source","MapToSubscriber","_super","destination","_next","x"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\mapTo.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { OperatorFunction } from '../types';\r\n\r\n/**\r\n * Emits the given constant value on the output Observable every time the source\r\n * Observable emits a value.\r\n *\r\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\r\n * the same output value every time.</span>\r\n *\r\n * ![](mapTo.png)\r\n *\r\n * Takes a constant `value` as argument, and emits that whenever the source\r\n * Observable emits a value. In other words, ignores the actual source value,\r\n * and simply uses the emission moment to know when to emit the given `value`.\r\n *\r\n * ## Example\r\n * Map every click to the string 'Hi'\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { mapTo } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const greetings = clicks.pipe(mapTo('Hi'));\r\n * greetings.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link map}\r\n *\r\n * @param {any} value The value to map each source value to.\r\n * @return {Observable} An Observable that emits the given `value` every time\r\n * the source Observable emits something.\r\n * @method mapTo\r\n * @owner Observable\r\n */\r\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R> {\r\n  return (source: Observable<T>) => source.lift(new MapToOperator(value));\r\n}\r\n\r\nclass MapToOperator<T, R> implements Operator<T, R> {\r\n\r\n  value: R;\r\n\r\n  constructor(value: R) {\r\n    this.value = value;\r\n  }\r\n\r\n  call(subscriber: Subscriber<R>, source: any): any {\r\n    return source.subscribe(new MapToSubscriber(subscriber, this.value));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass MapToSubscriber<T, R> extends Subscriber<T> {\r\n\r\n  value: R;\r\n\r\n  constructor(destination: Subscriber<R>, value: R) {\r\n    super(destination);\r\n    this.value = value;\r\n  }\r\n\r\n  protected _next(x: T) {\r\n    this.destination.next(this.value);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}