{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { map } from '../operators/map';\nimport { canReportError } from '../util/canReportError';\nimport { isScheduler } from '../util/isScheduler';\nimport { isArray } from '../util/isArray';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) {\n          return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);\n        }));\n      };\n    }\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var params = {\n      subject: undefined,\n      args: args,\n      callbackFunc: callbackFunc,\n      scheduler: scheduler,\n      context: this\n    };\n    return new Observable(function (subscriber) {\n      var context = params.context;\n      var subject = params.subject;\n\n      if (!scheduler) {\n        if (!subject) {\n          subject = params.subject = new AsyncSubject();\n\n          var handler = function () {\n            var innerArgs = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              innerArgs[_i] = arguments[_i];\n            }\n\n            var err = innerArgs.shift();\n\n            if (err) {\n              subject.error(err);\n              return;\n            }\n\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          };\n\n          try {\n            callbackFunc.apply(context, args.concat([handler]));\n          } catch (err) {\n            if (canReportError(subject)) {\n              subject.error(err);\n            } else {\n              console.warn(err);\n            }\n          }\n        }\n\n        return subject.subscribe(subscriber);\n      } else {\n        return scheduler.schedule(dispatch, 0, {\n          params: params,\n          subscriber: subscriber,\n          context: context\n        });\n      }\n    });\n  };\n}\n\nfunction dispatch(state) {\n  var _this = this;\n\n  var params = state.params,\n      subscriber = state.subscriber,\n      context = state.context;\n  var callbackFunc = params.callbackFunc,\n      args = params.args,\n      scheduler = params.scheduler;\n  var subject = params.subject;\n\n  if (!subject) {\n    subject = params.subject = new AsyncSubject();\n\n    var handler = function () {\n      var innerArgs = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        innerArgs[_i] = arguments[_i];\n      }\n\n      var err = innerArgs.shift();\n\n      if (err) {\n        _this.add(scheduler.schedule(dispatchError, 0, {\n          err: err,\n          subject: subject\n        }));\n      } else {\n        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n\n        _this.add(scheduler.schedule(dispatchNext, 0, {\n          value: value,\n          subject: subject\n        }));\n      }\n    };\n\n    try {\n      callbackFunc.apply(context, args.concat([handler]));\n    } catch (err) {\n      this.add(scheduler.schedule(dispatchError, 0, {\n        err: err,\n        subject: subject\n      }));\n    }\n  }\n\n  this.add(subject.subscribe(subscriber));\n}\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subject = arg.subject;\n  subject.error(err);\n}","map":{"version":3,"mappings":"AAAA;AACA,SAASA,UAAT,QAAuB,eAAvB;AAGA,SAASC,YAAT,QAAoB,iBAApB;AACA,SAASC,GAAT,QAAS,kBAAT;AACA,SAASC,cAAT,QAA4B,wBAA5B;AACA,SAASC,WAAT,QAAwB,qBAAxB;AAoJA,SAAMC,OAAN,QAAgB,iBAAhB;OAME,SAAIC,gBAAJ,CAAoBC,YAApB,EAAoBC,cAApB,EAAoBC,SAApB,EAAoB;MAClBD,gBAAgB;QACdJ,WAAS,CAAGI,cAAH,GAAkB;AAC5BC;WAEC;aAAQ,YAAc;gBAAd;;aAAA,0BAAc;;AAAK;;AAEzB;AAAA;AAAA;AACH;AACF;AAED;;SAA2B,YAAc;YAAd;;SAAA,0BAAc;;AACvC;;QACEC,SAAS;AACTC,aAAI,WADK;AAETC,gBAFS;AAGTL,kBAAS,cAHA;AAITE,eAAS,WAJA;AAKTI;AALS;WAOD,yBAAOC,UAAP,EAAmB;AACrB;AACN,UAAIH,OAAC,GAASD,MAAE,QAAhB;;UACE,YAAY;YACV,UAAU;AACVC,iBAAM,SAAU,QAAV,GAAU,kBAAhB;;cAAiBI,sBAAmB;yBAAnB,GAAmB;;iBAAnB,mCAAmBC;;AAClC;;AAEA,gBAAIC,GAAG,GAAEC,iBAAT;;gBACED;AACAN,qBAAO,MAAP,CAAOM,GAAP;AACD;AAED;;AACAN,mBAAO,CAACQ,IAAR,CAAQD,SAAW,OAAX,IAAW,CAAX,GAAWA,YAAX,GAAWA,SAAnB;AACAP;AAEF;;cACE;AACDJ;AAAC,mBACAU,KAAI;gBACFd,cAAc,WAAK;AACpBQ;mBACC;AACDS;AACF;AACF;AACD;;AACD;aACC;AACD;AAAAV;AAAAI;AAAAD;AAAA;AACA;AACH,KAhCU;AAiCb;AAgBD;;SAAAQ,gBA0BC;AAzBS;;AACA;AAAA,mBAAcC,gBAAd;AAAA,MAAkBT,OAAE,gBAApB;AACR,MAAIN,YAAU,SAAO,aAArB;AAAA,MAA6BK,kBAA7B;AAAA,MAA6BH,4BAA7B;AAEA,MAAIE,OAAC,GAASD,cAAd;;MACE,UAAU;AAEVC,WAAM,SAAU,QAAV,GAAU,kBAAhB;;QAAiBI,sBAAmB;mBAAnB,GAAmB;;WAAnB,mCAAmBC;;AAClC;;AACA,UAAIC,GAAG,GAAEC,iBAAT;;UACED,KAAI;AACLM;AAAAN;AAAAN;AAAA;aACC;AACA,iBAAQ,GAACO,SAAU,OAAV,IAAuC,CAAvC,GAAuCA,SAAe,CAAE,CAAF,CAAtD,GAA0DA,SAAnE;;AACDK;AAAAC;AAAAb;AAAA;AACD;AAEF;;QACE;AACDJ;AAAC,aACAU,KAAQ;AACT;AAAAA;AAAAN;AAAA;AACF;AAED;;AACD;AAOD;;SACUc,kBAAO;AACf,WAAQ,GAAIC,GAAC,MAAb;AAAA,MAAoBf,qBAApB;AACAA,SAAO,CAACQ,IAAR,CAAQK,KAAR;AACDb;AAOD;;SACUgB,cAAKD;AACb,SAAO,GAACA,GAAK,CAACT,GAAd;AAAA,MAAmBN,qBAAnB;AACDA","names":["Observable","AsyncSubject","map","canReportError","isScheduler","isArray","bindNodeCallback","callbackFunc","resultSelector","scheduler","params","subject","args","context","subscriber","handler","_i","err","innerArgs","next","console","dispatch","state","_this","value","dispatchNext","arg","dispatchError"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\bindNodeCallback.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { AsyncSubject } from '../AsyncSubject';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { SchedulerAction, SchedulerLike } from '../types';\r\nimport { map } from '../operators/map';\r\nimport { canReportError } from '../util/canReportError';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { isArray } from '../util/isArray';\r\n\r\n/* tslint:disable:max-line-length */\r\n/** @deprecated resultSelector is deprecated, pipe to map instead */\r\nexport function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;\r\n\r\nexport function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;\r\nexport function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;\r\n\r\nexport function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;\r\nexport function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;\r\n\r\nexport function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;\r\nexport function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;\r\n\r\nexport function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;\r\nexport function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;\r\n\r\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;\r\nexport function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;\r\n\r\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;\r\nexport function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>; /* tslint:enable:max-line-length */\r\n\r\nexport function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;\r\n/**\r\n * Converts a Node.js-style callback API to a function that returns an\r\n * Observable.\r\n *\r\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\r\n * callback is expected to be of type `callback(error, result)`.</span>\r\n *\r\n * `bindNodeCallback` is not an operator because its input and output are not\r\n * Observables. The input is a function `func` with some parameters, but the\r\n * last parameter must be a callback function that `func` calls when it is\r\n * done. The callback function is expected to follow Node.js conventions,\r\n * where the first argument to the callback is an error object, signaling\r\n * whether call was successful. If that object is passed to callback, it means\r\n * something went wrong.\r\n *\r\n * The output of `bindNodeCallback` is a function that takes the same\r\n * parameters as `func`, except the last one (the callback). When the output\r\n * function is called with arguments, it will return an Observable.\r\n * If `func` calls its callback with error parameter present, Observable will\r\n * error with that value as well. If error parameter is not passed, Observable will emit\r\n * second parameter. If there are more parameters (third and so on),\r\n * Observable will emit an array with all arguments, except first error argument.\r\n *\r\n * Note that `func` will not be called at the same time output function is,\r\n * but rather whenever resulting Observable is subscribed. By default call to\r\n * `func` will happen synchronously after subscription, but that can be changed\r\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\r\n * can also control when values from callback will be emitted by Observable.\r\n * To find out more, check out documentation for {@link bindCallback}, where\r\n * {@link SchedulerLike} works exactly the same.\r\n *\r\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\r\n * of returned function, when it is called.\r\n *\r\n * After Observable emits value, it will complete immediately. This means\r\n * even if `func` calls callback again, values from second and consecutive\r\n * calls will never appear on the stream. If you need to handle functions\r\n * that call callbacks multiple times, check out {@link fromEvent} or\r\n * {@link fromEventPattern} instead.\r\n *\r\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\r\n * \"Node.js-style\" callbacks are just a convention, so if you write for\r\n * browsers or any other environment and API you use implements that callback style,\r\n * `bindNodeCallback` can be safely used on that API functions as well.\r\n *\r\n * Remember that Error object passed to callback does not have to be an instance\r\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\r\n * Error parameter of callback function is interpreted as \"present\", when value\r\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\r\n * string or boolean `true`. In all of these cases resulting Observable would error\r\n * with that value. This means usually regular style callbacks will fail very often when\r\n * `bindNodeCallback` is used. If your Observable errors much more often then you\r\n * would expect, check if callback really is called in Node.js-style and, if not,\r\n * switch to {@link bindCallback} instead.\r\n *\r\n * Note that even if error parameter is technically present in callback, but its value\r\n * is falsy, it still won't appear in array emitted by Observable.\r\n *\r\n * ## Examples\r\n * ###  Read a file from the filesystem and get the data as an Observable\r\n * ```ts\r\n * import * as fs from 'fs';\r\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\r\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\r\n * result.subscribe(x => console.log(x), e => console.error(e));\r\n * ```\r\n *\r\n * ### Use on function calling callback with multiple arguments\r\n * ```ts\r\n * someFunction((err, a, b) => {\r\n *   console.log(err); // null\r\n *   console.log(a); // 5\r\n *   console.log(b); // \"some string\"\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(value => {\r\n *   console.log(value); // [5, \"some string\"]\r\n * });\r\n * ```\r\n *\r\n * ### Use on function calling callback in regular style\r\n * ```ts\r\n * someFunction(a => {\r\n *   console.log(a); // 5\r\n * });\r\n * const boundSomeFunction = bindNodeCallback(someFunction);\r\n * boundSomeFunction()\r\n * .subscribe(\r\n *   value => {}             // never gets called\r\n *   err => console.log(err) // 5\r\n * );\r\n * ```\r\n *\r\n * @see {@link bindCallback}\r\n * @see {@link from}\r\n *\r\n * @param {function} func Function with a Node.js-style callback as the last parameter.\r\n * @param {SchedulerLike} [scheduler] The scheduler on which to schedule the\r\n * callbacks.\r\n * @return {function(...params: *): Observable} A function which returns the\r\n * Observable that delivers the same values the Node.js callback would\r\n * deliver.\r\n * @name bindNodeCallback\r\n */\r\nexport function bindNodeCallback<T>(\r\n  callbackFunc: Function,\r\n  resultSelector: Function|SchedulerLike,\r\n  scheduler?: SchedulerLike\r\n): (...args: any[]) => Observable<T> {\r\n\r\n  if (resultSelector) {\r\n    if (isScheduler(resultSelector)) {\r\n      scheduler = resultSelector;\r\n    } else {\r\n      // DEPRECATED PATH\r\n      return (...args: any[]) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(\r\n        map(args => isArray(args) ? resultSelector(...args) : resultSelector(args))\r\n      );\r\n    }\r\n  }\r\n\r\n  return function(this: any, ...args: any[]): Observable<T> {\r\n    const params: ParamsState<T> = {\r\n      subject: undefined,\r\n      args,\r\n      callbackFunc,\r\n      scheduler,\r\n      context: this,\r\n    };\r\n    return new Observable<T>(subscriber => {\r\n      const { context } = params;\r\n      let { subject } = params;\r\n      if (!scheduler) {\r\n        if (!subject) {\r\n          subject = params.subject = new AsyncSubject<T>();\r\n          const handler = (...innerArgs: any[]) => {\r\n            const err = innerArgs.shift();\r\n\r\n            if (err) {\r\n              subject.error(err);\r\n              return;\r\n            }\r\n\r\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\r\n            subject.complete();\r\n          };\r\n\r\n          try {\r\n            callbackFunc.apply(context, [...args, handler]);\r\n          } catch (err) {\r\n            if (canReportError(subject)) {\r\n              subject.error(err);\r\n            } else {\r\n              console.warn(err);\r\n            }\r\n          }\r\n        }\r\n        return subject.subscribe(subscriber);\r\n      } else {\r\n        return scheduler.schedule<DispatchState<T>>(dispatch, 0, { params, subscriber, context });\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\ninterface DispatchState<T> {\r\n  subscriber: Subscriber<T>;\r\n  context: any;\r\n  params: ParamsState<T>;\r\n}\r\n\r\ninterface ParamsState<T> {\r\n  callbackFunc: Function;\r\n  args: any[];\r\n  scheduler: SchedulerLike;\r\n  subject: AsyncSubject<T>;\r\n  context: any;\r\n}\r\n\r\nfunction dispatch<T>(this: SchedulerAction<DispatchState<T>>, state: DispatchState<T>) {\r\n  const { params, subscriber, context } = state;\r\n  const { callbackFunc, args, scheduler } = params;\r\n  let subject = params.subject;\r\n\r\n  if (!subject) {\r\n    subject = params.subject = new AsyncSubject<T>();\r\n\r\n    const handler = (...innerArgs: any[]) => {\r\n      const err = innerArgs.shift();\r\n      if (err) {\r\n        this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, { err, subject }));\r\n      } else {\r\n        const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\r\n        this.add(scheduler.schedule<DispatchNextArg<T>>(dispatchNext, 0, { value, subject }));\r\n      }\r\n    };\r\n\r\n    try {\r\n      callbackFunc.apply(context, [...args, handler]);\r\n    } catch (err) {\r\n      this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, { err, subject }));\r\n    }\r\n  }\r\n\r\n  this.add(subject.subscribe(subscriber));\r\n}\r\n\r\ninterface DispatchNextArg<T> {\r\n  subject: AsyncSubject<T>;\r\n  value: T;\r\n}\r\n\r\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\r\n  const { value, subject } = arg;\r\n  subject.next(value);\r\n  subject.complete();\r\n}\r\n\r\ninterface DispatchErrorArg<T> {\r\n  subject: AsyncSubject<T>;\r\n  err: any;\r\n}\r\n\r\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\r\n  const { err, subject } = arg;\r\n  subject.error(err);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}