{"ast":null,"code":"/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */\nimport { mergeMap } from './mergeMap';\nexport function mergeMapTo(innerObservable, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  if (typeof resultSelector === 'function') {\n    return mergeMap(function () {\n      return innerObservable;\n    }, resultSelector, concurrent);\n  }\n\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return mergeMap(function () {\n    return innerObservable;\n  }, concurrent);\n}","map":{"version":3,"mappings":"AAEA;AAiDA,SAAMA,QAAN,QAAgB,YAAhB;OAGE,qDAA4BC,UAA5B,EAA6C;AAE7C,MAAIA,UAAO,WAAX,EAAyB;AACvBA,cAAO,SAAS,kBAAhB;AACD;;AACD,MAAI,OAAOC,cAAP,KAA0B,UAA9B,EAAwC;AACtC,mBAAa,aAAe;AAAA;AAAA,KAAf,EAAeA,cAAf,EAAeD,UAAf,CAAb;AACD;;AACD,aAAOC,cAAP,KAAsB,QAAtB,EAAsB;AACvBD","names":["mergeMap","concurrent","resultSelector"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\mergeMapTo.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { OperatorFunction, ObservedValueOf } from '../../internal/types';\r\nimport { mergeMap } from './mergeMap';\r\nimport { ObservableInput } from '../types';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function mergeMapTo<T, O extends ObservableInput<any>>(innerObservable: O, concurrent?: number): OperatorFunction<any, ObservedValueOf<O>>;\r\n/** @deprecated */\r\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(innerObservable: O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Projects each source value to the same Observable which is merged multiple\r\n * times in the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\r\n * to the same inner Observable.</span>\r\n *\r\n * ![](mergeMapTo.png)\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then merges those resulting Observables into one\r\n * single Observable, which is the output Observable.\r\n *\r\n * ## Example\r\n * For each click event, start an interval Observable ticking every 1 second\r\n * ```ts\r\n * import { fromEvent, interval } from 'rxjs';\r\n * import { mergeMapTo } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link concatMapTo}\r\n * @see {@link merge}\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param {ObservableInput} innerObservable An Observable to replace each value from\r\n * the source Observable.\r\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\r\n * Observables being subscribed to concurrently.\r\n * @return {Observable} An Observable that emits items from the given\r\n * `innerObservable`\r\n * @method mergeMapTo\r\n * @owner Observable\r\n */\r\nexport function mergeMapTo<T, R, O extends ObservableInput<any>>(\r\n  innerObservable: O,\r\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\r\n  concurrent: number = Number.POSITIVE_INFINITY\r\n): OperatorFunction<T, ObservedValueOf<O>|R> {\r\n  if (typeof resultSelector === 'function') {\r\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\r\n  }\r\n  if (typeof resultSelector === 'number') {\r\n    concurrent = resultSelector;\r\n  }\r\n  return mergeMap(() => innerObservable, concurrent);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}