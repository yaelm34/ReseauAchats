{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Action } from './Action';\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nexport { AsyncAction };","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAT,MAAuB,OAAvB;AAUA;;IAAoCC,qCAASC,MAAT,EAAS;AAO3CF,iCAA+CE,MAA/C;;WAAAD,YAEEE,iBAAM;AAFc,kCAAyBA,SAAzB,EAAyBC,IAAzB,KAAyB,IAAzB;;AACAC,sBAAmDF,SAAnD;AAHZE,iBAAOD,IAAP;;AAKT;AAEM;;aAAoB,gCAAiBE,KAAjB,EAAiBC,KAAjB,EAAiB;AAE1C,QAAIA,KAAK,UAAQ,CAAjB,EAAiB;AACfA,cAAO,CAAP;AACD;;AAGD,QAAI,KAACC,MAAL,EAAa;AAEP,aAAK,IAAL;AACN;;AAuBA,SAAIF,KAAJ,GAAUA,KAAV;QACEG,KAAK,KAAKA;QACXN;;AAID,QAAIM,EAAC,QAAL,EAAe;AAEX,WAACA,EAAD,GAAS,KAAMC,cAAN,CAAMP,SAAN,EAAMM,EAAN,EAAMF,KAAN,CAAT;AAEJ;;AAEA,mBAAY,IAAZ;AACD;AAES,6CAAVJ,SAAU,EAAe,KAA2BM,EAA1C,EAAoDF,KAApD;AAAoD;;;AAE9DN,aAAC,UAAD,CAACU,cAAD,GAAC;AAES;AAAmDJ;AAE3D;;WACEK,WAAU;GALd;;aASE,WAAkBF;AAClB,aAAO,UAAU,CAAjB,EAAiB;AAClBH;AAMM;;AAEL,QAAIA,KAAK,SAAL,IAAa,oBAAb,IAAa,sBAAjB,EAAiB;AACf,aAAOE,EAAP;AACD;;AAEDI,iBAAY,IAAZ;AACA,WAAMC,SAAN;;;aAEE,WAAaC;QACd;aAAU,IAAKC,KAAL,CAAY,8BAAZ;;;SAeVC;;AACF;;AAES;AACJ,aAAOC,KAAP;AACJ,KAFQ,MAGJ;AACF,WAAKT,EAAL,GAAU,KAAKC,cAAL,CAAO,cAAP,EAAO,OAAP,EAAO,IAAP,CAAV;AACD;;;aACC,WAAcS,WAAC;QACfC,UAAU;QACXC;;AACD,QAAI;AACF,WAAKjB,IAAL,CAAKE,KAAL;KADF,QAGCgB;AACFF;AAGDC;AAEE;;AACA,QAAMD,OAAN,EAAe;AACT;AACA,aAAKC,UAAL;AAEN;;;aAEK,WAAUE,eAAM;AACrB,QAAId,EAAC,QAASA,EAAd;AAEA,QAAIN,SAAK,GAAO,KAAEA,SAAlB;QACEqB,OAAO,GAACrB,SAAO,CAAKqB;QACrBC;AAED,SAAIrB,IAAJ,GAAU,IAAV;SACEE,QAAO;SACRW;AAED,SAAKd,SAAL,GAAiB,IAAjB;;AACD;AACHqB,qBAACC,KAAD,EAAC,CAAD;AAjJ0C;;;;;;;;;;CAAN","names":["tslib_1","AsyncAction","_super","scheduler","work","_this","state","delay","closed","id","recycleAsyncId","requestAsyncId","setInterval","clearInterval","undefined","execute","Error","pending","error","_execute","errored","errorValue","e","_unsubscribe","actions","index"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\scheduler\\AsyncAction.ts"],"sourcesContent":["import { Action } from './Action';\r\nimport { SchedulerAction } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class AsyncAction<T> extends Action<T> {\r\n\r\n  public id: any;\r\n  public state: T;\r\n  public delay: number;\r\n  protected pending: boolean = false;\r\n\r\n  constructor(protected scheduler: AsyncScheduler,\r\n              protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n\r\n    // Always replace the current state with the new state.\r\n    this.state = state;\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n\r\n    //\r\n    // Important implementation note:\r\n    //\r\n    // Actions only execute once by default, unless rescheduled from within the\r\n    // scheduled callback. This allows us to implement single and repeat\r\n    // actions via the same code path, without adding API surface area, as well\r\n    // as mimic traditional recursion but across asynchronous boundaries.\r\n    //\r\n    // However, JS runtimes and timers distinguish between intervals achieved by\r\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\r\n    // serial `setTimeout` calls can be individually delayed, which delays\r\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\r\n    // guarantee the interval callback will be invoked more precisely to the\r\n    // interval period, regardless of load.\r\n    //\r\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\r\n    // If the action reschedules itself with the same delay, the interval is not\r\n    // canceled. If the action doesn't reschedule, or reschedules with a\r\n    // different delay, the interval will be canceled after scheduled callback\r\n    // execution.\r\n    //\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Set the pending flag indicating that this action has been scheduled, or\r\n    // has recursively rescheduled itself.\r\n    this.pending = true;\r\n\r\n    this.delay = delay;\r\n    // If this action has already an async Id, don't request a new one.\r\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\r\n\r\n    return this;\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\r\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\r\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\r\n    if (delay !== null && this.delay === delay && this.pending === false) {\r\n      return id;\r\n    }\r\n    // Otherwise, if the action's delay time is different from the current delay,\r\n    // or the action has been rescheduled before it's executed, clear the interval id\r\n    clearInterval(id);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Immediately executes this action and the `work` it contains.\r\n   * @return {any}\r\n   */\r\n  public execute(state: T, delay: number): any {\r\n\r\n    if (this.closed) {\r\n      return new Error('executing a cancelled action');\r\n    }\r\n\r\n    this.pending = false;\r\n    const error = this._execute(state, delay);\r\n    if (error) {\r\n      return error;\r\n    } else if (this.pending === false && this.id != null) {\r\n      // Dequeue if the action didn't reschedule itself. Don't call\r\n      // unsubscribe(), because the action could reschedule later.\r\n      // For example:\r\n      // ```\r\n      // scheduler.schedule(function doWork(counter) {\r\n      //   /* ... I'm a busy worker bee ... */\r\n      //   var originalAction = this;\r\n      //   /* wait 100ms before rescheduling the action */\r\n      //   setTimeout(function () {\r\n      //     originalAction.schedule(counter + 1);\r\n      //   }, 100);\r\n      // }, 1000);\r\n      // ```\r\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\r\n    }\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    let errored: boolean = false;\r\n    let errorValue: any = undefined;\r\n    try {\r\n      this.work(state);\r\n    } catch (e) {\r\n      errored = true;\r\n      errorValue = !!e && e || new Error(e);\r\n    }\r\n    if (errored) {\r\n      this.unsubscribe();\r\n      return errorValue;\r\n    }\r\n  }\r\n\r\n  /** @deprecated This is an internal implementation detail, do not use. */\r\n  _unsubscribe() {\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n    const actions = scheduler.actions;\r\n    const index = actions.indexOf(this);\r\n\r\n    this.work  = null;\r\n    this.state = null;\r\n    this.pending = false;\r\n    this.scheduler = null;\r\n\r\n    if (index !== -1) {\r\n      actions.splice(index, 1);\r\n    }\r\n\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, null);\r\n    }\r\n\r\n    this.delay = null;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}