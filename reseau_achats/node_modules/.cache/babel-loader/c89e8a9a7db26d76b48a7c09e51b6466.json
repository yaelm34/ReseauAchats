{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from '../Subject';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nexport function windowTime(windowTimeSpan) {\n  var scheduler = async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = Number(arguments[2]);\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = Number(arguments[1]);\n  }\n\n  return function windowTimeOperatorFunction(source) {\n    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n  };\n}\n\nvar WindowTimeOperator = /*@__PURE__*/function () {\n  function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    this.windowTimeSpan = windowTimeSpan;\n    this.windowCreationInterval = windowCreationInterval;\n    this.maxWindowSize = maxWindowSize;\n    this.scheduler = scheduler;\n  }\n\n  WindowTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n  };\n\n  return WindowTimeOperator;\n}();\n\nvar CountedSubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(CountedSubject, _super);\n\n  function CountedSubject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._numberOfNextedValues = 0;\n    return _this;\n  }\n\n  CountedSubject.prototype.next = function (value) {\n    this._numberOfNextedValues++;\n\n    _super.prototype.next.call(this, value);\n  };\n\n  Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n    get: function () {\n      return this._numberOfNextedValues;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CountedSubject;\n}(Subject);\n\nvar WindowTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(WindowTimeSubscriber, _super);\n\n  function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.windowTimeSpan = windowTimeSpan;\n    _this.windowCreationInterval = windowCreationInterval;\n    _this.maxWindowSize = maxWindowSize;\n    _this.scheduler = scheduler;\n    _this.windows = [];\n\n    var window = _this.openWindow();\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      var closeState = {\n        subscriber: _this,\n        window: window,\n        context: null\n      };\n      var creationState = {\n        windowTimeSpan: windowTimeSpan,\n        windowCreationInterval: windowCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        window: window,\n        windowTimeSpan: windowTimeSpan\n      };\n\n      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n\n    return _this;\n  }\n\n  WindowTimeSubscriber.prototype._next = function (value) {\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len; i++) {\n      var window_1 = windows[i];\n\n      if (!window_1.closed) {\n        window_1.next(value);\n\n        if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n          this.closeWindow(window_1);\n        }\n      }\n    }\n  };\n\n  WindowTimeSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowTimeSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    while (windows.length > 0) {\n      var window_2 = windows.shift();\n\n      if (!window_2.closed) {\n        window_2.complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n\n  WindowTimeSubscriber.prototype.openWindow = function () {\n    var window = new CountedSubject();\n    this.windows.push(window);\n    var destination = this.destination;\n    destination.next(window);\n    return window;\n  };\n\n  WindowTimeSubscriber.prototype.closeWindow = function (window) {\n    window.complete();\n    var windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  };\n\n  return WindowTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchWindowTimeSpanOnly(state) {\n  var subscriber = state.subscriber,\n      windowTimeSpan = state.windowTimeSpan,\n      window = state.window;\n\n  if (window) {\n    subscriber.closeWindow(window);\n  }\n\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\nfunction dispatchWindowCreation(state) {\n  var windowTimeSpan = state.windowTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler,\n      windowCreationInterval = state.windowCreationInterval;\n  var window = subscriber.openWindow();\n  var action = this;\n  var context = {\n    action: action,\n    subscription: null\n  };\n  var timeSpanState = {\n    subscriber: subscriber,\n    window: window,\n    context: context\n  };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose(state) {\n  var subscriber = state.subscriber,\n      window = state.window,\n      context = state.context;\n\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n\n  subscriber.closeWindow(window);\n}","map":{"version":3,"mappings":"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","names":["tslib_1","Subject","async","Subscriber","isNumeric","isScheduler","windowTime","windowTimeSpan","scheduler","windowCreationInterval","maxWindowSize","POSITIVE_INFINITY","arguments","windowTimeOperatorFunction","source","WindowTimeOperator","call","CountedSubject","_super","value","configurable","WindowTimeSubscriber","destination","_this","window","closeState","subscriber","context","add","schedule","dispatchWindowClose","_next","windows","i","len","window_1","_error","_complete","window_2","prototype","push","closeWindow","dispatchWindowTimeSpanOnly","state","dispatchWindowCreation","action","subscription","timeSpanState"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\windowTime.ts"],"sourcesContent":["import { Subject } from '../Subject';\r\nimport { Operator } from '../Operator';\r\nimport { async } from '../scheduler/async';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { Subscription } from '../Subscription';\r\nimport { isNumeric } from '../util/isNumeric';\r\nimport { isScheduler } from '../util/isScheduler';\r\nimport { OperatorFunction, SchedulerLike, SchedulerAction } from '../types';\r\n\r\n/**\r\n * Branch out the source Observable values as a nested Observable periodically\r\n * in time.\r\n *\r\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\r\n * Observable instead of an array.</span>\r\n *\r\n * ![](windowTime.png)\r\n *\r\n * Returns an Observable that emits windows of items it collects from the source\r\n * Observable. The output Observable starts a new window periodically, as\r\n * determined by the `windowCreationInterval` argument. It emits each window\r\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\r\n * source Observable completes or encounters an error, the output Observable\r\n * emits the current window and propagates the notification from the source\r\n * Observable. If `windowCreationInterval` is not provided, the output\r\n * Observable starts a new window when the previous window of duration\r\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\r\n * will emit at most fixed number of values. Window will complete immediately\r\n * after emitting last value and next one still will open as specified by\r\n * `windowTimeSpan` and `windowCreationInterval` arguments.\r\n *\r\n * ## Examples\r\n * In every window of 1 second each, emit at most 2 click events\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000),\r\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\r\n *   mergeAll(),                    // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { windowTime, map, mergeAll, take } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000, 5000),\r\n *   map(win => win.pipe(take(2))), // each window has at most 2 emissions\r\n *   mergeAll(),                    // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Same as example above but with maxWindowCount instead of take\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { windowTime, mergeAll } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(\r\n *   windowTime(1000, 5000, 2), // each window has still at most 2 emissions\r\n *   mergeAll(),                // flatten the Observable-of-Observables\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link window}\r\n * @see {@link windowCount}\r\n * @see {@link windowToggle}\r\n * @see {@link windowWhen}\r\n * @see {@link bufferTime}\r\n *\r\n * @param {number} windowTimeSpan The amount of time to fill each window.\r\n * @param {number} [windowCreationInterval] The interval at which to start new\r\n * windows.\r\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\r\n * values each window can emit before completion.\r\n * @param {SchedulerLike} [scheduler=async] The scheduler on which to schedule the\r\n * intervals that determine window boundaries.\r\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\r\n * are Observables.\r\n * @method windowTime\r\n * @owner Observable\r\n */\r\nexport function windowTime<T>(windowTimeSpan: number,\r\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\r\nexport function windowTime<T>(windowTimeSpan: number,\r\n                              windowCreationInterval: number,\r\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\r\nexport function windowTime<T>(windowTimeSpan: number,\r\n                              windowCreationInterval: number,\r\n                              maxWindowSize: number,\r\n                              scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\r\n\r\nexport function windowTime<T>(windowTimeSpan: number): OperatorFunction<T, Observable<T>> {\r\n  let scheduler: SchedulerLike = async;\r\n  let windowCreationInterval: number = null;\r\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\r\n\r\n  if (isScheduler(arguments[3])) {\r\n    scheduler = arguments[3];\r\n  }\r\n\r\n  if (isScheduler(arguments[2])) {\r\n    scheduler = arguments[2];\r\n  } else if (isNumeric(arguments[2])) {\r\n    maxWindowSize = Number(arguments[2]);\r\n  }\r\n\r\n  if (isScheduler(arguments[1])) {\r\n    scheduler = arguments[1];\r\n  } else if (isNumeric(arguments[1])) {\r\n    windowCreationInterval = Number(arguments[1]);\r\n  }\r\n\r\n  return function windowTimeOperatorFunction(source: Observable<T>) {\r\n    return source.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\r\n  };\r\n}\r\n\r\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\r\n\r\n  constructor(private windowTimeSpan: number,\r\n              private windowCreationInterval: number | null,\r\n              private maxWindowSize: number,\r\n              private scheduler: SchedulerLike) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\r\n    return source.subscribe(new WindowTimeSubscriber(\r\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler\r\n    ));\r\n  }\r\n}\r\n\r\ninterface CreationState<T> {\r\n  windowTimeSpan: number;\r\n  windowCreationInterval: number;\r\n  subscriber: WindowTimeSubscriber<T>;\r\n  scheduler: SchedulerLike;\r\n}\r\n\r\ninterface TimeSpanOnlyState<T> {\r\n    window: CountedSubject<T>;\r\n    windowTimeSpan: number;\r\n    subscriber: WindowTimeSubscriber<T>;\r\n  }\r\n\r\ninterface CloseWindowContext<T> {\r\n  action: SchedulerAction<CreationState<T>>;\r\n  subscription: Subscription;\r\n}\r\n\r\ninterface CloseState<T> {\r\n  subscriber: WindowTimeSubscriber<T>;\r\n  window: CountedSubject<T>;\r\n  context: CloseWindowContext<T>;\r\n}\r\n\r\nclass CountedSubject<T> extends Subject<T> {\r\n  private _numberOfNextedValues: number = 0;\r\n\r\n  next(value?: T): void {\r\n    this._numberOfNextedValues++;\r\n    super.next(value);\r\n  }\r\n\r\n  get numberOfNextedValues(): number {\r\n    return this._numberOfNextedValues;\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\r\n  private windows: CountedSubject<T>[] = [];\r\n\r\n  constructor(protected destination: Subscriber<Observable<T>>,\r\n              private windowTimeSpan: number,\r\n              private windowCreationInterval: number | null,\r\n              private maxWindowSize: number,\r\n              private scheduler: SchedulerLike) {\r\n    super(destination);\r\n\r\n    const window = this.openWindow();\r\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\r\n      const closeState: CloseState<T> = { subscriber: this, window, context: <any>null };\r\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\r\n      this.add(scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, closeState));\r\n      this.add(scheduler.schedule<CreationState<T>>(dispatchWindowCreation, windowCreationInterval, creationState));\r\n    } else {\r\n      const timeSpanOnlyState: TimeSpanOnlyState<T> = { subscriber: this, window, windowTimeSpan };\r\n      this.add(scheduler.schedule<TimeSpanOnlyState<T>>(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\r\n    }\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    const windows = this.windows;\r\n    const len = windows.length;\r\n    for (let i = 0; i < len; i++) {\r\n      const window = windows[i];\r\n      if (!window.closed) {\r\n        window.next(value);\r\n        if (window.numberOfNextedValues >= this.maxWindowSize) {\r\n          this.closeWindow(window);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  protected _error(err: any): void {\r\n    const windows = this.windows;\r\n    while (windows.length > 0) {\r\n      windows.shift().error(err);\r\n    }\r\n    this.destination.error(err);\r\n  }\r\n\r\n  protected _complete(): void {\r\n    const windows = this.windows;\r\n    while (windows.length > 0) {\r\n      const window = windows.shift();\r\n      if (!window.closed) {\r\n        window.complete();\r\n      }\r\n    }\r\n    this.destination.complete();\r\n  }\r\n\r\n  public openWindow(): CountedSubject<T> {\r\n    const window = new CountedSubject<T>();\r\n    this.windows.push(window);\r\n    const destination = this.destination;\r\n    destination.next(window);\r\n    return window;\r\n  }\r\n\r\n  public closeWindow(window: CountedSubject<T>): void {\r\n    window.complete();\r\n    const windows = this.windows;\r\n    windows.splice(windows.indexOf(window), 1);\r\n  }\r\n}\r\n\r\nfunction dispatchWindowTimeSpanOnly<T>(this: SchedulerAction<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {\r\n  const { subscriber, windowTimeSpan, window } = state;\r\n  if (window) {\r\n    subscriber.closeWindow(window);\r\n  }\r\n  state.window = subscriber.openWindow();\r\n  this.schedule(state, windowTimeSpan);\r\n}\r\n\r\nfunction dispatchWindowCreation<T>(this: SchedulerAction<CreationState<T>>, state: CreationState<T>): void {\r\n  const { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\r\n  const window = subscriber.openWindow();\r\n  const action = this;\r\n  let context: CloseWindowContext<T> = { action, subscription: <any>null };\r\n  const timeSpanState: CloseState<T> = { subscriber, window, context };\r\n  context.subscription = scheduler.schedule<CloseState<T>>(dispatchWindowClose, windowTimeSpan, timeSpanState);\r\n  action.add(context.subscription);\r\n  action.schedule(state, windowCreationInterval);\r\n}\r\n\r\nfunction dispatchWindowClose<T>(state: CloseState<T>): void {\r\n  const { subscriber, window, context } = state;\r\n  if (context && context.action && context.subscription) {\r\n    context.action.remove(context.subscription);\r\n  }\r\n  subscriber.closeWindow(window);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}