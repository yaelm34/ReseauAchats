{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar channel_buf_1 = __importDefault(require(\"./channel-buf\"));\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar buffer_1 = __importDefault(require(\"buffer\"));\n\nvar string_decoder_1 = require(\"string_decoder\");\n\nvar decoder = new string_decoder_1.StringDecoder('utf8');\n\nfunction encode(str) {\n  return new channel_buf_1.default(newBuffer(str));\n}\n\nfunction decode(buffer, length) {\n  if (Object.prototype.hasOwnProperty.call(buffer, '_buffer')) {\n    return decodeChannelBuffer(buffer, length);\n  } else if (Object.prototype.hasOwnProperty.call(buffer, '_buffers')) {\n    return decodeCombinedBuffer(buffer, length);\n  } else {\n    throw (0, neo4j_driver_core_1.newError)(\"Don't know how to decode strings from '\" + buffer + \"'\");\n  }\n}\n\nfunction decodeChannelBuffer(buffer, length) {\n  var start = buffer.position;\n  var end = start + length;\n  buffer.position = Math.min(end, buffer.length);\n  return buffer._buffer.toString('utf8', start, end);\n}\n\nfunction decodeCombinedBuffer(buffer, length) {\n  return streamDecodeCombinedBuffer(buffer, length, function (partBuffer) {\n    return decoder.write(partBuffer._buffer);\n  }, function () {\n    return decoder.end();\n  });\n}\n\nfunction streamDecodeCombinedBuffer(combinedBuffers, length, decodeFn, endFn) {\n  var remainingBytesToRead = length;\n  var position = combinedBuffers.position;\n\n  combinedBuffers._updatePos(Math.min(length, combinedBuffers.length - position)); // Reduce CombinedBuffers to a decoded string\n\n\n  var out = combinedBuffers._buffers.reduce(function (last, partBuffer) {\n    if (remainingBytesToRead <= 0) {\n      return last;\n    } else if (position >= partBuffer.length) {\n      position -= partBuffer.length;\n      return '';\n    } else {\n      partBuffer._updatePos(position - partBuffer.position);\n\n      var bytesToRead = Math.min(partBuffer.length - position, remainingBytesToRead);\n      var lastSlice = partBuffer.readSlice(bytesToRead);\n\n      partBuffer._updatePos(bytesToRead);\n\n      remainingBytesToRead = Math.max(remainingBytesToRead - lastSlice.length, 0);\n      position = 0;\n      return last + decodeFn(lastSlice);\n    }\n  }, '');\n\n  return out + endFn();\n}\n\nfunction newBuffer(str) {\n  // use static factory function present in newer NodeJS versions to create a buffer containing the given string\n  // or fallback to the old, potentially deprecated constructor\n  if (typeof buffer_1.default.Buffer.from === 'function') {\n    return buffer_1.default.Buffer.from(str, 'utf8');\n  } else {\n    // eslint-disable-next-line node/no-deprecated-api\n    return new buffer_1.default.Buffer(str, 'utf8');\n  }\n}\n\nexports.default = {\n  encode: encode,\n  decode: decode\n};","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/channel/utf8.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","channel_buf_1","require","neo4j_driver_core_1","buffer_1","string_decoder_1","decoder","StringDecoder","encode","str","default","newBuffer","decode","buffer","length","prototype","hasOwnProperty","call","decodeChannelBuffer","decodeCombinedBuffer","newError","start","position","end","Math","min","_buffer","toString","streamDecodeCombinedBuffer","partBuffer","write","combinedBuffers","decodeFn","endFn","remainingBytesToRead","_updatePos","out","_buffers","reduce","last","bytesToRead","lastSlice","readSlice","max","Buffer","from"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar channel_buf_1 = __importDefault(require(\"./channel-buf\"));\r\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\r\nvar buffer_1 = __importDefault(require(\"buffer\"));\r\nvar string_decoder_1 = require(\"string_decoder\");\r\nvar decoder = new string_decoder_1.StringDecoder('utf8');\r\nfunction encode(str) {\r\n    return new channel_buf_1.default(newBuffer(str));\r\n}\r\nfunction decode(buffer, length) {\r\n    if (Object.prototype.hasOwnProperty.call(buffer, '_buffer')) {\r\n        return decodeChannelBuffer(buffer, length);\r\n    }\r\n    else if (Object.prototype.hasOwnProperty.call(buffer, '_buffers')) {\r\n        return decodeCombinedBuffer(buffer, length);\r\n    }\r\n    else {\r\n        throw (0, neo4j_driver_core_1.newError)(\"Don't know how to decode strings from '\" + buffer + \"'\");\r\n    }\r\n}\r\nfunction decodeChannelBuffer(buffer, length) {\r\n    var start = buffer.position;\r\n    var end = start + length;\r\n    buffer.position = Math.min(end, buffer.length);\r\n    return buffer._buffer.toString('utf8', start, end);\r\n}\r\nfunction decodeCombinedBuffer(buffer, length) {\r\n    return streamDecodeCombinedBuffer(buffer, length, function (partBuffer) { return decoder.write(partBuffer._buffer); }, function () { return decoder.end(); });\r\n}\r\nfunction streamDecodeCombinedBuffer(combinedBuffers, length, decodeFn, endFn) {\r\n    var remainingBytesToRead = length;\r\n    var position = combinedBuffers.position;\r\n    combinedBuffers._updatePos(Math.min(length, combinedBuffers.length - position));\r\n    // Reduce CombinedBuffers to a decoded string\r\n    var out = combinedBuffers._buffers.reduce(function (last, partBuffer) {\r\n        if (remainingBytesToRead <= 0) {\r\n            return last;\r\n        }\r\n        else if (position >= partBuffer.length) {\r\n            position -= partBuffer.length;\r\n            return '';\r\n        }\r\n        else {\r\n            partBuffer._updatePos(position - partBuffer.position);\r\n            var bytesToRead = Math.min(partBuffer.length - position, remainingBytesToRead);\r\n            var lastSlice = partBuffer.readSlice(bytesToRead);\r\n            partBuffer._updatePos(bytesToRead);\r\n            remainingBytesToRead = Math.max(remainingBytesToRead - lastSlice.length, 0);\r\n            position = 0;\r\n            return last + decodeFn(lastSlice);\r\n        }\r\n    }, '');\r\n    return out + endFn();\r\n}\r\nfunction newBuffer(str) {\r\n    // use static factory function present in newer NodeJS versions to create a buffer containing the given string\r\n    // or fallback to the old, potentially deprecated constructor\r\n    if (typeof buffer_1.default.Buffer.from === 'function') {\r\n        return buffer_1.default.Buffer.from(str, 'utf8');\r\n    }\r\n    else {\r\n        // eslint-disable-next-line node/no-deprecated-api\r\n        return new buffer_1.default.Buffer(str, 'utf8');\r\n    }\r\n}\r\nexports.default = {\r\n    encode: encode,\r\n    decode: decode\r\n};\r\n"]},"metadata":{},"sourceType":"script"}