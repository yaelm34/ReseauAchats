{"ast":null,"code":"/** PURE_IMPORTS_START _map PURE_IMPORTS_END */\nimport { map } from './map';\nexport function pluck() {\n  var properties = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    properties[_i] = arguments[_i];\n  }\n\n  var length = properties.length;\n\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n\n  return function (source) {\n    return map(plucker(properties, length))(source);\n  };\n}\n\nfunction plucker(props, length) {\n  var mapper = function (x) {\n    var currentProp = x;\n\n    for (var i = 0; i < length; i++) {\n      var p = currentProp != null ? currentProp[props[i]] : undefined;\n\n      if (p !== void 0) {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n\n    return currentProp;\n  };\n\n  return mapper;\n}","map":{"version":3,"mappings":"AACA;AA6CA,SAAMA,GAAN,QAAgB,OAAhB;OAA4B,iBAAuB;gBAAvB;;OAAA,mCAAuBC;;AACjD;;AACA,MAAIC,MAAM,aAAQ,OAAlB;;MACEA,MAAM,KAAI;AACX;AACD;;AACD;AAAA;AAAA;AAED;;SACQC,QAASC,eAAU;MACvBC,MAAI,aAAeC,CAAf,EAAgB;AACpB,mBAAc,GAAGA,CAAjB;;SACE,IAAOC,IAAG,eAAeA,KAAM;AAC/B,UAAIC,CAAC,cAAa,QAAb,GAAaC,qBAAb,GAAaC,SAAlB;;UACEF,WAAW,GAAG;AACfC;aACC;AACD;AACF;AACD;;AACA;AAEF;;AACD","names":["map","_i","length","plucker","props","mapper","x","i","p","currentProp","undefined"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\pluck.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { map } from './map';\r\nimport { OperatorFunction } from '../types';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): OperatorFunction<T, T[K1][K2][K3]>;\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): OperatorFunction<T, T[K1][K2][K3][K4]>;\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\r\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\r\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Maps each source value (an object) to its specified nested property.\r\n *\r\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\r\n * the nested properties of every emitted object.</span>\r\n *\r\n * ![](pluck.png)\r\n *\r\n * Given a list of strings describing a path to an object property, retrieves\r\n * the value of a specified nested property from all values in the source\r\n * Observable. If a property can't be resolved, it will return `undefined` for\r\n * that value.\r\n *\r\n * ## Example\r\n * Map every click to the tagName of the clicked target element\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { pluck } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\r\n * tagNames.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link map}\r\n *\r\n * @param {...string} properties The nested properties to pluck from each source\r\n * value (an object).\r\n * @return {Observable} A new Observable of property values from the source values.\r\n * @method pluck\r\n * @owner Observable\r\n */\r\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {\r\n  const length = properties.length;\r\n  if (length === 0) {\r\n    throw new Error('list of properties cannot be empty.');\r\n  }\r\n  return (source: Observable<T>) => map(plucker(properties, length))(source as any);\r\n}\r\n\r\nfunction plucker(props: string[], length: number): (x: string) => any {\r\n  const mapper = (x: string) => {\r\n    let currentProp = x;\r\n    for (let i = 0; i < length; i++) {\r\n      const p = currentProp != null ? currentProp[props[i]] : undefined;\r\n      if (p !== void 0) {\r\n        currentProp = p;\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n    return currentProp;\r\n  };\r\n\r\n  return mapper;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}