{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    return source.lift(new DebounceTimeOperator(dueTime, scheduler));\n  };\n}\n\nvar DebounceTimeOperator = /*@__PURE__*/function () {\n  function DebounceTimeOperator(dueTime, scheduler) {\n    this.dueTime = dueTime;\n    this.scheduler = scheduler;\n  }\n\n  DebounceTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  };\n\n  return DebounceTimeOperator;\n}();\n\nvar DebounceTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(DebounceTimeSubscriber, _super);\n\n  function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.dueTime = dueTime;\n    _this.scheduler = scheduler;\n    _this.debouncedSubscription = null;\n    _this.lastValue = null;\n    _this.hasValue = false;\n    return _this;\n  }\n\n  DebounceTimeSubscriber.prototype._next = function (value) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  };\n\n  DebounceTimeSubscriber.prototype._complete = function () {\n    this.debouncedNext();\n    this.destination.complete();\n  };\n\n  DebounceTimeSubscriber.prototype.debouncedNext = function () {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      var lastValue = this.lastValue;\n      this.lastValue = null;\n      this.hasValue = false;\n      this.destination.next(lastValue);\n    }\n  };\n\n  DebounceTimeSubscriber.prototype.clearDebounce = function () {\n    var debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  };\n\n  return DebounceTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchNext(subscriber) {\n  subscriber.debouncedNext();\n}","map":{"version":3,"mappings":";AAEA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAEA,SAASC,UAAT,QAAsB,eAAtB;AAuDA,SAAMC,KAAN,QAAgB,oBAAhB;OAAiD,0CAAgC;AAC/E,eAAO,KAAC,KAAqB,CAA7B,EAA6B;AAC9BC;AAED;;AACE;AAAA,WAAoBC,MAAyB,KAAzB,CAAyB,IAAwBC,oBAAxB,CAAwBC,OAAxB,EAAwBH,SAAxB,CAAzB,CAApB;AAAqE,GAArE;;;wBAAsD,GAAT,aAAwB;AACrE,WAACE,oBAAD,CAACC,OAAD,EAACH,SAAD,EAAC;AAED;AACE,qBAAcA,SAAd;AACD;;AACHE,iCAACE,IAAD,GAAC;AAAA;AAOD,GAPA;;AAOwC;CAb+B;;0BAqBnE,gBAAM,UAAYC,MAAZ,EACP;SAHmB,WAAOC,wBAAQD;;WACfC,uBAAwBC;AANpC,kCAAsCA,WAAtC,KAA2C,IAA3C;;AACAC,oBAASL,OAAT;AACAK,sBAAoBR,SAApB;;AAMPQ;AAESA;AACR,WAAKA,KAAL;;;wBAEgB,WAAKC;AACrB,SAAKC,aAAL;AACD;AAES;AACR,SAAKC,GAAL,CAAK,6BAAgB,yDAArB;;;AAEFL,wBAAC,UAAD,CAACM,SAAD,GAAC;AAED;AACE,SAAKL,WAAL,CAAKM,QAAL;GAHF;;wBAMY,2BAAmB;SAM3BH;;QACA,KAAKI,UAAQ;AACb,UAAIC,SAAC,GAAW,KAAKA,SAArB;AACD;AACF;AAEO;AACN;;;wBAGc,2BAAuB;QACnCC,qBAAqB,GAAC;;QACtBA,qBAAK,KAAqB,MAAG;AAC9B;AACFA;AACH,mCAAC,IAAD;AAhDwC;AAkDxC;;AACE;AACD,CA5CS,CA4CTlB,UA5CS","names":["tslib_1","Subscriber","async","scheduler","source","DebounceTimeOperator","dueTime","call","_super","DebounceTimeSubscriber","destination","_this","_next","clearDebounce","add","_complete","complete","hasValue","lastValue","debouncedSubscription"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\debounceTime.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { async } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike, TeardownLogic } from '../types';\r\n\r\n/**\r\n * Emits a value from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent value from each burst of emissions.</span>\r\n *\r\n * ![](debounceTime.png)\r\n *\r\n * `debounceTime` delays values emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new value arrives on the source\r\n * Observable. This operator keeps track of the most recent value from the\r\n * source Observable, and emits that only when `dueTime` enough time has passed\r\n * without any other value appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous value will be dropped\r\n * and will not be emitted on the output Observable.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * value to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\r\n * managing timers.\r\n *\r\n * ## Example\r\n * Emit the most recent click after a burst of clicks\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { debounceTime } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(debounceTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified `dueTime`, and may drop some values if they occur\r\n * too frequently.\r\n * @method debounceTime\r\n * @owner Observable\r\n */\r\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\r\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\r\n}\r\n\r\nclass DebounceTimeOperator<T> implements Operator<T, T> {\r\n  constructor(private dueTime: number, private scheduler: SchedulerLike) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\r\n  private debouncedSubscription: Subscription = null;\r\n  private lastValue: T = null;\r\n  private hasValue: boolean = false;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private dueTime: number,\r\n              private scheduler: SchedulerLike) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _next(value: T) {\r\n    this.clearDebounce();\r\n    this.lastValue = value;\r\n    this.hasValue = true;\r\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\r\n  }\r\n\r\n  protected _complete() {\r\n    this.debouncedNext();\r\n    this.destination.complete();\r\n  }\r\n\r\n  debouncedNext(): void {\r\n    this.clearDebounce();\r\n\r\n    if (this.hasValue) {\r\n      const { lastValue } = this;\r\n      // This must be done *before* passing the value\r\n      // along to the destination because it's possible for\r\n      // the value to synchronously re-enter this operator\r\n      // recursively when scheduled with things like\r\n      // VirtualScheduler/TestScheduler.\r\n      this.lastValue = null;\r\n      this.hasValue = false;\r\n      this.destination.next(lastValue);\r\n    }\r\n  }\r\n\r\n  private clearDebounce(): void {\r\n    const debouncedSubscription = this.debouncedSubscription;\r\n\r\n    if (debouncedSubscription !== null) {\r\n      this.remove(debouncedSubscription);\r\n      debouncedSubscription.unsubscribe();\r\n      this.debouncedSubscription = null;\r\n    }\r\n  }\r\n}\r\n\r\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\r\n  subscriber.debouncedNext();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}