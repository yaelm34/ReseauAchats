{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar channel_1 = require(\"../channel\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\n\nvar Structure =\n/** @class */\nfunction () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    this.signature = signature;\n    this.fields = fields;\n  }\n\n  Structure.prototype.toString = function () {\n    var fieldStr = '';\n\n    for (var i = 0; i < this.fields.length; i++) {\n      if (i > 0) {\n        fieldStr += ', ';\n      }\n\n      fieldStr += this.fields[i];\n    }\n\n    return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n  };\n\n  return Structure;\n}();\n\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\n\nvar Packer =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n\n\n  Packer.prototype.packable = function (x) {\n    var _this = this;\n\n    if (x === null) {\n      return function () {\n        return _this._ch.writeUInt8(NULL);\n      };\n    } else if (x === true) {\n      return function () {\n        return _this._ch.writeUInt8(TRUE);\n      };\n    } else if (x === false) {\n      return function () {\n        return _this._ch.writeUInt8(FALSE);\n      };\n    } else if (typeof x === 'number') {\n      return function () {\n        return _this.packFloat(x);\n      };\n    } else if (typeof x === 'string') {\n      return function () {\n        return _this.packString(x);\n      };\n    } else if (typeof x === 'bigint') {\n      return function () {\n        return _this.packInteger((0, neo4j_driver_core_1.int)(x));\n      };\n    } else if ((0, neo4j_driver_core_1.isInt)(x)) {\n      return function () {\n        return _this.packInteger(x);\n      };\n    } else if (x instanceof Int8Array) {\n      return function () {\n        return _this.packBytes(x);\n      };\n    } else if (x instanceof Array) {\n      return function () {\n        _this.packListHeader(x.length);\n\n        for (var i_1 = 0; i_1 < x.length; i_1++) {\n          _this.packable(x[i_1] === undefined ? null : x[i_1])();\n        }\n      };\n    } else if (isIterable(x)) {\n      return this.packableIterable(x);\n    } else if (x instanceof neo4j_driver_core_1.Node) {\n      return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Relationship) {\n      return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Path) {\n      return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n    } else if (x instanceof Structure) {\n      var packableFields = [];\n\n      for (var i = 0; i < x.fields.length; i++) {\n        packableFields[i] = this.packable(x.fields[i]);\n      }\n\n      return function () {\n        return _this.packStruct(x.signature, packableFields);\n      };\n    } else if (typeof x === 'object') {\n      return function () {\n        var keys = Object.keys(x);\n        var count = 0;\n\n        for (var i_2 = 0; i_2 < keys.length; i_2++) {\n          if (x[keys[i_2]] !== undefined) {\n            count++;\n          }\n        }\n\n        _this.packMapHeader(count);\n\n        for (var i_3 = 0; i_3 < keys.length; i_3++) {\n          var key = keys[i_3];\n\n          if (x[key] !== undefined) {\n            _this.packString(key);\n\n            _this.packable(x[key])();\n          }\n        }\n      };\n    } else {\n      return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n    }\n  };\n\n  Packer.prototype.packableIterable = function (iterable) {\n    try {\n      var array = Array.from(iterable);\n      return this.packable(array);\n    } catch (e) {\n      // handle errors from iterable to array conversion\n      throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n    }\n  };\n  /**\n   * Packs a struct\n   * @param signature the signature of the struct\n   * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n   */\n\n\n  Packer.prototype.packStruct = function (signature, packableFields) {\n    packableFields = packableFields || [];\n    this.packStructHeader(packableFields.length, signature);\n\n    for (var i = 0; i < packableFields.length; i++) {\n      packableFields[i]();\n    }\n  };\n\n  Packer.prototype.packInteger = function (x) {\n    var high = x.high;\n    var low = x.low;\n\n    if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n      this._ch.writeUInt8(INT_8);\n\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n      this._ch.writeUInt8(INT_16);\n\n      this._ch.writeInt16(low);\n    } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n      this._ch.writeUInt8(INT_32);\n\n      this._ch.writeInt32(low);\n    } else {\n      this._ch.writeUInt8(INT_64);\n\n      this._ch.writeInt32(high);\n\n      this._ch.writeInt32(low);\n    }\n  };\n\n  Packer.prototype.packFloat = function (x) {\n    this._ch.writeUInt8(FLOAT_64);\n\n    this._ch.writeFloat64(x);\n  };\n\n  Packer.prototype.packString = function (x) {\n    var bytes = channel_1.utf8.encode(x);\n    var size = bytes.length;\n\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRING | size);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRING_8);\n\n      this._ch.writeUInt8(size);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRING_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(STRING_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n\n      this._ch.writeBytes(bytes);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packListHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_LIST | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(LIST_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(LIST_16);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(LIST_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packBytes = function (array) {\n    if (this._byteArraysSupported) {\n      this.packBytesHeader(array.length);\n\n      for (var i = 0; i < array.length; i++) {\n        this._ch.writeInt8(array[i]);\n      }\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n    }\n  };\n\n  Packer.prototype.packBytesHeader = function (size) {\n    if (size < 0x100) {\n      this._ch.writeUInt8(BYTES_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(BYTES_16);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(BYTES_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packMapHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_MAP | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(MAP_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(MAP_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(MAP_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packStructHeader = function (size, signature) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRUCT | size);\n\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRUCT_8);\n\n      this._ch.writeUInt8(size);\n\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRUCT_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.disableByteArrays = function () {\n    this._byteArraysSupported = false;\n  };\n\n  Packer.prototype._nonPackableValue = function (message) {\n    return function () {\n      throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n    };\n  };\n\n  return Packer;\n}();\n\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\n\nvar Unpacker =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n\n    this._disableLosslessIntegers = disableLosslessIntegers;\n    this._useBigInt = useBigInt;\n  }\n\n  Unpacker.prototype.unpack = function (buffer) {\n    var marker = buffer.readUInt8();\n    var markerHigh = marker & 0xf0;\n    var markerLow = marker & 0x0f;\n\n    if (marker === NULL) {\n      return null;\n    }\n\n    var boolean = this._unpackBoolean(marker);\n\n    if (boolean !== null) {\n      return boolean;\n    }\n\n    var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n\n    if (numberOrInteger !== null) {\n      if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n        if (this._useBigInt) {\n          return numberOrInteger.toBigInt();\n        } else if (this._disableLosslessIntegers) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n      }\n\n      return numberOrInteger;\n    }\n\n    var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n\n    if (string !== null) {\n      return string;\n    }\n\n    var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n\n    if (list !== null) {\n      return list;\n    }\n\n    var byteArray = this._unpackByteArray(marker, buffer);\n\n    if (byteArray !== null) {\n      return byteArray;\n    }\n\n    var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n\n    if (map !== null) {\n      return map;\n    }\n\n    var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n\n    if (struct !== null) {\n      return struct;\n    }\n\n    throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n  };\n\n  Unpacker.prototype.unpackInteger = function (buffer) {\n    var marker = buffer.readUInt8();\n\n    var result = this._unpackInteger(marker, buffer);\n\n    if (result == null) {\n      throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n    }\n\n    return result;\n  };\n\n  Unpacker.prototype._unpackBoolean = function (marker) {\n    if (marker === TRUE) {\n      return true;\n    } else if (marker === FALSE) {\n      return false;\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n    if (marker === FLOAT_64) {\n      return buffer.readFloat64();\n    } else {\n      return this._unpackInteger(marker, buffer);\n    }\n  };\n\n  Unpacker.prototype._unpackInteger = function (marker, buffer) {\n    if (marker >= 0 && marker < 128) {\n      return (0, neo4j_driver_core_1.int)(marker);\n    } else if (marker >= 240 && marker < 256) {\n      return (0, neo4j_driver_core_1.int)(marker - 256);\n    } else if (marker === INT_8) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n    } else if (marker === INT_16) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n    } else if (marker === INT_32) {\n      var b = buffer.readInt32();\n      return (0, neo4j_driver_core_1.int)(b);\n    } else if (marker === INT_64) {\n      var high = buffer.readInt32();\n      var low = buffer.readInt32();\n      return new neo4j_driver_core_1.Integer(low, high);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRING) {\n      return channel_1.utf8.decode(buffer, markerLow);\n    } else if (marker === STRING_8) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt8());\n    } else if (marker === STRING_16) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt16());\n    } else if (marker === STRING_32) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt32());\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_LIST) {\n      return this._unpackListWithSize(markerLow, buffer);\n    } else if (marker === LIST_8) {\n      return this._unpackListWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === LIST_16) {\n      return this._unpackListWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === LIST_32) {\n      return this._unpackListWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n    var value = [];\n\n    for (var i = 0; i < size; i++) {\n      value.push(this.unpack(buffer));\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n    if (marker === BYTES_8) {\n      return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === BYTES_16) {\n      return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === BYTES_32) {\n      return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n    var value = new Int8Array(size);\n\n    for (var i = 0; i < size; i++) {\n      value[i] = buffer.readInt8();\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_MAP) {\n      return this._unpackMapWithSize(markerLow, buffer);\n    } else if (marker === MAP_8) {\n      return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === MAP_16) {\n      return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === MAP_32) {\n      return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n    var value = {};\n\n    for (var i = 0; i < size; i++) {\n      var key = this.unpack(buffer);\n      value[key] = this.unpack(buffer);\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRUCT) {\n      return this._unpackStructWithSize(markerLow, buffer);\n    } else if (marker === STRUCT_8) {\n      return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === STRUCT_16) {\n      return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n    var signature = buffer.readUInt8();\n\n    if (signature === NODE) {\n      return this._unpackNode(structSize, buffer);\n    } else if (signature === RELATIONSHIP) {\n      return this._unpackRelationship(structSize, buffer);\n    } else if (signature === UNBOUND_RELATIONSHIP) {\n      return this._unpackUnboundRelationship(structSize, buffer);\n    } else if (signature === PATH) {\n      return this._unpackPath(structSize, buffer);\n    } else {\n      return this._unpackUnknownStruct(signature, structSize, buffer);\n    }\n  };\n\n  Unpacker.prototype._unpackNode = function (structSize, buffer) {\n    this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.Node(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Labels\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n    this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.Relationship(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Start Node Identity\n    this.unpack(buffer), // End Node Identity\n    this.unpack(buffer), // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n    this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackPath = function (structSize, buffer) {\n    this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n\n    var nodes = this.unpack(buffer);\n    var rels = this.unpack(buffer);\n    var sequence = this.unpack(buffer);\n    var segments = [];\n    var prevNode = nodes[0];\n\n    for (var i = 0; i < sequence.length; i += 2) {\n      var nextNode = nodes[sequence[i + 1]];\n      var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n      var rel = void 0;\n\n      if (relIndex > 0) {\n        rel = rels[relIndex - 1];\n\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // To avoid duplication, relationships in a path do not contain\n          // information about their start and end nodes, that's instead\n          // inferred from the path sequence. This is us inferring (and,\n          // for performance reasons remembering) the start/end of a rel.\n          rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n        }\n      } else {\n        rel = rels[-relIndex - 1];\n\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // See above\n          rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n        }\n      } // Done hydrating one path segment.\n\n\n      segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n      prevNode = nextNode;\n    }\n\n    return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n  };\n\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    var result = new Structure(signature, []);\n\n    for (var i = 0; i < structSize; i++) {\n      result.fields.push(this.unpack(buffer));\n    }\n\n    return result;\n  };\n\n  Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n    if (expectedSize !== actualSize) {\n      throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n    }\n  };\n\n  return Unpacker;\n}();\n\nexports.Unpacker = Unpacker;\n\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return typeof obj[Symbol.iterator] === 'function';\n}","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v1.js"],"names":["Object","defineProperty","exports","value","Structure","Unpacker","Packer","channel_1","require","neo4j_driver_core_1","PROTOCOL_ERROR","error","TINY_STRING","TINY_LIST","TINY_MAP","TINY_STRUCT","NULL","FLOAT_64","FALSE","TRUE","INT_8","INT_16","INT_32","INT_64","STRING_8","STRING_16","STRING_32","LIST_8","LIST_16","LIST_32","BYTES_8","BYTES_16","BYTES_32","MAP_8","MAP_16","MAP_32","STRUCT_8","STRUCT_16","NODE","NODE_STRUCT_SIZE","RELATIONSHIP","RELATIONSHIP_STRUCT_SIZE","UNBOUND_RELATIONSHIP","UNBOUND_RELATIONSHIP_STRUCT_SIZE","PATH","PATH_STRUCT_SIZE","signature","fields","prototype","toString","fieldStr","i","length","channel","_ch","_byteArraysSupported","packable","x","_this","writeUInt8","packFloat","packString","packInteger","int","isInt","Int8Array","packBytes","Array","packListHeader","i_1","undefined","isIterable","packableIterable","Node","_nonPackableValue","Relationship","Path","packableFields","packStruct","keys","count","i_2","packMapHeader","i_3","key","iterable","array","from","e","newError","message","packStructHeader","high","low","greaterThanOrEqual","lessThan","writeInt8","writeInt16","writeInt32","writeFloat64","bytes","utf8","encode","size","writeBytes","packBytesHeader","disableByteArrays","disableLosslessIntegers","useBigInt","_disableLosslessIntegers","_useBigInt","unpack","buffer","marker","readUInt8","markerHigh","markerLow","boolean","_unpackBoolean","numberOrInteger","_unpackNumberOrInteger","toBigInt","toNumberOrInfinity","string","_unpackString","list","_unpackList","byteArray","_unpackByteArray","map","_unpackMap","struct","_unpackStruct","unpackInteger","result","_unpackInteger","readFloat64","readInt8","readInt16","b","readInt32","Integer","decode","readUInt16","readUInt32","_unpackListWithSize","push","_unpackByteArrayWithSize","_unpackMapWithSize","_unpackStructWithSize","structSize","_unpackNode","_unpackRelationship","_unpackUnboundRelationship","_unpackPath","_unpackUnknownStruct","_verifyStructSize","UnboundRelationship","nodes","rels","sequence","segments","prevNode","nextNode","relIndex","toNumber","rel","bind","identity","PathSegment","structName","expectedSize","actualSize","obj","Symbol","iterator"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\nvar Structure = /** @class */ (function () {\n    /**\n     * Create new instance\n     */\n    function Structure(signature, fields) {\n        this.signature = signature;\n        this.fields = fields;\n    }\n    Structure.prototype.toString = function () {\n        var fieldStr = '';\n        for (var i = 0; i < this.fields.length; i++) {\n            if (i > 0) {\n                fieldStr += ', ';\n            }\n            fieldStr += this.fields[i];\n        }\n        return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n    };\n    return Structure;\n}());\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\nvar Packer = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Chunker} channel the chunker backed by a network channel.\n     */\n    function Packer(channel) {\n        this._ch = channel;\n        this._byteArraysSupported = true;\n    }\n    /**\n     * Creates a packable function out of the provided value\n     * @param x the value to pack\n     * @returns Function\n     */\n    Packer.prototype.packable = function (x) {\n        var _this = this;\n        if (x === null) {\n            return function () { return _this._ch.writeUInt8(NULL); };\n        }\n        else if (x === true) {\n            return function () { return _this._ch.writeUInt8(TRUE); };\n        }\n        else if (x === false) {\n            return function () { return _this._ch.writeUInt8(FALSE); };\n        }\n        else if (typeof x === 'number') {\n            return function () { return _this.packFloat(x); };\n        }\n        else if (typeof x === 'string') {\n            return function () { return _this.packString(x); };\n        }\n        else if (typeof x === 'bigint') {\n            return function () { return _this.packInteger((0, neo4j_driver_core_1.int)(x)); };\n        }\n        else if ((0, neo4j_driver_core_1.isInt)(x)) {\n            return function () { return _this.packInteger(x); };\n        }\n        else if (x instanceof Int8Array) {\n            return function () { return _this.packBytes(x); };\n        }\n        else if (x instanceof Array) {\n            return function () {\n                _this.packListHeader(x.length);\n                for (var i_1 = 0; i_1 < x.length; i_1++) {\n                    _this.packable(x[i_1] === undefined ? null : x[i_1])();\n                }\n            };\n        }\n        else if (isIterable(x)) {\n            return this.packableIterable(x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Node) {\n            return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Relationship) {\n            return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Path) {\n            return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n        }\n        else if (x instanceof Structure) {\n            var packableFields = [];\n            for (var i = 0; i < x.fields.length; i++) {\n                packableFields[i] = this.packable(x.fields[i]);\n            }\n            return function () { return _this.packStruct(x.signature, packableFields); };\n        }\n        else if (typeof x === 'object') {\n            return function () {\n                var keys = Object.keys(x);\n                var count = 0;\n                for (var i_2 = 0; i_2 < keys.length; i_2++) {\n                    if (x[keys[i_2]] !== undefined) {\n                        count++;\n                    }\n                }\n                _this.packMapHeader(count);\n                for (var i_3 = 0; i_3 < keys.length; i_3++) {\n                    var key = keys[i_3];\n                    if (x[key] !== undefined) {\n                        _this.packString(key);\n                        _this.packable(x[key])();\n                    }\n                }\n            };\n        }\n        else {\n            return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n        }\n    };\n    Packer.prototype.packableIterable = function (iterable) {\n        try {\n            var array = Array.from(iterable);\n            return this.packable(array);\n        }\n        catch (e) {\n            // handle errors from iterable to array conversion\n            throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n        }\n    };\n    /**\n     * Packs a struct\n     * @param signature the signature of the struct\n     * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n     */\n    Packer.prototype.packStruct = function (signature, packableFields) {\n        packableFields = packableFields || [];\n        this.packStructHeader(packableFields.length, signature);\n        for (var i = 0; i < packableFields.length; i++) {\n            packableFields[i]();\n        }\n    };\n    Packer.prototype.packInteger = function (x) {\n        var high = x.high;\n        var low = x.low;\n        if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n            this._ch.writeUInt8(INT_8);\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n            this._ch.writeUInt8(INT_16);\n            this._ch.writeInt16(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n            this._ch.writeUInt8(INT_32);\n            this._ch.writeInt32(low);\n        }\n        else {\n            this._ch.writeUInt8(INT_64);\n            this._ch.writeInt32(high);\n            this._ch.writeInt32(low);\n        }\n    };\n    Packer.prototype.packFloat = function (x) {\n        this._ch.writeUInt8(FLOAT_64);\n        this._ch.writeFloat64(x);\n    };\n    Packer.prototype.packString = function (x) {\n        var bytes = channel_1.utf8.encode(x);\n        var size = bytes.length;\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRING | size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRING_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRING_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(STRING_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packListHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_LIST | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(LIST_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(LIST_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(LIST_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packBytes = function (array) {\n        if (this._byteArraysSupported) {\n            this.packBytesHeader(array.length);\n            for (var i = 0; i < array.length; i++) {\n                this._ch.writeInt8(array[i]);\n            }\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n        }\n    };\n    Packer.prototype.packBytesHeader = function (size) {\n        if (size < 0x100) {\n            this._ch.writeUInt8(BYTES_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(BYTES_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(BYTES_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packMapHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_MAP | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(MAP_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(MAP_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(MAP_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packStructHeader = function (size, signature) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRUCT | size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRUCT_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRUCT_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.disableByteArrays = function () {\n        this._byteArraysSupported = false;\n    };\n    Packer.prototype._nonPackableValue = function (message) {\n        return function () {\n            throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n        };\n    };\n    return Packer;\n}());\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\nvar Unpacker = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n     */\n    function Unpacker(disableLosslessIntegers, useBigInt) {\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\n        if (useBigInt === void 0) { useBigInt = false; }\n        this._disableLosslessIntegers = disableLosslessIntegers;\n        this._useBigInt = useBigInt;\n    }\n    Unpacker.prototype.unpack = function (buffer) {\n        var marker = buffer.readUInt8();\n        var markerHigh = marker & 0xf0;\n        var markerLow = marker & 0x0f;\n        if (marker === NULL) {\n            return null;\n        }\n        var boolean = this._unpackBoolean(marker);\n        if (boolean !== null) {\n            return boolean;\n        }\n        var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n        if (numberOrInteger !== null) {\n            if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n                if (this._useBigInt) {\n                    return numberOrInteger.toBigInt();\n                }\n                else if (this._disableLosslessIntegers) {\n                    return numberOrInteger.toNumberOrInfinity();\n                }\n            }\n            return numberOrInteger;\n        }\n        var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n        if (string !== null) {\n            return string;\n        }\n        var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n        if (list !== null) {\n            return list;\n        }\n        var byteArray = this._unpackByteArray(marker, buffer);\n        if (byteArray !== null) {\n            return byteArray;\n        }\n        var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n        if (map !== null) {\n            return map;\n        }\n        var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n        if (struct !== null) {\n            return struct;\n        }\n        throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n    };\n    Unpacker.prototype.unpackInteger = function (buffer) {\n        var marker = buffer.readUInt8();\n        var result = this._unpackInteger(marker, buffer);\n        if (result == null) {\n            throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n        }\n        return result;\n    };\n    Unpacker.prototype._unpackBoolean = function (marker) {\n        if (marker === TRUE) {\n            return true;\n        }\n        else if (marker === FALSE) {\n            return false;\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n        if (marker === FLOAT_64) {\n            return buffer.readFloat64();\n        }\n        else {\n            return this._unpackInteger(marker, buffer);\n        }\n    };\n    Unpacker.prototype._unpackInteger = function (marker, buffer) {\n        if (marker >= 0 && marker < 128) {\n            return (0, neo4j_driver_core_1.int)(marker);\n        }\n        else if (marker >= 240 && marker < 256) {\n            return (0, neo4j_driver_core_1.int)(marker - 256);\n        }\n        else if (marker === INT_8) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n        }\n        else if (marker === INT_16) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n        }\n        else if (marker === INT_32) {\n            var b = buffer.readInt32();\n            return (0, neo4j_driver_core_1.int)(b);\n        }\n        else if (marker === INT_64) {\n            var high = buffer.readInt32();\n            var low = buffer.readInt32();\n            return new neo4j_driver_core_1.Integer(low, high);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRING) {\n            return channel_1.utf8.decode(buffer, markerLow);\n        }\n        else if (marker === STRING_8) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt8());\n        }\n        else if (marker === STRING_16) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt16());\n        }\n        else if (marker === STRING_32) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt32());\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_LIST) {\n            return this._unpackListWithSize(markerLow, buffer);\n        }\n        else if (marker === LIST_8) {\n            return this._unpackListWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === LIST_16) {\n            return this._unpackListWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === LIST_32) {\n            return this._unpackListWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n        var value = [];\n        for (var i = 0; i < size; i++) {\n            value.push(this.unpack(buffer));\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n        if (marker === BYTES_8) {\n            return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === BYTES_16) {\n            return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === BYTES_32) {\n            return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n        var value = new Int8Array(size);\n        for (var i = 0; i < size; i++) {\n            value[i] = buffer.readInt8();\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_MAP) {\n            return this._unpackMapWithSize(markerLow, buffer);\n        }\n        else if (marker === MAP_8) {\n            return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === MAP_16) {\n            return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === MAP_32) {\n            return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n        var value = {};\n        for (var i = 0; i < size; i++) {\n            var key = this.unpack(buffer);\n            value[key] = this.unpack(buffer);\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRUCT) {\n            return this._unpackStructWithSize(markerLow, buffer);\n        }\n        else if (marker === STRUCT_8) {\n            return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === STRUCT_16) {\n            return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n        var signature = buffer.readUInt8();\n        if (signature === NODE) {\n            return this._unpackNode(structSize, buffer);\n        }\n        else if (signature === RELATIONSHIP) {\n            return this._unpackRelationship(structSize, buffer);\n        }\n        else if (signature === UNBOUND_RELATIONSHIP) {\n            return this._unpackUnboundRelationship(structSize, buffer);\n        }\n        else if (signature === PATH) {\n            return this._unpackPath(structSize, buffer);\n        }\n        else {\n            return this._unpackUnknownStruct(signature, structSize, buffer);\n        }\n    };\n    Unpacker.prototype._unpackNode = function (structSize, buffer) {\n        this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Node(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Labels\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n        this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Relationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Start Node Identity\n        this.unpack(buffer), // End Node Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n        this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackPath = function (structSize, buffer) {\n        this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n        var nodes = this.unpack(buffer);\n        var rels = this.unpack(buffer);\n        var sequence = this.unpack(buffer);\n        var segments = [];\n        var prevNode = nodes[0];\n        for (var i = 0; i < sequence.length; i += 2) {\n            var nextNode = nodes[sequence[i + 1]];\n            var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n            var rel = void 0;\n            if (relIndex > 0) {\n                rel = rels[relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // To avoid duplication, relationships in a path do not contain\n                    // information about their start and end nodes, that's instead\n                    // inferred from the path sequence. This is us inferring (and,\n                    // for performance reasons remembering) the start/end of a rel.\n                    rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n                }\n            }\n            else {\n                rel = rels[-relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // See above\n                    rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n                }\n            }\n            // Done hydrating one path segment.\n            segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n            prevNode = nextNode;\n        }\n        return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n    };\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n        var result = new Structure(signature, []);\n        for (var i = 0; i < structSize; i++) {\n            result.fields.push(this.unpack(buffer));\n        }\n        return result;\n    };\n    Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n        if (expectedSize !== actualSize) {\n            throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n        }\n    };\n    return Unpacker;\n}());\nexports.Unpacker = Unpacker;\nfunction isIterable(obj) {\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\n"]},"metadata":{},"sourceType":"script"}