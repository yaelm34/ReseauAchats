{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function observeOn(scheduler, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n\n  return function observeOnOperatorFunction(source) {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\n\nvar ObserveOnOperator = /*@__PURE__*/function () {\n  function ObserveOnOperator(scheduler, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  ObserveOnOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n  };\n\n  return ObserveOnOperator;\n}();\n\nexport { ObserveOnOperator };\n\nvar ObserveOnSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ObserveOnSubscriber, _super);\n\n  function ObserveOnSubscriber(destination, scheduler, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    var _this = _super.call(this, destination) || this;\n\n    _this.scheduler = scheduler;\n    _this.delay = delay;\n    return _this;\n  }\n\n  ObserveOnSubscriber.dispatch = function (arg) {\n    var notification = arg.notification,\n        destination = arg.destination;\n    notification.observe(destination);\n    this.unsubscribe();\n  };\n\n  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n    var destination = this.destination;\n    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n  };\n\n  ObserveOnSubscriber.prototype._next = function (value) {\n    this.scheduleMessage(Notification.createNext(value));\n  };\n\n  ObserveOnSubscriber.prototype._error = function (err) {\n    this.scheduleMessage(Notification.createError(err));\n    this.unsubscribe();\n  };\n\n  ObserveOnSubscriber.prototype._complete = function () {\n    this.scheduleMessage(Notification.createComplete());\n    this.unsubscribe();\n  };\n\n  return ObserveOnSubscriber;\n}(Subscriber);\n\nexport { ObserveOnSubscriber };\n\nvar ObserveOnMessage = /*@__PURE__*/function () {\n  function ObserveOnMessage(notification, destination) {\n    this.notification = notification;\n    this.destination = destination;\n  }\n\n  return ObserveOnMessage;\n}();\n\nexport { ObserveOnMessage };","map":{"version":3,"mappings":";AAEA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAEA,SAASC,UAAT,QAAuB,eAAvB;AAuDA,SAAMC,YAAN,QAA6B,iBAA7B;OAAuD,8BAAiBC,KAAjB,EAAiB;AACtE,WAAO,UAAS,CAAhB,EAAgB;AACdA,YAAO,CAAP;AACD;;AACF;AAED;AACE,GAHD;;;qBAGqB,GAAS,aAAe;WAAUC,kBAAiBC;AACtE;AAEDF;AACE;;AACD;AACH;AAAC;;;AAOD;AAA4C;;AAQ1C;CArB4C;;SAqB5CC;;uBAC6B,GAAT,aAAwB;SACxB,gCAAiBE;;;AAEpC;AAVMH;AACG;;AACR,gBAAYG,MAAC,KAAD,CAAS,IAAT,EAASC,WAAT,KAAsB,IAAlC;;AACAC,SAAK,UAAL,GAAkBH,SAAlB;AACDG;AAQO;;;qBAES,CAACC,WAAK,UAAUC,GAAV,EACnB;AAIH;AAAA;AAESC;AACR,SAAKC,WAAL;AACD;;AAESC,kDAAV,UAAyBF,YAAzB,EAAyB;AACvB,QAAIJ,WAAC,QAAgBA,WAArB;AACAA,eAAK,IAAL,CAAgB,KAAGF,SAAH,CAAGS,QAAH,CAAGD,4BAAH,EAAG,UAAH,EAAG,oDAAH,CAAhB;AACD,GAHS;;AAKAA,kDAAVE,KAAU,EAAV;AACE,SAAKC,eAAL,CAAqBd,YAAY,CAACe,UAAb,CAAaF,KAAb,CAArB;GADQ;;AAGVF,qBAAC,UAAD,CAACK,MAAD,GAAC;AACH,qCAAC,YAAD,CAACC,GAAD;AApC4C,SAAUP,WAAV;GAmC1C;;AAGFC;AACE,qCAAmB,CAA+BO,cAAlD;AAAmB;GADrB;;AAGE,SAACP,mBAAD;CAhC4C;;AAiC9C,SAACA,mBAAD","names":["tslib_1","Subscriber","Notification","delay","ObserveOnOperator","scheduler","_super","destination","_this","dispatch","arg","notification","unsubscribe","ObserveOnSubscriber","schedule","value","scheduleMessage","createNext","_error","err","createComplete"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\observeOn.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { Notification } from '../Notification';\r\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\r\n\r\n/**\r\n *\r\n * Re-emits all notifications from source Observable with specified scheduler.\r\n *\r\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\r\n *\r\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\r\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\r\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\r\n *\r\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\r\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\r\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\r\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\r\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\r\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\r\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\r\n * little bit more, to ensure that they are emitted at expected moments.\r\n *\r\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\r\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\r\n * will delay all notifications - including error notifications - while `delay` will pass through error\r\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\r\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\r\n * for notification emissions in general.\r\n *\r\n * ## Example\r\n * Ensure values in subscribe are called just before browser repaint.\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { observeOn } from 'rxjs/operators';\r\n *\r\n * const intervals = interval(10);                // Intervals are scheduled\r\n *                                                // with async scheduler by default...\r\n * intervals.pipe(\r\n *   observeOn(animationFrameScheduler),          // ...but we will observe on animationFrame\r\n * )                                              // scheduler to ensure smooth animation.\r\n * .subscribe(val => {\r\n *   someDiv.style.height = val + 'px';\r\n * });\r\n * ```\r\n *\r\n * @see {@link delay}\r\n *\r\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\r\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\r\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\r\n * but with provided scheduler.\r\n *\r\n * @method observeOn\r\n * @owner Observable\r\n */\r\nexport function observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\r\n  return function observeOnOperatorFunction(source: Observable<T>): Observable<T> {\r\n    return source.lift(new ObserveOnOperator(scheduler, delay));\r\n  };\r\n}\r\n\r\nexport class ObserveOnOperator<T> implements Operator<T, T> {\r\n  constructor(private scheduler: SchedulerLike, private delay: number = 0) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nexport class ObserveOnSubscriber<T> extends Subscriber<T> {\r\n  /** @nocollapse */\r\n  static dispatch(this: SchedulerAction<ObserveOnMessage>, arg: ObserveOnMessage) {\r\n    const { notification, destination } = arg;\r\n    notification.observe(destination);\r\n    this.unsubscribe();\r\n  }\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private scheduler: SchedulerLike,\r\n              private delay: number = 0) {\r\n    super(destination);\r\n  }\r\n\r\n  private scheduleMessage(notification: Notification<any>): void {\r\n    const destination = this.destination as Subscription;\r\n    destination.add(this.scheduler.schedule(\r\n      ObserveOnSubscriber.dispatch,\r\n      this.delay,\r\n      new ObserveOnMessage(notification, this.destination)\r\n    ));\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    this.scheduleMessage(Notification.createNext(value));\r\n  }\r\n\r\n  protected _error(err: any): void {\r\n    this.scheduleMessage(Notification.createError(err));\r\n    this.unsubscribe();\r\n  }\r\n\r\n  protected _complete(): void {\r\n    this.scheduleMessage(Notification.createComplete());\r\n    this.unsubscribe();\r\n  }\r\n}\r\n\r\nexport class ObserveOnMessage {\r\n  constructor(public notification: Notification<any>,\r\n              public destination: PartialObserver<any>) {\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}