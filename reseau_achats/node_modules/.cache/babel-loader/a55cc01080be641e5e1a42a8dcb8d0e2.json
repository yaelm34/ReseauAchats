{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { from } from '../observable/from';\nimport { isArray } from '../util/isArray';\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\nexport function onErrorResumeNext() {\n  var nextSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nextSources[_i] = arguments[_i];\n  }\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n\n  return function (source) {\n    return source.lift(new OnErrorResumeNextOperator(nextSources));\n  };\n}\nexport function onErrorResumeNextStatic() {\n  var nextSources = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nextSources[_i] = arguments[_i];\n  }\n\n  var source = undefined;\n\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\n    nextSources = nextSources[0];\n  }\n\n  source = nextSources.shift();\n  return from(source).lift(new OnErrorResumeNextOperator(nextSources));\n}\n\nvar OnErrorResumeNextOperator = /*@__PURE__*/function () {\n  function OnErrorResumeNextOperator(nextSources) {\n    this.nextSources = nextSources;\n  }\n\n  OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n  };\n\n  return OnErrorResumeNextOperator;\n}();\n\nvar OnErrorResumeNextSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(OnErrorResumeNextSubscriber, _super);\n\n  function OnErrorResumeNextSubscriber(destination, nextSources) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    _this.nextSources = nextSources;\n    return _this;\n  }\n\n  OnErrorResumeNextSubscriber.prototype.notifyError = function () {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {\n    this.subscribeToNextSource();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._error = function (err) {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  };\n\n  OnErrorResumeNextSubscriber.prototype._complete = function () {\n    this.subscribeToNextSource();\n    this.unsubscribe();\n  };\n\n  OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n    var next = this.nextSources.shift();\n\n    if (!!next) {\n      var innerSubscriber = new SimpleInnerSubscriber(this);\n      var destination = this.destination;\n      destination.add(innerSubscriber);\n      var innerSubscription = innerSubscribe(next, innerSubscriber);\n\n      if (innerSubscription !== innerSubscriber) {\n        destination.add(innerSubscription);\n      }\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  return OnErrorResumeNextSubscriber;\n}(SimpleOuterSubscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAIA,SAASC,IAAT,QAAkB,oBAAlB;AAEA,SAASC,OAAT,QAAS,iBAAT;AAmFA,SAAMC,qBAAN,EAAgBC,qBAAhB,EAAiCC,cAAjC,QAAiC,mBAAjC;OAAwC,6BAC2C;iBAAA,GAD3C;;OAAA,mCAC2CC;;AACjF;;MACEC,WAAW,OAAX,KAAsC,CAAtC,IAAoDL,OAAC;AACtDK;AAED;;AACD;AAAA;AAAA;AAaD;OAA8C,mCAEb;iBAAA,GAFa;;OAAA,mCAEbD;;AAC/B;;AAEA,MAAIE,kBAAJ;;MACED,WAAW,OAAX,KAAc,CAAd,IAAsDL,OAAC;AACxDK;AAED;;AAEAC,WAAOD,WAAa,MAAb,EAAP;AACD;AAED;;IACEE,yCAAoB,YAAwC;WAAxCA,0BAAwCF;AAC3D;AAED;;2BACgB,WAAcG,6BAA4BF,MAA5B,EAAwC;AACrE;AACH;;AAPA,SAOCC,yBAPD;AASA,CARsB;;IAQ0BE,qDAA2BC,MAA3B,EAA2B;AACzEZ,iDAAsBY,MAAtB;;WAAAD,4BAEQE,aAAYN,aACnB;AAHqB,sBAAW,KAAX,uBAA0B,IAA1B;;AACFO;;AAEnB;AAED;;6BACO,WAAwBC;AAC9B;AAED;;6BACO,WAAwBC;AAC9B;AAES;;6BACH,WAAwBC;AAC7B,SAAKC,qBAAL;AACD;AAES;;6BACH,WAAwBC;AAC7B,SAAKD,qBAAL;AACD;AAEO;;6BACY,WAAiBA,wBAAG;AACtC,QAAIE,IAAE,GAAI,KAAEb,WAAF,CAAEc,KAAF,EAAV;;QACE,QAAM;AACN,UAAMC,eAAc,GAAI,IAAClB,qBAAD,CAA6B,IAA7B,CAAxB;AACA,qBAAe,GAAC,gBAAhB;AACAS,iBAAM,IAAN,CAAMS,eAAN;AAIA,UAAIC,iBAAiB,iBAAK,OAAiBD,eAAjB,CAA1B;;UACEC,iBAAgB,sBAAmB;AACpCV;AACF;WACC;AACD;AACF;AACH;;AAzCgD;CAAA","names":["tslib_1","from","isArray","SimpleOuterSubscriber","SimpleInnerSubscriber","innerSubscribe","_i","nextSources","source","OnErrorResumeNextOperator","call","OnErrorResumeNextSubscriber","_super","destination","_this","notifyError","notifyComplete","_error","subscribeToNextSource","_complete","next","shift","innerSubscriber","innerSubscription"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\onErrorResumeNext.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { from } from '../observable/from';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { isArray } from '../util/isArray';\r\nimport { ObservableInput, OperatorFunction } from '../types';\r\nimport { SimpleOuterSubscriber, SimpleInnerSubscriber, innerSubscribe } from '../innerSubscribe';\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function onErrorResumeNext<T>(): OperatorFunction<T, T>;\r\nexport function onErrorResumeNext<T, T2>(v: ObservableInput<T2>): OperatorFunction<T, T | T2>;\r\nexport function onErrorResumeNext<T, T2, T3>(v: ObservableInput<T2>, v2: ObservableInput<T3>): OperatorFunction<T, T | T2 | T3>;\r\nexport function onErrorResumeNext<T, T2, T3, T4>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>): OperatorFunction<T, T | T2 | T3 | T4>;\r\nexport function onErrorResumeNext<T, T2, T3, T4, T5>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>): OperatorFunction<T, T | T2 | T3 | T4 | T5>;\r\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6>;\r\nexport function onErrorResumeNext<T, T2, T3, T4, T5, T6, T7>(v: ObservableInput<T2>, v2: ObservableInput<T3>, v3: ObservableInput<T4>, v4: ObservableInput<T5>, v5: ObservableInput<T6>, v6: ObservableInput<T7>): OperatorFunction<T, T | T2 | T3 | T4 | T5 | T6 | T7>;\r\nexport function onErrorResumeNext<T, R>(...observables: Array<ObservableInput<any>>): OperatorFunction<T, T | R>;\r\nexport function onErrorResumeNext<T, R>(array: ObservableInput<any>[]): OperatorFunction<T, T | R>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\r\n * that was passed.\r\n *\r\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\r\n *\r\n * ![](onErrorResumeNext.png)\r\n *\r\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\r\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\r\n * as the source.\r\n *\r\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\r\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\r\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\r\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\r\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\r\n * be happening until there is no more Observables left in the series, at which point returned Observable will\r\n * complete - even if the last subscribed stream ended with an error.\r\n *\r\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\r\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\r\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\r\n * an error.\r\n *\r\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\r\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\r\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\r\n *\r\n *\r\n * ## Example\r\n * Subscribe to the next Observable after map fails\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n * import { onErrorResumeNext, map } from 'rxjs/operators';\r\n *\r\n * of(1, 2, 3, 0).pipe(\r\n *   map(x => {\r\n *       if (x === 0) { throw Error(); }\r\n *        return 10 / x;\r\n *   }),\r\n *   onErrorResumeNext(of(1, 2, 3)),\r\n * )\r\n * .subscribe(\r\n *   val => console.log(val),\r\n *   err => console.log(err),          // Will never be called.\r\n *   () => console.log('that\\'s it!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 5\r\n * // 3.3333333333333335\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // \"that's it!\"\r\n * ```\r\n *\r\n * @see {@link concat}\r\n * @see {@link catchError}\r\n *\r\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\r\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\r\n * to the next passed Observable and so on, until it completes or runs out of Observables.\r\n * @method onErrorResumeNext\r\n * @owner Observable\r\n */\r\n\r\nexport function onErrorResumeNext<T, R>(...nextSources: Array<ObservableInput<any> |\r\n                                                       Array<ObservableInput<any>>>): OperatorFunction<T, R> {\r\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\r\n    nextSources = <Array<Observable<any>>>nextSources[0];\r\n  }\r\n\r\n  return (source: Observable<T>) => source.lift(new OnErrorResumeNextOperator<T, R>(nextSources));\r\n}\r\n\r\n/* tslint:disable:max-line-length */\r\nexport function onErrorResumeNextStatic<R>(v: ObservableInput<R>): Observable<R>;\r\nexport function onErrorResumeNextStatic<T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<R>;\r\nexport function onErrorResumeNextStatic<T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<R>;\r\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<R>;\r\nexport function onErrorResumeNextStatic<T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<R>;\r\n\r\nexport function onErrorResumeNextStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\r\nexport function onErrorResumeNextStatic<R>(array: ObservableInput<any>[]): Observable<R>;\r\n/* tslint:enable:max-line-length */\r\n\r\nexport function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> |\r\n  Array<ObservableInput<any>> |\r\n  ((...values: Array<any>) => R)>): Observable<R> {\r\n  let source: ObservableInput<any>|undefined = undefined;\r\n\r\n  if (nextSources.length === 1 && isArray(nextSources[0])) {\r\n    nextSources = nextSources[0] as ObservableInput<any>[];\r\n  }\r\n  // TODO: resolve issue with passing no arguments.\r\n  source = nextSources.shift()!;\r\n\r\n  return from(source).lift(new OnErrorResumeNextOperator<T, R>(nextSources));\r\n}\r\n\r\nclass OnErrorResumeNextOperator<T, R> implements Operator<T, R> {\r\n  constructor(private nextSources: Array<ObservableInput<any>>) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<R>, source: any): any {\r\n    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\r\n  }\r\n}\r\n\r\nclass OnErrorResumeNextSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\r\n  constructor(protected destination: Subscriber<T>,\r\n              private nextSources: Array<ObservableInput<any>>) {\r\n    super(destination);\r\n  }\r\n\r\n  notifyError(): void {\r\n    this.subscribeToNextSource();\r\n  }\r\n\r\n  notifyComplete(): void {\r\n    this.subscribeToNextSource();\r\n  }\r\n\r\n  protected _error(err: any): void {\r\n    this.subscribeToNextSource();\r\n    this.unsubscribe();\r\n  }\r\n\r\n  protected _complete(): void {\r\n    this.subscribeToNextSource();\r\n    this.unsubscribe();\r\n  }\r\n\r\n  private subscribeToNextSource(): void {\r\n    const next = this.nextSources.shift();\r\n    if (!!next) {\r\n      const innerSubscriber = new SimpleInnerSubscriber(this);\r\n      const destination = this.destination as Subscription;\r\n      destination.add(innerSubscriber);\r\n      const innerSubscription = innerSubscribe(next, innerSubscriber);\r\n      // The returned subscription will usually be the subscriber that was\r\n      // passed. However, interop subscribers will be wrapped and for\r\n      // unsubscriptions to chain correctly, the wrapper needs to be added, too.\r\n      if (innerSubscription !== innerSubscriber) {\r\n        destination.add(innerSubscription);\r\n      }\r\n    } else {\r\n      this.destination.complete();\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}