{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\nexport function tap(nextOrObserver, error, complete) {\n  return function tapOperatorFunction(source) {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nvar DoOperator = /*@__PURE__*/function () {\n  function DoOperator(nextOrObserver, error, complete) {\n    this.nextOrObserver = nextOrObserver;\n    this.error = error;\n    this.complete = complete;\n  }\n\n  DoOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  };\n\n  return DoOperator;\n}();\n\nvar TapSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TapSubscriber, _super);\n\n  function TapSubscriber(destination, observerOrNext, error, complete) {\n    var _this = _super.call(this, destination) || this;\n\n    _this._tapNext = noop;\n    _this._tapError = noop;\n    _this._tapComplete = noop;\n    _this._tapError = error || noop;\n    _this._tapComplete = complete || noop;\n\n    if (isFunction(observerOrNext)) {\n      _this._context = _this;\n      _this._tapNext = observerOrNext;\n    } else if (observerOrNext) {\n      _this._context = observerOrNext;\n      _this._tapNext = observerOrNext.next || noop;\n      _this._tapError = observerOrNext.error || noop;\n      _this._tapComplete = observerOrNext.complete || noop;\n    }\n\n    return _this;\n  }\n\n  TapSubscriber.prototype._next = function (value) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(value);\n  };\n\n  TapSubscriber.prototype._error = function (err) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.error(err);\n  };\n\n  TapSubscriber.prototype._complete = function () {\n    try {\n      this._tapComplete.call(this._context);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    return this.destination.complete();\n  };\n\n  return TapSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AAGA,SAASC,UAAT,QAAqB,eAArB;AACA,SAASC,IAAT,QAAqB,cAArB;AA6DA,SAAMC,UAAN,QAAuB,oBAAvB;OAGE,SAAOC,GAAP,CAAgBC,cAAhB,EAAgBC,KAAhB,EAAoCC,QAApC,EAAyD;SACvD,SAAOC,mBAAP,CAAuBC,MAAvB,EAAkC;AAClC;AACH;AAED;;IACEC,0BAAoB,YACA;WADAA,kCAAsDH;AACtD,0BAAwBF,cAAxB;AACA,iBAAQC,KAAR;AACnB;AACD;;YACE,CAAOK,UAAOC,OAAU,UAAIC,UAAJ,EAAkBJ,MAAlB,EAA8B;AACvD;AACH;;AARA,SAQCC,UARD;AAgBA,CAfsB;;IAeSI,uCAAaC,MAAb,EAAa;AAS1Cf,mCAAYe,MAAZ;;WAAAD,cAIIE,aAAMC,gBAAYX,OAYnBC;AAtBK,sBAAiC,KAAjC,CAAsC,IAAtC,EAAsCS,WAAtC,KAAsC,IAAtC;;AAEAE,qBAAShB,IAAT;AAEAgB,sBAAYhB,IAAZ;AAOJgB,SAAI,CAACC,YAAL,GAAiBjB,IAAjB;AACAgB,SAAI,CAACE,SAAL,GAAiBd,KAAG,QAApB;AACAY,SAAI,aAAJ,GAAeX,QAAc,IAAGL,IAAhC;;QACEC,UAAK,kBAAgB;AACrBe,WAAI,CAACG,QAAL,GAAgBH,KAAhB;AACDA;WACC,IAAID,cAAJ,EAAgB;AAChBC,WAAI,CAACG,QAAL,GAAgBJ,cAAhB;AACAC,WAAI,CAACI,QAAL,GAAcL,cAAG,CAAcM,IAAjB,IAAuBrB,IAArC;AACAgB,WAAI,CAACE,SAAL,GAAiBH,cAAG,MAAH,IAAkBf,IAAnC;AACDgB;;;AACF;AAEH;;eACM;QACF;AACD;AAAC,aACAM,KAAK;AACL,uBAAOlB,KAAP,CAAOkB,GAAP;AACD;AACD;;AACD;AAED;;eACM;QACF;AACD;AAAC,aACAA,KAAK;AACL,uBAAOlB,KAAP,CAAOkB,GAAP;AACD;AACD;;AACD;AAED;;eACM;QACF;AACD;AAAC,aACAA,KAAK;AACL,uBAAOlB,KAAP,CAAOkB,GAAP;AACD;AACD;;AACD;AACH;;AAxD+B;CAAA","names":["tslib_1","Subscriber","noop","isFunction","tap","nextOrObserver","error","complete","tapOperatorFunction","source","DoOperator","prototype","call","subscriber","TapSubscriber","_super","destination","observerOrNext","_this","_tapComplete","_tapError","_context","_tapNext","next","err"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\tap.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\r\nimport { noop } from '../util/noop';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/* tslint:disable:max-line-length */\r\n/** @deprecated Use an observer instead of a complete callback */\r\nexport function tap<T>(next: null | undefined, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\r\n/** @deprecated Use an observer instead of an error callback */\r\nexport function tap<T>(next: null | undefined, error: (error: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\r\n/** @deprecated Use an observer instead of a complete callback */\r\nexport function tap<T>(next: (value: T) => void, error: null | undefined, complete: () => void): MonoTypeOperatorFunction<T>;\r\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\r\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\r\n/* tslint:enable:max-line-length */\r\n\r\n/**\r\n * Perform a side effect for every emission on the source Observable, but return\r\n * an Observable that is identical to the source.\r\n *\r\n * <span class=\"informal\">Intercepts each emission on the source and runs a\r\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\r\n *\r\n * ![](do.png)\r\n *\r\n * Returns a mirrored Observable of the source Observable, but modified so that\r\n * the provided Observer is called to perform a side effect for every value,\r\n * error, and completion emitted by the source. Any errors that are thrown in\r\n * the aforementioned Observer or handlers are safely sent down the error path\r\n * of the output Observable.\r\n *\r\n * This operator is useful for debugging your Observables for the correct values\r\n * or performing other side effects.\r\n *\r\n * Note: this is different to a `subscribe` on the Observable. If the Observable\r\n * returned by `tap` is not subscribed, the side effects specified by the\r\n * Observer will never happen. `tap` therefore simply spies on existing\r\n * execution, it does not trigger an execution to happen like `subscribe` does.\r\n *\r\n * ## Example\r\n * Map every click to the clientX position of that click, while also logging the click event\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { tap, map } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const positions = clicks.pipe(\r\n *   tap(ev => console.log(ev)),\r\n *   map(ev => ev.clientX),\r\n * );\r\n * positions.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link map}\r\n * @see {@link Observable#subscribe}\r\n *\r\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\r\n * callback for `next`.\r\n * @param {function} [error] Callback for errors in the source.\r\n * @param {function} [complete] Callback for the completion of the source.\r\n * @return {Observable} An Observable identical to the source, but runs the\r\n * specified Observer or callback(s) for each item.\r\n * @name tap\r\n */\r\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\r\n                       error?: (e: any) => void,\r\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\r\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\r\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\r\n  };\r\n}\r\n\r\nclass DoOperator<T> implements Operator<T, T> {\r\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\r\n              private error?: (e: any) => void,\r\n              private complete?: () => void) {\r\n  }\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\n\r\nclass TapSubscriber<T> extends Subscriber<T> {\r\n  private _context: any;\r\n\r\n  private _tapNext: ((value: T) => void) = noop;\r\n\r\n  private _tapError: ((err: any) => void) = noop;\r\n\r\n  private _tapComplete: (() => void) = noop;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\r\n              error?: (e?: any) => void,\r\n              complete?: () => void) {\r\n      super(destination);\r\n      this._tapError = error || noop;\r\n      this._tapComplete = complete || noop;\r\n      if (isFunction(observerOrNext)) {\r\n        this._context = this;\r\n        this._tapNext = observerOrNext;\r\n      } else if (observerOrNext) {\r\n        this._context = observerOrNext;\r\n        this._tapNext = observerOrNext.next || noop;\r\n        this._tapError = observerOrNext.error || noop;\r\n        this._tapComplete = observerOrNext.complete || noop;\r\n      }\r\n    }\r\n\r\n  _next(value: T) {\r\n    try {\r\n      this._tapNext.call(this._context, value);\r\n    } catch (err) {\r\n      this.destination.error(err);\r\n      return;\r\n    }\r\n    this.destination.next(value);\r\n  }\r\n\r\n  _error(err: any) {\r\n    try {\r\n      this._tapError.call(this._context, err);\r\n    } catch (err) {\r\n      this.destination.error(err);\r\n      return;\r\n    }\r\n    this.destination.error(err);\r\n  }\r\n\r\n  _complete() {\r\n    try {\r\n      this._tapComplete.call(this._context, );\r\n    } catch (err) {\r\n      this.destination.error(err);\r\n      return;\r\n    }\r\n    return this.destination.complete();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}