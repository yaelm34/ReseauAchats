{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar routing_table_1 = __importDefault(require(\"./routing-table\"));\n\nvar bolt_1 = require(\"../bolt\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar SERVICE_UNAVAILABLE = neo4j_driver_core_1.error.SERVICE_UNAVAILABLE;\nvar PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';\nvar DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';\n\nvar Rediscovery =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @param {object} routingContext\r\n   */\n  function Rediscovery(routingContext) {\n    this._routingContext = routingContext;\n  }\n  /**\r\n   * Try to fetch new routing table from the given router.\r\n   * @param {Session} session the session to use.\r\n   * @param {string} database the database for which to lookup routing table.\r\n   * @param {ServerAddress} routerAddress the URL of the router.\r\n   * @param {string} impersonatedUser The impersonated user\r\n   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.\r\n   */\n\n\n  Rediscovery.prototype.lookupRoutingTableOnRouter = function (session, database, routerAddress, impersonatedUser) {\n    var _this = this;\n\n    return session._acquireConnection(function (connection) {\n      return _this._requestRawRoutingTable(connection, session, database, routerAddress, impersonatedUser).then(function (rawRoutingTable) {\n        if (rawRoutingTable.isNull) {\n          return null;\n        }\n\n        return routing_table_1.default.fromRawRoutingTable(database, routerAddress, rawRoutingTable);\n      });\n    });\n  };\n\n  Rediscovery.prototype._requestRawRoutingTable = function (connection, session, database, routerAddress, impersonatedUser) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      connection.protocol().requestRoutingInformation({\n        routingContext: _this._routingContext,\n        databaseName: database,\n        impersonatedUser: impersonatedUser,\n        sessionContext: {\n          bookmark: session._lastBookmark,\n          mode: session._mode,\n          database: session._database,\n          afterComplete: session._onComplete\n        },\n        onCompleted: resolve,\n        onError: function (error) {\n          if (error.code === DATABASE_NOT_FOUND_CODE) {\n            reject(error);\n          } else if (error.code === PROCEDURE_NOT_FOUND_CODE) {\n            // throw when getServers procedure not found because this is clearly a configuration issue\n            reject((0, neo4j_driver_core_1.newError)(\"Server at \" + routerAddress.asHostPort() + \" can't perform routing. Make sure you are connecting to a causal cluster\", SERVICE_UNAVAILABLE));\n          } else {\n            // return nothing when failed to connect because code higher in the callstack is still able to retry with a\n            // different session towards a different router\n            resolve(bolt_1.RawRoutingTable.ofNull());\n          }\n        }\n      });\n    });\n  };\n\n  return Rediscovery;\n}();\n\nexports.default = Rediscovery;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/rediscovery/rediscovery.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","routing_table_1","require","bolt_1","neo4j_driver_core_1","SERVICE_UNAVAILABLE","error","PROCEDURE_NOT_FOUND_CODE","DATABASE_NOT_FOUND_CODE","Rediscovery","routingContext","_routingContext","prototype","lookupRoutingTableOnRouter","session","database","routerAddress","impersonatedUser","_this","_acquireConnection","connection","_requestRawRoutingTable","then","rawRoutingTable","isNull","default","fromRawRoutingTable","Promise","resolve","reject","protocol","requestRoutingInformation","databaseName","sessionContext","bookmark","_lastBookmark","mode","_mode","_database","afterComplete","_onComplete","onCompleted","onError","code","newError","asHostPort","RawRoutingTable","ofNull"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar routing_table_1 = __importDefault(require(\"./routing-table\"));\r\nvar bolt_1 = require(\"../bolt\");\r\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\r\nvar SERVICE_UNAVAILABLE = neo4j_driver_core_1.error.SERVICE_UNAVAILABLE;\r\nvar PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';\r\nvar DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';\r\nvar Rediscovery = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @param {object} routingContext\r\n     */\r\n    function Rediscovery(routingContext) {\r\n        this._routingContext = routingContext;\r\n    }\r\n    /**\r\n     * Try to fetch new routing table from the given router.\r\n     * @param {Session} session the session to use.\r\n     * @param {string} database the database for which to lookup routing table.\r\n     * @param {ServerAddress} routerAddress the URL of the router.\r\n     * @param {string} impersonatedUser The impersonated user\r\n     * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.\r\n     */\r\n    Rediscovery.prototype.lookupRoutingTableOnRouter = function (session, database, routerAddress, impersonatedUser) {\r\n        var _this = this;\r\n        return session._acquireConnection(function (connection) {\r\n            return _this._requestRawRoutingTable(connection, session, database, routerAddress, impersonatedUser).then(function (rawRoutingTable) {\r\n                if (rawRoutingTable.isNull) {\r\n                    return null;\r\n                }\r\n                return routing_table_1.default.fromRawRoutingTable(database, routerAddress, rawRoutingTable);\r\n            });\r\n        });\r\n    };\r\n    Rediscovery.prototype._requestRawRoutingTable = function (connection, session, database, routerAddress, impersonatedUser) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            connection.protocol().requestRoutingInformation({\r\n                routingContext: _this._routingContext,\r\n                databaseName: database,\r\n                impersonatedUser: impersonatedUser,\r\n                sessionContext: {\r\n                    bookmark: session._lastBookmark,\r\n                    mode: session._mode,\r\n                    database: session._database,\r\n                    afterComplete: session._onComplete\r\n                },\r\n                onCompleted: resolve,\r\n                onError: function (error) {\r\n                    if (error.code === DATABASE_NOT_FOUND_CODE) {\r\n                        reject(error);\r\n                    }\r\n                    else if (error.code === PROCEDURE_NOT_FOUND_CODE) {\r\n                        // throw when getServers procedure not found because this is clearly a configuration issue\r\n                        reject((0, neo4j_driver_core_1.newError)(\"Server at \" + routerAddress.asHostPort() + \" can't perform routing. Make sure you are connecting to a causal cluster\", SERVICE_UNAVAILABLE));\r\n                    }\r\n                    else {\r\n                        // return nothing when failed to connect because code higher in the callstack is still able to retry with a\r\n                        // different session towards a different router\r\n                        resolve(bolt_1.RawRoutingTable.ofNull());\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Rediscovery;\r\n}());\r\nexports.default = Rediscovery;\r\n"]},"metadata":{},"sourceType":"script"}