{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nvar VirtualTimeScheduler = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(VirtualTimeScheduler, _super);\n\n  function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n    if (SchedulerAction === void 0) {\n      SchedulerAction = VirtualAction;\n    }\n\n    if (maxFrames === void 0) {\n      maxFrames = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      return _this.frame;\n    }) || this;\n\n    _this.maxFrames = maxFrames;\n    _this.frame = 0;\n    _this.index = -1;\n    return _this;\n  }\n\n  VirtualTimeScheduler.prototype.flush = function () {\n    var _a = this,\n        actions = _a.actions,\n        maxFrames = _a.maxFrames;\n\n    var error, action;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n}(AsyncScheduler);\n\nexport { VirtualTimeScheduler };\n\nvar VirtualAction = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(VirtualAction, _super);\n\n  function VirtualAction(scheduler, work, index) {\n    if (index === void 0) {\n      index = scheduler.index += 1;\n    }\n\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.index = index;\n    _this.active = true;\n    _this.index = scheduler.index = index;\n    return _this;\n  }\n\n  VirtualAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (!this.id) {\n      return _super.prototype.schedule.call(this, state, delay);\n    }\n\n    this.active = false;\n    var action = new VirtualAction(this.scheduler, this.work);\n    this.add(action);\n    return action.schedule(state, delay);\n  };\n\n  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    this.delay = scheduler.frame + delay;\n    var actions = scheduler.actions;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return true;\n  };\n\n  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return undefined;\n  };\n\n  VirtualAction.prototype._execute = function (state, delay) {\n    if (this.active === true) {\n      return _super.prototype._execute.call(this, state, delay);\n    }\n  };\n\n  VirtualAction.sortActions = function (a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  return VirtualAction;\n}(AsyncAction);\n\nexport { VirtualAction };","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAT,MAAsB,OAAtB;AAEA,SAASC,WAAT,QAAyB,eAAzB;AAGA;;IAA0CC,8CAAcC,MAAd,EAAc;AAOtDH,0CAAYG,MAAZ;;WAAYD,iDAAsC;AAC/B;AADnBE,qBAEE,gBAFF;AACmB;;AAJZ,iBAAK,KAAa,MAAlB,EAAkB;AAClBC,eAAK,GAAaC,MAAC,kBAAnB;;;AAKN;AAAA;AAAA;;AAOMC;AAECA,kBAA2B,CAA3B;AACNA,SAAI,MAAJ,GAAgB,EAAhB;AAEA,WAAOA,KAAP;;;sBAEY,CAAGC,UAAOC,QAAM;QAE1BC,KAAI;QAAKC,OAAS,GAACD;QAAcL,SAAQ,KAAM,CAACA;;eAC9CO;;WACD;AACFD;AAEG,WAAKE,KAAL,GAAOD,YAAP;;AACF,eAAO,SAAS,QAAT,CAAiBA,MAAS,MAA1B,EAA0BA,YAA1B,CAAP,EAAiC;AAC/B;AACD;;;QAEFE;AACF;AAnCgBF;AAoCnB;;AAtC0C,YAAcE,KAAd;AAA7B;AA4Cb;;AAAsCZ;AAIpC;CAhDwC;;SAgDxCA;;iBAAsB,gBAAS,UAAsBC,MAAtB,EAAsB;SAC/B,0BAAmDA;;WACnDY,cAAKC,WAA+BC;AAJhD,kBAAM,KAAgB,CAAtB,EAAuB;AAM/BC,WAAK,GAAKF,SAAG,MAAH,IAAkB,CAA5B;;;AACD;;AAEMT;AAAoBA;AACzBA,SAAK,MAAL,GAAcW,KAAd;SACE,UAAO;SACR;AACD,WAAKX,KAAL;;;eAMS,WAAQY;AACjB,aAAO,KAAO,MAAd,EAAsB;AACvBC;AAES;;AAA0D;AAC9D,aAAMjB,MAAG,UAAH,CAAkBgB,QAAlB,CAA2BE,IAA3B,CAA2B,IAA3B,EAA2BC,KAA3B,EAA2BF,KAA3B,CAAN;AACG;;AACP,kBAAa,KAAb;AACC,cAAoC,GAAK,kBAAc,cAAd,EAA2B,SAA3B,CAAzC;AACD,aAAOR,MAAP;AACD;AAES;;eAA0D,4BAAiB;AACnF,aAAO,UAAU,CAAjB,EAAiB;AAClBQ;AAES;;AACR,SAAIA,KAAJ,GAASJ,SAAW,MAAX,GAAiBI,KAA1B;QACET,OAAO;WACR;AACFA;AAEa;;;eAEL,CAACH,UAAUe,iBAAS;aACvB,UAAS;WACV;;;;;;eAEM;aACLC,WAAU;aACXrB;AACF;;;eACC,eAAS;QACVsB;UAAMA;AACL,eAAU,CAAV;AACD,aACF;AACH;AA1DiD,OAyD9C;;;;;;;;;;;CArD8B","names":["tslib_1","AsyncAction","VirtualTimeScheduler","_super","SchedulerAction","maxFrames","Number","_this","prototype","flush","_a","actions","action","frame","error","VirtualAction","scheduler","work","index","schedule","delay","call","state","recycleAsyncId","active","a"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\scheduler\\VirtualTimeScheduler.ts"],"sourcesContent":["import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { SchedulerAction } from '../types';\r\n\r\nexport class VirtualTimeScheduler extends AsyncScheduler {\r\n\r\n  protected static frameTimeFactor: number = 10;\r\n\r\n  public frame: number = 0;\r\n  public index: number = -1;\r\n\r\n  constructor(SchedulerAction: typeof AsyncAction = VirtualAction as any,\r\n              public maxFrames: number = Number.POSITIVE_INFINITY) {\r\n    super(SchedulerAction, () => this.frame);\r\n  }\r\n\r\n  /**\r\n   * Prompt the Scheduler to execute all of its queued actions, therefore\r\n   * clearing its queue.\r\n   * @return {void}\r\n   */\r\n  public flush(): void {\r\n\r\n    const {actions, maxFrames} = this;\r\n    let error: any, action: AsyncAction<any>;\r\n\r\n    while ((action = actions[0]) && action.delay <= maxFrames) {\r\n      actions.shift();\r\n      this.frame = action.delay;\r\n\r\n      if (error = action.execute(action.state, action.delay)) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      while (action = actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @nodoc\r\n */\r\nexport class VirtualAction<T> extends AsyncAction<T> {\r\n\r\n  protected active: boolean = true;\r\n\r\n  constructor(protected scheduler: VirtualTimeScheduler,\r\n              protected work: (this: SchedulerAction<T>, state?: T) => void,\r\n              protected index: number = scheduler.index += 1) {\r\n    super(scheduler, work);\r\n    this.index = scheduler.index = index;\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (!this.id) {\r\n      return super.schedule(state, delay);\r\n    }\r\n    this.active = false;\r\n    // If an action is rescheduled, we save allocations by mutating its state,\r\n    // pushing it to the end of the scheduler queue, and recycling the action.\r\n    // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n    // must be immutable so they can be inspected later.\r\n    const action = new VirtualAction(this.scheduler, this.work);\r\n    this.add(action);\r\n    return action.schedule(state, delay);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\r\n    this.delay = scheduler.frame + delay;\r\n    const {actions} = scheduler;\r\n    actions.push(this);\r\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\r\n    return true;\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\r\n    return undefined;\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    if (this.active === true) {\r\n      return super._execute(state, delay);\r\n    }\r\n  }\r\n\r\n  public static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\r\n    if (a.delay === b.delay) {\r\n      if (a.index === b.index) {\r\n        return 0;\r\n      } else if (a.index > b.index) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    } else if (a.delay > b.delay) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}