{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isNumeric } from '../util/isNumeric';\nexport function interval(period, scheduler) {\n  if (period === void 0) {\n    period = 0;\n  }\n\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  if (!isNumeric(period) || period < 0) {\n    period = 0;\n  }\n\n  if (!scheduler || typeof scheduler.schedule !== 'function') {\n    scheduler = async;\n  }\n\n  return new Observable(function (subscriber) {\n    subscriber.add(scheduler.schedule(dispatch, period, {\n      subscriber: subscriber,\n      counter: 0,\n      period: period\n    }));\n    return subscriber;\n  });\n}\n\nfunction dispatch(state) {\n  var subscriber = state.subscriber,\n      counter = state.counter,\n      period = state.period;\n  subscriber.next(counter);\n  this.schedule({\n    subscriber: subscriber,\n    counter: counter + 1,\n    period: period\n  }, period);\n}","map":{"version":3,"mappings":"AAAA;AACA,SAASA,UAAT,QAAsB,eAAtB;AAEA,SAASC,KAAT,QAAoB,oBAApB;AAmDA,SAAMC,SAAN,QAAyB,mBAAzB;OAAyB,qCAAU;AACV;AACnBC,UAAC,IAAD;;;MAEHC;AAEGA,aAAC,GAASH,KAAV;;;MAEH;AAEDE,UAAO,GAAI,CAAX;;;MAIE,cAAO,OAAWC,kBAAX,KAAW;AACjBA;AACJ;;AAED,SAAS,eAAmE;AAClEC,sCAAYC,QAAZ,EAAYH,MAAZ,EAAY;AAAOE,gBAAE,YAAT;AAA0BE,gBAA1B;AAA0BJ;AAA1B,KAAZ;AACR,WAAWE,UAAX;AACA,GAHO,CAAT;AAIC","names":["Observable","async","isNumeric","period","scheduler","subscriber","dispatch","counter"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\interval.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { async } from '../scheduler/async';\r\nimport { SchedulerAction, SchedulerLike } from '../types';\r\nimport { isNumeric } from '../util/isNumeric';\r\nimport { Subscriber } from '../Subscriber';\r\n\r\n/**\r\n * Creates an Observable that emits sequential numbers every specified\r\n * interval of time, on a specified {@link SchedulerLike}.\r\n *\r\n * <span class=\"informal\">Emits incremental numbers periodically in time.\r\n * </span>\r\n *\r\n * ![](interval.png)\r\n *\r\n * `interval` returns an Observable that emits an infinite sequence of\r\n * ascending integers, with a constant interval of time of your choosing\r\n * between those emissions. The first emission is not sent immediately, but\r\n * only after the first period has passed. By default, this operator uses the\r\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\r\n * {@link SchedulerLike} to it.\r\n *\r\n * ## Example\r\n * Emits ascending numbers, one every second (1000ms) up to the number 3\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { take } from 'rxjs/operators';\r\n *\r\n * const numbers = interval(1000);\r\n *\r\n * const takeFourNumbers = numbers.pipe(take(4));\r\n *\r\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\r\n *\r\n * // Logs:\r\n * // Next: 0\r\n * // Next: 1\r\n * // Next: 2\r\n * // Next: 3\r\n * ```\r\n *\r\n * @see {@link timer}\r\n * @see {@link delay}\r\n *\r\n * @param {number} [period=0] The interval size in milliseconds (by default)\r\n * or the time unit determined by the scheduler's clock.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for scheduling\r\n * the emission of values, and providing a notion of \"time\".\r\n * @return {Observable} An Observable that emits a sequential number each time\r\n * interval.\r\n * @static true\r\n * @name interval\r\n * @owner Observable\r\n */\r\nexport function interval(period = 0,\r\n                         scheduler: SchedulerLike = async): Observable<number> {\r\n  if (!isNumeric(period) || period < 0) {\r\n    period = 0;\r\n  }\r\n\r\n  if (!scheduler || typeof scheduler.schedule !== 'function') {\r\n    scheduler = async;\r\n  }\r\n\r\n  return new Observable<number>(subscriber => {\r\n    subscriber.add(\r\n      scheduler.schedule(dispatch, period, { subscriber, counter: 0, period })\r\n    );\r\n    return subscriber;\r\n  });\r\n}\r\n\r\nfunction dispatch(this: SchedulerAction<IntervalState>, state: IntervalState) {\r\n  const { subscriber, counter, period } = state;\r\n  subscriber.next(counter);\r\n  this.schedule({ subscriber, counter: counter + 1, period }, period);\r\n}\r\n\r\ninterface IntervalState {\r\n  subscriber: Subscriber<number>;\r\n  counter: number;\r\n  period: number;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}