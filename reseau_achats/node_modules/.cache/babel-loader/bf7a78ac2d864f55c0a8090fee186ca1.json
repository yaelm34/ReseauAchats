{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\nexport function delay(delay, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  var absoluteDelay = isDate(delay);\n  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);\n  return function (source) {\n    return source.lift(new DelayOperator(delayFor, scheduler));\n  };\n}\n\nvar DelayOperator = /*@__PURE__*/function () {\n  function DelayOperator(delay, scheduler) {\n    this.delay = delay;\n    this.scheduler = scheduler;\n  }\n\n  DelayOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n  };\n\n  return DelayOperator;\n}();\n\nvar DelaySubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(DelaySubscriber, _super);\n\n  function DelaySubscriber(destination, delay, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.delay = delay;\n    _this.scheduler = scheduler;\n    _this.queue = [];\n    _this.active = false;\n    _this.errored = false;\n    return _this;\n  }\n\n  DelaySubscriber.dispatch = function (state) {\n    var source = state.source;\n    var queue = source.queue;\n    var scheduler = state.scheduler;\n    var destination = state.destination;\n\n    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {\n      queue.shift().notification.observe(destination);\n    }\n\n    if (queue.length > 0) {\n      var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n      this.schedule(state, delay_1);\n    } else {\n      this.unsubscribe();\n      source.active = false;\n    }\n  };\n\n  DelaySubscriber.prototype._schedule = function (scheduler) {\n    this.active = true;\n    var destination = this.destination;\n    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n      source: this,\n      destination: this.destination,\n      scheduler: scheduler\n    }));\n  };\n\n  DelaySubscriber.prototype.scheduleNotification = function (notification) {\n    if (this.errored === true) {\n      return;\n    }\n\n    var scheduler = this.scheduler;\n    var message = new DelayMessage(scheduler.now() + this.delay, notification);\n    this.queue.push(message);\n\n    if (this.active === false) {\n      this._schedule(scheduler);\n    }\n  };\n\n  DelaySubscriber.prototype._next = function (value) {\n    this.scheduleNotification(Notification.createNext(value));\n  };\n\n  DelaySubscriber.prototype._error = function (err) {\n    this.errored = true;\n    this.queue = [];\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  DelaySubscriber.prototype._complete = function () {\n    this.scheduleNotification(Notification.createComplete());\n    this.unsubscribe();\n  };\n\n  return DelaySubscriber;\n}(Subscriber);\n\nvar DelayMessage = /*@__PURE__*/function () {\n  function DelayMessage(time, notification) {\n    this.time = time;\n    this.notification = notification;\n  }\n\n  return DelayMessage;\n}();","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAT,MAAsB,OAAtB;AACA,SAASC,KAAT,QAAiB,oBAAjB;AAEA,SAASC,MAAT,QAAqB,gBAArB;AAEA,SAASC,UAAT,QAAuB,eAAvB;AAsDA,SAAMC,YAAN,QACyB,iBADzB;OACyB;AACvB,MAAMC,cAAa,KAAG,CAAtB,EAA4B;AACtBA,aAAQ,GAAGJ,KAAX;AACN;;AACD;AAED;AACE,2BAAoB;AAAA,WACAK,MAAwB,KAAxB,CAAwB,sCAAxB,CADA;AACwB,GAD5C;;;iBACoB,gBAAwB;AAC5C,WAACC,aAAD,CAACC,KAAD,EAACH,SAAD,EAAC;AAED;AACE,qBAAcA,SAAd;AACD;;AACHE,0BAACE,IAAD,GAAC;AAAA;AAaD,GAbA;;AAaiC;CAnBa;;mBA2C5C,GAGE,uBAAMC,MAAN,EAAkB;SAFA,4BAAaA;;WACbC,6BAAwBH;AAzBpC,gBAAKE,MAA8B,KAA9B,CAA8B,IAA9B,EAA8BE,WAA9B,KAA8B,IAAnC;;AACAC,kBAAML,KAAN;AACAK,sBAAmBR,SAAnB;;AAyBPQ;AAvBcA;AACb,WAAMA,KAAN;;;iBAEM,YAAkB,UAAUC,KAAV,EAAU;AAClC,QAAMR,cAAc,OAApB;AAEA,aAAO,GAAKA,MAAC,CAAMS,KAAnB;QACEV,SAAM,GAAKS,KAAG;QACfF;;AAED,WAAIG,KAAM,OAAN,GAAkB,CAAlB,IAAkBA,oCAAtB,EAAsB;AACpBA,WAAM,MAAN,GAAcC,YAAd,CAA0BC,OAA1B,CAAmCL,WAAnC;;;QAEDG;UAAMG;AACL,WAAKC,QAAL,CAAKL,KAAL,EAAmBI,OAAnB;WAED;AACF;AAQOZ;AACN;;;iBAEW,CAACc,UAAIC,YAAkB,UAAgBhB,SAAhB,EAAgC;SAChEiB,SAAQ;QACNV;AACLA;AAEON,kBAFP;AAEOM,mCAFP;AAEDP,eAA6B;AAF5B;;;iBAKE;AAED,QAAM,iBAAiB,IAAvB,EAAuB;AACjB;AACN;;AAEA,QAAIA,SAAK,GAAM,KAAKA,SAApB;QACEkB,OAAK,OAASC,YAAT,CAAqBnB,4BAArB,EAAqBW,YAArB;SACND;;AACF;AAES;AACR;AACD;;AAESJ,oCAAM,UAAhBc,KAAgB,EAAS;AACvB,SAAKC,oBAAL,CAAoBtB,8BAApB;GADQ;;iBAGH,WAAiBuB,SAAM;AAC5B,SAAKC,OAAL,GAAK,IAAL;AACD;AAES;AACR,SAAKC,WAAL;;;AAEFlB,iBAAC,UAAD,CAACmB,SAAD,GAAC;AACH,8BAAC1B,6BAAD;AAnEiC,SAAUyB,WAAV;AAqEjC,GAHE;;AAIA;CA3CE;;gBA4C0B,4BAA6B;AACzD,WAACL,YAAD,CAACO,IAAD,EAACf,YAAD,EAAC;AACH;AAAC;;;;CAF6B","names":["tslib_1","async","isDate","Subscriber","Notification","scheduler","source","DelayOperator","delay","call","_super","DelaySubscriber","destination","_this","state","queue","notification","observe","delay_1","schedule","prototype","_schedule","active","message","DelayMessage","value","scheduleNotification","_error","errored","unsubscribe","_complete","time"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\delay.ts"],"sourcesContent":["import { async } from '../scheduler/async';\r\nimport { isDate } from '../util/isDate';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { Notification } from '../Notification';\r\nimport { Observable } from '../Observable';\r\nimport { MonoTypeOperatorFunction, PartialObserver, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\r\n\r\n/**\r\n * Delays the emission of items from the source Observable by a given timeout or\r\n * until a given Date.\r\n *\r\n * <span class=\"informal\">Time shifts each item by some specified amount of\r\n * milliseconds.</span>\r\n *\r\n * ![](delay.png)\r\n *\r\n * If the delay argument is a Number, this operator time shifts the source\r\n * Observable by that amount of time expressed in milliseconds. The relative\r\n * time intervals between the values are preserved.\r\n *\r\n * If the delay argument is a Date, this operator time shifts the start of the\r\n * Observable execution until the given date occurs.\r\n *\r\n * ## Examples\r\n * Delay each click by one second\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { delay } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\r\n * delayedClicks.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * Delay all clicks until a future date happens\r\n * ```ts\r\n * import { fromEvent } from 'rxjs';\r\n * import { delay } from 'rxjs/operators';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\r\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\r\n * delayedClicks.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link debounceTime}\r\n * @see {@link delayWhen}\r\n *\r\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\r\n * a `Date` until which the emission of the source items is delayed.\r\n * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for\r\n * managing the timers that handle the time-shift for each item.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified timeout or Date.\r\n * @method delay\r\n * @owner Observable\r\n */\r\nexport function delay<T>(delay: number|Date,\r\n                         scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\r\n  const absoluteDelay = isDate(delay);\r\n  const delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(<number>delay);\r\n  return (source: Observable<T>) => source.lift(new DelayOperator(delayFor, scheduler));\r\n}\r\n\r\nclass DelayOperator<T> implements Operator<T, T> {\r\n  constructor(private delay: number,\r\n              private scheduler: SchedulerLike) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\r\n  }\r\n}\r\n\r\ninterface DelayState<T> {\r\n  source: DelaySubscriber<T>;\r\n  destination: PartialObserver<T>;\r\n  scheduler: SchedulerLike;\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass DelaySubscriber<T> extends Subscriber<T> {\r\n  private queue: Array<DelayMessage<T>> = [];\r\n  private active: boolean = false;\r\n  private errored: boolean = false;\r\n\r\n  private static dispatch<T>(this: SchedulerAction<DelayState<T>>, state: DelayState<T>): void {\r\n    const source = state.source;\r\n    const queue = source.queue;\r\n    const scheduler = state.scheduler;\r\n    const destination = state.destination;\r\n\r\n    while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\r\n      queue.shift().notification.observe(destination);\r\n    }\r\n\r\n    if (queue.length > 0) {\r\n      const delay = Math.max(0, queue[0].time - scheduler.now());\r\n      this.schedule(state, delay);\r\n    } else {\r\n      this.unsubscribe();\r\n      source.active = false;\r\n    }\r\n  }\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private delay: number,\r\n              private scheduler: SchedulerLike) {\r\n    super(destination);\r\n  }\r\n\r\n  private _schedule(scheduler: SchedulerLike): void {\r\n    this.active = true;\r\n    const destination = this.destination as Subscription;\r\n    destination.add(scheduler.schedule<DelayState<T>>(DelaySubscriber.dispatch, this.delay, {\r\n      source: this, destination: this.destination, scheduler: scheduler\r\n    }));\r\n  }\r\n\r\n  private scheduleNotification(notification: Notification<T>): void {\r\n    if (this.errored === true) {\r\n      return;\r\n    }\r\n\r\n    const scheduler = this.scheduler;\r\n    const message = new DelayMessage(scheduler.now() + this.delay, notification);\r\n    this.queue.push(message);\r\n\r\n    if (this.active === false) {\r\n      this._schedule(scheduler);\r\n    }\r\n  }\r\n\r\n  protected _next(value: T) {\r\n    this.scheduleNotification(Notification.createNext(value));\r\n  }\r\n\r\n  protected _error(err: any) {\r\n    this.errored = true;\r\n    this.queue = [];\r\n    this.destination.error(err);\r\n    this.unsubscribe();\r\n  }\r\n\r\n  protected _complete() {\r\n    this.scheduleNotification(Notification.createComplete());\r\n    this.unsubscribe();\r\n  }\r\n}\r\n\r\nclass DelayMessage<T> {\r\n  constructor(public readonly time: number,\r\n              public readonly notification: Notification<T>) {\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}