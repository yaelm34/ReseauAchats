{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\n\nvar integer_1 = __importStar(require(\"../integer\"));\n\nvar error_1 = require(\"../error\");\n\nvar util_1 = require(\"./util\");\n/*\r\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\r\n\r\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\r\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\r\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\r\n\r\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\r\n  conversion functions.\r\n */\n\n\nvar ValueRange =\n/** @class */\nfunction () {\n  function ValueRange(min, max) {\n    this._minNumber = min;\n    this._maxNumber = max;\n    this._minInteger = (0, integer_1.int)(min);\n    this._maxInteger = (0, integer_1.int)(max);\n  }\n\n  ValueRange.prototype.contains = function (value) {\n    if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n      return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);\n    } else if (typeof value === 'bigint') {\n      var intValue = (0, integer_1.int)(value);\n      return intValue.greaterThanOrEqual(this._minInteger) && intValue.lessThanOrEqual(this._maxInteger);\n    } else {\n      return value >= this._minNumber && value <= this._maxNumber;\n    }\n  };\n\n  ValueRange.prototype.toString = function () {\n    return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\n  };\n\n  return ValueRange;\n}();\n\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\n\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n  return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\n\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\n\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n  return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\n\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\r\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\r\n * @param {Integer|number|string} hour the hour of the local time to convert.\r\n * @param {Integer|number|string} minute the minute of the local time to convert.\r\n * @param {Integer|number|string} second the second of the local time to convert.\r\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\r\n * @return {Integer} nanoseconds representing the given local time.\r\n */\n\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  nanosecond = (0, integer_1.int)(nanosecond);\n  var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n  totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n  totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n  return totalNanos.add(nanosecond);\n}\n\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\r\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\r\n * @param {Integer|number|string} year the year of the local date-time to convert.\r\n * @param {Integer|number|string} month the month of the local date-time to convert.\r\n * @param {Integer|number|string} day the day of the local date-time to convert.\r\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\r\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\r\n * @param {Integer|number|string} second the second of the local date-time to convert.\r\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\r\n * @return {Integer} epoch second in UTC representing the given local date time.\r\n */\n\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n  var epochDay = dateToEpochDay(year, month, day);\n  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n  return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\n\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\r\n * Converts given local date into a single integer representing it's epoch day.\r\n * @param {Integer|number|string} year the year of the local date to convert.\r\n * @param {Integer|number|string} month the month of the local date to convert.\r\n * @param {Integer|number|string} day the day of the local date to convert.\r\n * @return {Integer} epoch day representing the given date.\r\n */\n\nfunction dateToEpochDay(year, month, day) {\n  year = (0, integer_1.int)(year);\n  month = (0, integer_1.int)(month);\n  day = (0, integer_1.int)(day);\n  var epochDay = year.multiply(365);\n\n  if (year.greaterThanOrEqual(0)) {\n    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));\n  } else {\n    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));\n  }\n\n  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));\n  epochDay = epochDay.add(day.subtract(1));\n\n  if (month.greaterThan(2)) {\n    epochDay = epochDay.subtract(1);\n\n    if (!isLeapYear(year)) {\n      epochDay = epochDay.subtract(1);\n    }\n  }\n\n  return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\n\nexports.dateToEpochDay = dateToEpochDay;\n/**\r\n * Format given duration to an ISO 8601 string.\r\n * @param {Integer|number|string} months the number of months.\r\n * @param {Integer|number|string} days the number of days.\r\n * @param {Integer|number|string} seconds the number of seconds.\r\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\r\n * @return {string} ISO string that represents given duration.\r\n */\n\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n  var monthsString = formatNumber(months);\n  var daysString = formatNumber(days);\n  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n  return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\n}\n\nexports.durationToIsoString = durationToIsoString;\n/**\r\n * Formats given time to an ISO 8601 string.\r\n * @param {Integer|number|string} hour the hour value.\r\n * @param {Integer|number|string} minute the minute value.\r\n * @param {Integer|number|string} second the second value.\r\n * @param {Integer|number|string} nanosecond the nanosecond value.\r\n * @return {string} ISO string that represents given time.\r\n */\n\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n  var hourString = formatNumber(hour, 2);\n  var minuteString = formatNumber(minute, 2);\n  var secondString = formatNumber(second, 2);\n  var nanosecondString = formatNanosecond(nanosecond);\n  return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\n}\n\nexports.timeToIsoString = timeToIsoString;\n/**\r\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\r\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\r\n * @return {string} ISO string that represents given offset.\r\n */\n\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n  offsetSeconds = (0, integer_1.int)(offsetSeconds);\n\n  if (offsetSeconds.equals(0)) {\n    return 'Z';\n  }\n\n  var isNegative = offsetSeconds.isNegative();\n\n  if (isNegative) {\n    offsetSeconds = offsetSeconds.multiply(-1);\n  }\n\n  var signPrefix = isNegative ? '-' : '+';\n  var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n  var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n  var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n  return seconds ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds : \"\" + signPrefix + hours + \":\" + minutes;\n}\n\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\r\n * Formats given date to an ISO 8601 string.\r\n * @param {Integer|number|string} year the date year.\r\n * @param {Integer|number|string} month the date month.\r\n * @param {Integer|number|string} day the date day.\r\n * @return {string} ISO string that represents given date.\r\n */\n\nfunction dateToIsoString(year, month, day) {\n  year = (0, integer_1.int)(year);\n  var isNegative = year.isNegative();\n\n  if (isNegative) {\n    year = year.multiply(-1);\n  }\n\n  var yearString = formatNumber(year, 4);\n\n  if (isNegative) {\n    yearString = '-' + yearString;\n  }\n\n  var monthString = formatNumber(month, 2);\n  var dayString = formatNumber(day, 2);\n  return yearString + \"-\" + monthString + \"-\" + dayString;\n}\n\nexports.dateToIsoString = dateToIsoString;\n/**\r\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\r\n * @param {global.Date} standardDate the standard JavaScript date.\r\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\r\n * @return {Integer|number|bigint} the total amount of nanoseconds.\r\n */\n\nfunction totalNanoseconds(standardDate, nanoseconds) {\n  nanoseconds = nanoseconds || 0;\n  var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n  return add(nanoseconds, nanosFromMillis);\n}\n\nexports.totalNanoseconds = totalNanoseconds;\n/**\r\n * Get the time zone offset in seconds from the given standard JavaScript date.\r\n *\r\n * <b>Implementation note:</b>\r\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\r\n * So positive value means offset is behind UTC and negative value means it is ahead.\r\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\r\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\r\n *\r\n * @param {global.Date} standardDate the standard JavaScript date.\r\n * @return {number} the time zone offset in seconds.\r\n */\n\nfunction timeZoneOffsetInSeconds(standardDate) {\n  var offsetInMinutes = standardDate.getTimezoneOffset();\n\n  if (offsetInMinutes === 0) {\n    return 0;\n  }\n\n  return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\n}\n\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\r\n * Assert that the year value is valid.\r\n * @param {Integer|number} year the value to check.\r\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidYear(year) {\n  return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\n\nexports.assertValidYear = assertValidYear;\n/**\r\n * Assert that the month value is valid.\r\n * @param {Integer|number} month the value to check.\r\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidMonth(month) {\n  return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\n\nexports.assertValidMonth = assertValidMonth;\n/**\r\n * Assert that the day value is valid.\r\n * @param {Integer|number} day the value to check.\r\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidDay(day) {\n  return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\n\nexports.assertValidDay = assertValidDay;\n/**\r\n * Assert that the hour value is valid.\r\n * @param {Integer|number} hour the value to check.\r\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidHour(hour) {\n  return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\n\nexports.assertValidHour = assertValidHour;\n/**\r\n * Assert that the minute value is valid.\r\n * @param {Integer|number} minute the value to check.\r\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidMinute(minute) {\n  return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\n\nexports.assertValidMinute = assertValidMinute;\n/**\r\n * Assert that the second value is valid.\r\n * @param {Integer|number} second the value to check.\r\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidSecond(second) {\n  return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\n\nexports.assertValidSecond = assertValidSecond;\n/**\r\n * Assert that the nanosecond value is valid.\r\n * @param {Integer|number} nanosecond the value to check.\r\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidNanosecond(nanosecond) {\n  return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\n\nexports.assertValidNanosecond = assertValidNanosecond;\n/**\r\n * Check if the given value is of expected type and is in the expected range.\r\n * @param {Integer|number} value the value to check.\r\n * @param {ValueRange} range the range.\r\n * @param {string} name the name of the value.\r\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\r\n */\n\nfunction assertValidTemporalValue(value, range, name) {\n  (0, util_1.assertNumberOrInteger)(value, name);\n\n  if (!range.contains(value)) {\n    throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\n  }\n\n  return value;\n}\n/**\r\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\r\n * @param {Integer|number|string} hour the hour of the local time.\r\n * @param {Integer|number|string} minute the minute of the local time.\r\n * @param {Integer|number|string} second the second of the local time.\r\n * @return {Integer} seconds representing the given local time.\r\n */\n\n\nfunction localTimeToSecondOfDay(hour, minute, second) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n  totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n  return totalSeconds.add(second);\n}\n/**\r\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\r\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\r\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\r\n */\n\n\nfunction isLeapYear(year) {\n  year = (0, integer_1.int)(year);\n\n  if (!year.modulo(4).equals(0)) {\n    return false;\n  } else if (!year.modulo(100).equals(0)) {\n    return true;\n  } else if (!year.modulo(400).equals(0)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n/**\r\n * @param {Integer|number|string} x the divident.\r\n * @param {Integer|number|string} y the divisor.\r\n * @return {Integer} the result.\r\n */\n\n\nfunction floorDiv(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  var result = x.div(y);\n\n  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n    result = result.subtract(1);\n  }\n\n  return result;\n}\n\nexports.floorDiv = floorDiv;\n/**\r\n * @param {Integer|number|string} x the divident.\r\n * @param {Integer|number|string} y the divisor.\r\n * @return {Integer} the result.\r\n */\n\nfunction floorMod(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  return x.subtract(floorDiv(x, y).multiply(y));\n}\n\nexports.floorMod = floorMod;\n/**\r\n * @param {Integer|number|string} seconds the number of seconds to format.\r\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\r\n * @return {string} formatted value.\r\n */\n\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n  seconds = (0, integer_1.int)(seconds);\n  nanoseconds = (0, integer_1.int)(nanoseconds);\n  var secondsString;\n  var nanosecondsString;\n  var secondsNegative = seconds.isNegative();\n  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n\n  if (secondsNegative && nanosecondsGreaterThanZero) {\n    if (seconds.equals(-1)) {\n      secondsString = '-0';\n    } else {\n      secondsString = seconds.add(1).toString();\n    }\n  } else {\n    secondsString = seconds.toString();\n  }\n\n  if (nanosecondsGreaterThanZero) {\n    if (secondsNegative) {\n      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    } else {\n      nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    }\n  }\n\n  return nanosecondsString ? secondsString + nanosecondsString : secondsString;\n}\n/**\r\n * @param {Integer|number|string} value the number of nanoseconds to format.\r\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\r\n */\n\n\nfunction formatNanosecond(value) {\n  value = (0, integer_1.int)(value);\n  return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\r\n * @param {Integer|number|string} num the number to format.\r\n * @param {number} [stringLength=undefined] the string length to left-pad to.\r\n * @return {string} formatted and possibly left-padded number as string.\r\n */\n\n\nfunction formatNumber(num, stringLength) {\n  num = (0, integer_1.int)(num);\n  var isNegative = num.isNegative();\n\n  if (isNegative) {\n    num = num.negate();\n  }\n\n  var numString = num.toString();\n\n  if (stringLength) {\n    // left pad the string with zeroes\n    while (numString.length < stringLength) {\n      numString = '0' + numString;\n    }\n  }\n\n  return isNegative ? '-' + numString : numString;\n}\n\nfunction add(x, y) {\n  if (x instanceof integer_1.default) {\n    return x.add(y);\n  } else if (typeof x === 'bigint') {\n    return x + BigInt(y);\n  }\n\n  return x + y;\n}","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/internal/temporal-util.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","floorMod","floorDiv","assertValidNanosecond","assertValidSecond","assertValidMinute","assertValidHour","assertValidDay","assertValidMonth","assertValidYear","timeZoneOffsetInSeconds","totalNanoseconds","dateToIsoString","timeZoneOffsetToIsoString","timeToIsoString","durationToIsoString","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","normalizeNanosecondsForDuration","normalizeSecondsForDuration","SECONDS_PER_DAY","DAYS_PER_400_YEAR_CYCLE","DAYS_0000_TO_1970","NANOS_PER_HOUR","NANOS_PER_MINUTE","NANOS_PER_MILLISECOND","NANOS_PER_SECOND","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","MINUTES_PER_HOUR","NANOSECOND_OF_SECOND_RANGE","SECOND_OF_MINUTE_RANGE","MINUTE_OF_HOUR_RANGE","HOUR_OF_DAY_RANGE","DAY_OF_MONTH_RANGE","MONTH_OF_YEAR_RANGE","YEAR_RANGE","integer_1","require","error_1","util_1","ValueRange","min","max","_minNumber","_maxNumber","_minInteger","int","_maxInteger","contains","isInt","default","greaterThanOrEqual","lessThanOrEqual","intValue","toString","seconds","nanoseconds","add","hour","minute","second","nanosecond","totalNanos","multiply","year","month","day","epochDay","localTimeSeconds","localTimeToSecondOfDay","div","subtract","greaterThan","isLeapYear","months","days","monthsString","formatNumber","daysString","secondsAndNanosecondsString","formatSecondsAndNanosecondsForDuration","hourString","minuteString","secondString","nanosecondString","formatNanosecond","offsetSeconds","equals","isNegative","signPrefix","hours","minutes","modulo","secondsValue","yearString","monthString","dayString","standardDate","nanosFromMillis","getMilliseconds","offsetInMinutes","getTimezoneOffset","assertValidTemporalValue","range","name","assertNumberOrInteger","newError","totalSeconds","x","y","isPositive","notEquals","secondsString","nanosecondsString","secondsNegative","nanosecondsGreaterThanZero","negate","num","stringLength","numString","length","BigInt"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\r\nvar integer_1 = __importStar(require(\"../integer\"));\r\nvar error_1 = require(\"../error\");\r\nvar util_1 = require(\"./util\");\r\n/*\r\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\r\n\r\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\r\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\r\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\r\n\r\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\r\n  conversion functions.\r\n */\r\nvar ValueRange = /** @class */ (function () {\r\n    function ValueRange(min, max) {\r\n        this._minNumber = min;\r\n        this._maxNumber = max;\r\n        this._minInteger = (0, integer_1.int)(min);\r\n        this._maxInteger = (0, integer_1.int)(max);\r\n    }\r\n    ValueRange.prototype.contains = function (value) {\r\n        if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\r\n            return (value.greaterThanOrEqual(this._minInteger) &&\r\n                value.lessThanOrEqual(this._maxInteger));\r\n        }\r\n        else if (typeof value === 'bigint') {\r\n            var intValue = (0, integer_1.int)(value);\r\n            return (intValue.greaterThanOrEqual(this._minInteger) &&\r\n                intValue.lessThanOrEqual(this._maxInteger));\r\n        }\r\n        else {\r\n            return value >= this._minNumber && value <= this._maxNumber;\r\n        }\r\n    };\r\n    ValueRange.prototype.toString = function () {\r\n        return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\r\n    };\r\n    return ValueRange;\r\n}());\r\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\r\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\r\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\r\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\r\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\r\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\r\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\r\nexports.MINUTES_PER_HOUR = 60;\r\nexports.SECONDS_PER_MINUTE = 60;\r\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\r\nexports.NANOS_PER_SECOND = 1000000000;\r\nexports.NANOS_PER_MILLISECOND = 1000000;\r\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\r\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\r\nexports.DAYS_0000_TO_1970 = 719528;\r\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\r\nexports.SECONDS_PER_DAY = 86400;\r\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\r\n    return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\r\n}\r\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\r\nfunction normalizeNanosecondsForDuration(nanoseconds) {\r\n    return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\r\n}\r\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\r\n/**\r\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\r\n * @param {Integer|number|string} hour the hour of the local time to convert.\r\n * @param {Integer|number|string} minute the minute of the local time to convert.\r\n * @param {Integer|number|string} second the second of the local time to convert.\r\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\r\n * @return {Integer} nanoseconds representing the given local time.\r\n */\r\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\r\n    hour = (0, integer_1.int)(hour);\r\n    minute = (0, integer_1.int)(minute);\r\n    second = (0, integer_1.int)(second);\r\n    nanosecond = (0, integer_1.int)(nanosecond);\r\n    var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\r\n    totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\r\n    totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\r\n    return totalNanos.add(nanosecond);\r\n}\r\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\r\n/**\r\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\r\n * @param {Integer|number|string} year the year of the local date-time to convert.\r\n * @param {Integer|number|string} month the month of the local date-time to convert.\r\n * @param {Integer|number|string} day the day of the local date-time to convert.\r\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\r\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\r\n * @param {Integer|number|string} second the second of the local date-time to convert.\r\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\r\n * @return {Integer} epoch second in UTC representing the given local date time.\r\n */\r\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\r\n    var epochDay = dateToEpochDay(year, month, day);\r\n    var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\r\n    return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\r\n}\r\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\r\n/**\r\n * Converts given local date into a single integer representing it's epoch day.\r\n * @param {Integer|number|string} year the year of the local date to convert.\r\n * @param {Integer|number|string} month the month of the local date to convert.\r\n * @param {Integer|number|string} day the day of the local date to convert.\r\n * @return {Integer} epoch day representing the given date.\r\n */\r\nfunction dateToEpochDay(year, month, day) {\r\n    year = (0, integer_1.int)(year);\r\n    month = (0, integer_1.int)(month);\r\n    day = (0, integer_1.int)(day);\r\n    var epochDay = year.multiply(365);\r\n    if (year.greaterThanOrEqual(0)) {\r\n        epochDay = epochDay.add(year\r\n            .add(3)\r\n            .div(4)\r\n            .subtract(year.add(99).div(100))\r\n            .add(year.add(399).div(400)));\r\n    }\r\n    else {\r\n        epochDay = epochDay.subtract(year\r\n            .div(-4)\r\n            .subtract(year.div(-100))\r\n            .add(year.div(-400)));\r\n    }\r\n    epochDay = epochDay.add(month\r\n        .multiply(367)\r\n        .subtract(362)\r\n        .div(12));\r\n    epochDay = epochDay.add(day.subtract(1));\r\n    if (month.greaterThan(2)) {\r\n        epochDay = epochDay.subtract(1);\r\n        if (!isLeapYear(year)) {\r\n            epochDay = epochDay.subtract(1);\r\n        }\r\n    }\r\n    return epochDay.subtract(exports.DAYS_0000_TO_1970);\r\n}\r\nexports.dateToEpochDay = dateToEpochDay;\r\n/**\r\n * Format given duration to an ISO 8601 string.\r\n * @param {Integer|number|string} months the number of months.\r\n * @param {Integer|number|string} days the number of days.\r\n * @param {Integer|number|string} seconds the number of seconds.\r\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\r\n * @return {string} ISO string that represents given duration.\r\n */\r\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\r\n    var monthsString = formatNumber(months);\r\n    var daysString = formatNumber(days);\r\n    var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\r\n    return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\r\n}\r\nexports.durationToIsoString = durationToIsoString;\r\n/**\r\n * Formats given time to an ISO 8601 string.\r\n * @param {Integer|number|string} hour the hour value.\r\n * @param {Integer|number|string} minute the minute value.\r\n * @param {Integer|number|string} second the second value.\r\n * @param {Integer|number|string} nanosecond the nanosecond value.\r\n * @return {string} ISO string that represents given time.\r\n */\r\nfunction timeToIsoString(hour, minute, second, nanosecond) {\r\n    var hourString = formatNumber(hour, 2);\r\n    var minuteString = formatNumber(minute, 2);\r\n    var secondString = formatNumber(second, 2);\r\n    var nanosecondString = formatNanosecond(nanosecond);\r\n    return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\r\n}\r\nexports.timeToIsoString = timeToIsoString;\r\n/**\r\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\r\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\r\n * @return {string} ISO string that represents given offset.\r\n */\r\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\r\n    offsetSeconds = (0, integer_1.int)(offsetSeconds);\r\n    if (offsetSeconds.equals(0)) {\r\n        return 'Z';\r\n    }\r\n    var isNegative = offsetSeconds.isNegative();\r\n    if (isNegative) {\r\n        offsetSeconds = offsetSeconds.multiply(-1);\r\n    }\r\n    var signPrefix = isNegative ? '-' : '+';\r\n    var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\r\n    var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\r\n    var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\r\n    var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\r\n    return seconds\r\n        ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds\r\n        : \"\" + signPrefix + hours + \":\" + minutes;\r\n}\r\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\r\n/**\r\n * Formats given date to an ISO 8601 string.\r\n * @param {Integer|number|string} year the date year.\r\n * @param {Integer|number|string} month the date month.\r\n * @param {Integer|number|string} day the date day.\r\n * @return {string} ISO string that represents given date.\r\n */\r\nfunction dateToIsoString(year, month, day) {\r\n    year = (0, integer_1.int)(year);\r\n    var isNegative = year.isNegative();\r\n    if (isNegative) {\r\n        year = year.multiply(-1);\r\n    }\r\n    var yearString = formatNumber(year, 4);\r\n    if (isNegative) {\r\n        yearString = '-' + yearString;\r\n    }\r\n    var monthString = formatNumber(month, 2);\r\n    var dayString = formatNumber(day, 2);\r\n    return yearString + \"-\" + monthString + \"-\" + dayString;\r\n}\r\nexports.dateToIsoString = dateToIsoString;\r\n/**\r\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\r\n * @param {global.Date} standardDate the standard JavaScript date.\r\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\r\n * @return {Integer|number|bigint} the total amount of nanoseconds.\r\n */\r\nfunction totalNanoseconds(standardDate, nanoseconds) {\r\n    nanoseconds = nanoseconds || 0;\r\n    var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\r\n    return add(nanoseconds, nanosFromMillis);\r\n}\r\nexports.totalNanoseconds = totalNanoseconds;\r\n/**\r\n * Get the time zone offset in seconds from the given standard JavaScript date.\r\n *\r\n * <b>Implementation note:</b>\r\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\r\n * So positive value means offset is behind UTC and negative value means it is ahead.\r\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\r\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\r\n *\r\n * @param {global.Date} standardDate the standard JavaScript date.\r\n * @return {number} the time zone offset in seconds.\r\n */\r\nfunction timeZoneOffsetInSeconds(standardDate) {\r\n    var offsetInMinutes = standardDate.getTimezoneOffset();\r\n    if (offsetInMinutes === 0) {\r\n        return 0;\r\n    }\r\n    return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\r\n}\r\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\r\n/**\r\n * Assert that the year value is valid.\r\n * @param {Integer|number} year the value to check.\r\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidYear(year) {\r\n    return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\r\n}\r\nexports.assertValidYear = assertValidYear;\r\n/**\r\n * Assert that the month value is valid.\r\n * @param {Integer|number} month the value to check.\r\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidMonth(month) {\r\n    return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\r\n}\r\nexports.assertValidMonth = assertValidMonth;\r\n/**\r\n * Assert that the day value is valid.\r\n * @param {Integer|number} day the value to check.\r\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidDay(day) {\r\n    return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\r\n}\r\nexports.assertValidDay = assertValidDay;\r\n/**\r\n * Assert that the hour value is valid.\r\n * @param {Integer|number} hour the value to check.\r\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidHour(hour) {\r\n    return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\r\n}\r\nexports.assertValidHour = assertValidHour;\r\n/**\r\n * Assert that the minute value is valid.\r\n * @param {Integer|number} minute the value to check.\r\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidMinute(minute) {\r\n    return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\r\n}\r\nexports.assertValidMinute = assertValidMinute;\r\n/**\r\n * Assert that the second value is valid.\r\n * @param {Integer|number} second the value to check.\r\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidSecond(second) {\r\n    return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\r\n}\r\nexports.assertValidSecond = assertValidSecond;\r\n/**\r\n * Assert that the nanosecond value is valid.\r\n * @param {Integer|number} nanosecond the value to check.\r\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidNanosecond(nanosecond) {\r\n    return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\r\n}\r\nexports.assertValidNanosecond = assertValidNanosecond;\r\n/**\r\n * Check if the given value is of expected type and is in the expected range.\r\n * @param {Integer|number} value the value to check.\r\n * @param {ValueRange} range the range.\r\n * @param {string} name the name of the value.\r\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\r\n */\r\nfunction assertValidTemporalValue(value, range, name) {\r\n    (0, util_1.assertNumberOrInteger)(value, name);\r\n    if (!range.contains(value)) {\r\n        throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\r\n * @param {Integer|number|string} hour the hour of the local time.\r\n * @param {Integer|number|string} minute the minute of the local time.\r\n * @param {Integer|number|string} second the second of the local time.\r\n * @return {Integer} seconds representing the given local time.\r\n */\r\nfunction localTimeToSecondOfDay(hour, minute, second) {\r\n    hour = (0, integer_1.int)(hour);\r\n    minute = (0, integer_1.int)(minute);\r\n    second = (0, integer_1.int)(second);\r\n    var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\r\n    totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\r\n    return totalSeconds.add(second);\r\n}\r\n/**\r\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\r\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\r\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\r\n */\r\nfunction isLeapYear(year) {\r\n    year = (0, integer_1.int)(year);\r\n    if (!year.modulo(4).equals(0)) {\r\n        return false;\r\n    }\r\n    else if (!year.modulo(100).equals(0)) {\r\n        return true;\r\n    }\r\n    else if (!year.modulo(400).equals(0)) {\r\n        return false;\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n/**\r\n * @param {Integer|number|string} x the divident.\r\n * @param {Integer|number|string} y the divisor.\r\n * @return {Integer} the result.\r\n */\r\nfunction floorDiv(x, y) {\r\n    x = (0, integer_1.int)(x);\r\n    y = (0, integer_1.int)(y);\r\n    var result = x.div(y);\r\n    if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\r\n        result = result.subtract(1);\r\n    }\r\n    return result;\r\n}\r\nexports.floorDiv = floorDiv;\r\n/**\r\n * @param {Integer|number|string} x the divident.\r\n * @param {Integer|number|string} y the divisor.\r\n * @return {Integer} the result.\r\n */\r\nfunction floorMod(x, y) {\r\n    x = (0, integer_1.int)(x);\r\n    y = (0, integer_1.int)(y);\r\n    return x.subtract(floorDiv(x, y).multiply(y));\r\n}\r\nexports.floorMod = floorMod;\r\n/**\r\n * @param {Integer|number|string} seconds the number of seconds to format.\r\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\r\n * @return {string} formatted value.\r\n */\r\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\r\n    seconds = (0, integer_1.int)(seconds);\r\n    nanoseconds = (0, integer_1.int)(nanoseconds);\r\n    var secondsString;\r\n    var nanosecondsString;\r\n    var secondsNegative = seconds.isNegative();\r\n    var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\r\n    if (secondsNegative && nanosecondsGreaterThanZero) {\r\n        if (seconds.equals(-1)) {\r\n            secondsString = '-0';\r\n        }\r\n        else {\r\n            secondsString = seconds.add(1).toString();\r\n        }\r\n    }\r\n    else {\r\n        secondsString = seconds.toString();\r\n    }\r\n    if (nanosecondsGreaterThanZero) {\r\n        if (secondsNegative) {\r\n            nanosecondsString = formatNanosecond(nanoseconds\r\n                .negate()\r\n                .add(2 * exports.NANOS_PER_SECOND)\r\n                .modulo(exports.NANOS_PER_SECOND));\r\n        }\r\n        else {\r\n            nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\r\n        }\r\n    }\r\n    return nanosecondsString ? secondsString + nanosecondsString : secondsString;\r\n}\r\n/**\r\n * @param {Integer|number|string} value the number of nanoseconds to format.\r\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\r\n */\r\nfunction formatNanosecond(value) {\r\n    value = (0, integer_1.int)(value);\r\n    return value.equals(0) ? '' : '.' + formatNumber(value, 9);\r\n}\r\n/**\r\n * @param {Integer|number|string} num the number to format.\r\n * @param {number} [stringLength=undefined] the string length to left-pad to.\r\n * @return {string} formatted and possibly left-padded number as string.\r\n */\r\nfunction formatNumber(num, stringLength) {\r\n    num = (0, integer_1.int)(num);\r\n    var isNegative = num.isNegative();\r\n    if (isNegative) {\r\n        num = num.negate();\r\n    }\r\n    var numString = num.toString();\r\n    if (stringLength) {\r\n        // left pad the string with zeroes\r\n        while (numString.length < stringLength) {\r\n            numString = '0' + numString;\r\n        }\r\n    }\r\n    return isNegative ? '-' + numString : numString;\r\n}\r\nfunction add(x, y) {\r\n    if (x instanceof integer_1.default) {\r\n        return x.add(y);\r\n    }\r\n    else if (typeof x === 'bigint') {\r\n        return x + BigInt(y);\r\n    }\r\n    return x + y;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}