{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\nexport function audit(durationSelector) {\n  return function auditOperatorFunction(source) {\n    return source.lift(new AuditOperator(durationSelector));\n  };\n}\n\nvar AuditOperator = /*@__PURE__*/function () {\n  function AuditOperator(durationSelector) {\n    this.durationSelector = durationSelector;\n  }\n\n  AuditOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n  };\n\n  return AuditOperator;\n}();\n\nvar AuditSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(AuditSubscriber, _super);\n\n  function AuditSubscriber(destination, durationSelector) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.durationSelector = durationSelector;\n    _this.hasValue = false;\n    return _this;\n  }\n\n  AuditSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n\n    if (!this.throttled) {\n      var duration = void 0;\n\n      try {\n        var durationSelector = this.durationSelector;\n        duration = durationSelector(value);\n      } catch (err) {\n        return this.destination.error(err);\n      }\n\n      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\n\n      if (!innerSubscription || innerSubscription.closed) {\n        this.clearThrottle();\n      } else {\n        this.add(this.throttled = innerSubscription);\n      }\n    }\n  };\n\n  AuditSubscriber.prototype.clearThrottle = function () {\n    var _a = this,\n        value = _a.value,\n        hasValue = _a.hasValue,\n        throttled = _a.throttled;\n\n    if (throttled) {\n      this.remove(throttled);\n      this.throttled = undefined;\n      throttled.unsubscribe();\n    }\n\n    if (hasValue) {\n      this.value = undefined;\n      this.hasValue = false;\n      this.destination.next(value);\n    }\n  };\n\n  AuditSubscriber.prototype.notifyNext = function () {\n    this.clearThrottle();\n  };\n\n  AuditSubscriber.prototype.notifyComplete = function () {\n    this.clearThrottle();\n  };\n\n  return AuditSubscriber;\n}(SimpleOuterSubscriber);","map":{"version":3,"mappings":";AAKA,OAAO,KAAEA,OAAT,MAAS,OAAT;AAgDA,SAAMC,qBAAN,EAAyBC,cAAzB,EAAmFC,qBAAnF,QAAmF,mBAAnF;OACE,SAAOC,KAAP,CAAgBC,gBAAhB,EAAgB;SACd,SAAOC,qBAAP,CAAuBC,MAAvB,EAAqC;AACrC;AACH;AAED;;IACEC,6BAAoB,YAA0D;WAA1DA;AACnB;AAED;;eACS,WAAOC,OAAU,UAAIC,UAAJ,EAA0BH,MAA1B,EAAsC;AAC/D;AACH;;AAPA,SAOCC,aAPD;AAcA,CAbsB;;IAacG,yCAA2BC,MAA3B,EAA2B;AAM7DZ,qCAAYY,MAAZ;;WAAAD,gBAEEE,aAAMR,kBACP;AAFmB,4BAAgB,IAAhB,kBAA0D,IAA1D;;AAJZS,6BAA0BT,gBAA1B;;AAMP;AAES;;iBACE,WAASU;AACnB,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,QAAL,GAAU,IAAV;;QACE,MAAIC,WAAQ;AACZ,UAAIC,iBAAJ;;UACU;AACR,4BAAW,QAAiBd,gBAA5B;AACDc;AAAC,eACAC,KAAO;AACR;AACD;;AACA,UAAIC,iBAAC,GAAiBnB,cAAI,WAAkB,IAAQC,qBAAR,CAAQ,IAAR,CAAlB,CAA1B;;UACE,sBAAqBkB;AACtB;aACC;AACD;AACF;AACF;AAED;;iBACQ,WAAEC,gBAAO;AACf,QAAIC,SAAJ;AAAA,QAAeP,gBAAf;AAAA,QAAeC,sBAAf;AAAA,QAAeC,wBAAf;;QACEA,WAAW;AACX,WAAKM,MAAL,CAAKN,SAAL;AACA,uBAAUO,SAAV;AACDP;AACD;;QACED,UAAU;AACV,WAAKD,KAAL,GAAaS,SAAb;AACA,WAAKR,QAAL,GAAgB,KAAhB;AACD;AACF;AAED;;iBACO,WAAgBS;AACtB;AAED;;iBACO,WAAgBC;AACtB;AACH;;AApDoC;CAAA","names":["tslib_1","SimpleOuterSubscriber","innerSubscribe","SimpleInnerSubscriber","audit","durationSelector","auditOperatorFunction","source","AuditOperator","call","subscriber","AuditSubscriber","_super","destination","_this","_next","value","hasValue","throttled","duration","err","innerSubscription","clearThrottle","_a","remove","undefined","notifyNext","notifyComplete"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\audit.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SubscribableOrPromise, TeardownLogic } from '../types';\r\nimport { SimpleOuterSubscriber, innerSubscribe, SimpleInnerSubscriber } from '../innerSubscribe';\r\n\r\n/**\r\n * Ignores source values for a duration determined by another Observable, then\r\n * emits the most recent value from the source Observable, then repeats this\r\n * process.\r\n *\r\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\r\n * duration is determined by a second Observable.</span>\r\n *\r\n * ![](audit.png)\r\n *\r\n * `audit` is similar to `throttle`, but emits the last value from the silenced\r\n * time window, instead of the first value. `audit` emits the most recent value\r\n * from the source Observable on the output Observable as soon as its internal\r\n * timer becomes disabled, and ignores source values while the timer is enabled.\r\n * Initially, the timer is disabled. As soon as the first source value arrives,\r\n * the timer is enabled by calling the `durationSelector` function with the\r\n * source value, which returns the \"duration\" Observable. When the duration\r\n * Observable emits a value or completes, the timer is disabled, then the most\r\n * recent source value is emitted on the output Observable, and this process\r\n * repeats for the next source value.\r\n *\r\n * ## Example\r\n *\r\n * Emit clicks at a rate of at most one click per second\r\n * ```ts\r\n * import { fromEvent, interval } from 'rxjs';\r\n * import { audit } from 'rxjs/operators'\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(audit(ev => interval(1000)));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delayWhen}\r\n * @see {@link sample}\r\n * @see {@link throttle}\r\n *\r\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\r\n * that receives a value from the source Observable, for computing the silencing\r\n * duration, returned as an Observable or a Promise.\r\n * @return {Observable<T>} An Observable that performs rate-limiting of\r\n * emissions from the source Observable.\r\n * @method audit\r\n * @owner Observable\r\n */\r\nexport function audit<T>(durationSelector: (value: T) => SubscribableOrPromise<any>): MonoTypeOperatorFunction<T> {\r\n  return function auditOperatorFunction(source: Observable<T>) {\r\n    return source.lift(new AuditOperator(durationSelector));\r\n  };\r\n}\r\n\r\nclass AuditOperator<T> implements Operator<T, T> {\r\n  constructor(private durationSelector: (value: T) => SubscribableOrPromise<any>) {\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new AuditSubscriber<T, T>(subscriber, this.durationSelector));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass AuditSubscriber<T, R> extends SimpleOuterSubscriber<T, R> {\r\n\r\n  private value?: T;\r\n  private hasValue: boolean = false;\r\n  private throttled?: Subscription;\r\n\r\n  constructor(destination: Subscriber<T>,\r\n              private durationSelector: (value: T) => SubscribableOrPromise<any>) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    this.value = value;\r\n    this.hasValue = true;\r\n    if (!this.throttled) {\r\n      let duration;\r\n      try {\r\n        const { durationSelector } = this;\r\n        duration = durationSelector(value);\r\n      } catch (err) {\r\n        return this.destination.error!(err);\r\n      }\r\n      const innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));\r\n      if (!innerSubscription || innerSubscription.closed) {\r\n        this.clearThrottle();\r\n      } else {\r\n        this.add(this.throttled = innerSubscription);\r\n      }\r\n    }\r\n  }\r\n\r\n  clearThrottle() {\r\n    const { value, hasValue, throttled } = this;\r\n    if (throttled) {\r\n      this.remove(throttled);\r\n      this.throttled = undefined;\r\n      throttled.unsubscribe();\r\n    }\r\n    if (hasValue) {\r\n      this.value = undefined;\r\n      this.hasValue = false;\r\n      this.destination.next!(value);\r\n    }\r\n  }\r\n\r\n  notifyNext(): void {\r\n    this.clearThrottle();\r\n  }\r\n\r\n  notifyComplete(): void {\r\n    this.clearThrottle();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}