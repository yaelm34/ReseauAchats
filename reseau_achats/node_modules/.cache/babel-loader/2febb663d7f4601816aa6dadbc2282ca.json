{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nexport function takeLast(count) {\n  return function takeLastOperatorFunction(source) {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeLastOperator(count));\n    }\n  };\n}\n\nvar TakeLastOperator = /*@__PURE__*/function () {\n  function TakeLastOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeLastOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n  };\n\n  return TakeLastOperator;\n}();\n\nvar TakeLastSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(TakeLastSubscriber, _super);\n\n  function TakeLastSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.ring = new Array();\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeLastSubscriber.prototype._next = function (value) {\n    var ring = this.ring;\n    var total = this.total;\n    var count = this.count++;\n\n    if (ring.length < total) {\n      ring.push(value);\n    } else {\n      var index = count % total;\n      ring[index] = value;\n    }\n  };\n\n  TakeLastSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n    var count = this.count;\n\n    if (count > 0) {\n      var total = this.count >= this.total ? this.total : this.count;\n      var ring = this.ring;\n\n      for (var i = 0; i < total; i++) {\n        var idx = count++ % total;\n        destination.next(ring[idx]);\n      }\n    }\n\n    destination.complete();\n  };\n\n  return TakeLastSubscriber;\n}(Subscriber);","map":{"version":3,"mappings":";AACA,OAAO,KAAEA,OAAT,MAAqB,OAArB;AACA,SAASC,UAAT,QAAS,eAAT;AACA,SAASC,uBAAT,QAAsB,iCAAtB;AA8CA,SAAMC,KAAN,QAAgB,qBAAhB;OACE,SAAOC,QAAP,CAAgBC,KAAhB,EAAgB;SACd,SAASC,wBAAT,CAAiBC,MAAjB,EAAiB;QACfF,UAAO,GAAK;AACb;WACC;AACD;AACD;AACH;AAED;;IACEG,gCAAiC;WAAbA,iBAAaC;AAC/B,SAAIA,KAAJ,GAASA,KAAT;;QACE,aAAU;AACX;AACF;AAED;;kBACS,CAAMC,UAAUC,OAAK,sBAAmBJ,MAAnB,EAA+B;AAC5D;AACH;;AAVA,SAUCC,gBAVD;AAiBA,CAhBmC;;IAgBCI,4CAAaC,MAAb,EAAa;AAI/Cb,wCAAYa,MAAZ;;WAAAD,mBACEE,aAAML,OAAY;AAD4B,gBAAKI,MAAL,CAAKF,KAAQ,IAAR,EAAQG,WAAR,KAAQ,IAAb;;AAHxCC,kBAAiBN,KAAjB;AACAM,iBAAK,IAAaC,KAAb,EAAL;;AAIP;AAES;;oBACK,CAAIN,UAAMO;AACvB,QAAMC,OAAK,KAAOA,IAAlB;AACA,QAAMT,KAAK,GAAG,KAAKA,KAAnB;AAEA,QAAIJ,KAAK,QAAMA,KAAN,EAAT;;QACEa,IAAI,CAACC,MAAL,GAAUV,OAAO;AAClBS;WACC;AACA,UAAIE,KAAC,GAAMf,KAAG,GAAMI,KAApB;AACDS;AACF;AAES;;oBACF,CAAWR,UAAQW,YAAY;AACrC,QAAIP,WAAQ,GAAK,KAAMA,WAAvB;AAEA,QAAIT,KAAK,GAAG,KAAGA,KAAf;;QACEA,KAAM,MAAK;AACX,UAAMI,KAAI,GAAI,KAAKJ,KAAL,IAAU,UAAV,GAAU,UAAV,GAAU,UAAxB;AAEA,cAAK,GAAK,KAAMa,IAAhB;;WACE,IAAMI,IAAG,GAAIA,IAAKb,OAAMa,KAAM;AAC9B,kBAAWjB,KAAK,EAAhB,GAAsBI,KAAtB;AACDK;AACF;AAED;;AACDA;AACH;;AArCoC;CAAA","names":["tslib_1","Subscriber","ArgumentOutOfRangeError","empty","takeLast","count","takeLastOperatorFunction","source","TakeLastOperator","total","prototype","call","TakeLastSubscriber","_super","destination","_this","Array","_next","ring","length","index","_complete","i"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\takeLast.ts"],"sourcesContent":["import { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\r\nimport { empty } from '../observable/empty';\r\nimport { Observable } from '../Observable';\r\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\r\n\r\n/**\r\n * Emits only the last `count` values emitted by the source Observable.\r\n *\r\n * <span class=\"informal\">Remembers the latest `count` values, then emits those\r\n * only when the source completes.</span>\r\n *\r\n * ![](takeLast.png)\r\n *\r\n * `takeLast` returns an Observable that emits at most the last `count` values\r\n * emitted by the source Observable. If the source emits fewer than `count`\r\n * values then all of its values are emitted. This operator must wait until the\r\n * `complete` notification emission from the source in order to emit the `next`\r\n * values on the output Observable, because otherwise it is impossible to know\r\n * whether or not more values will be emitted on the source. For this reason,\r\n * all values are emitted synchronously, followed by the complete notification.\r\n *\r\n * ## Example\r\n * Take the last 3 values of an Observable with many values\r\n * ```ts\r\n * import { range } from 'rxjs';\r\n * import { takeLast } from 'rxjs/operators';\r\n *\r\n * const many = range(1, 100);\r\n * const lastThree = many.pipe(takeLast(3));\r\n * lastThree.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link take}\r\n * @see {@link takeUntil}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\r\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\r\n *\r\n * @param {number} count The maximum number of values to emit from the end of\r\n * the sequence of values emitted by the source Observable.\r\n * @return {Observable<T>} An Observable that emits at most the last count\r\n * values emitted by the source Observable.\r\n * @method takeLast\r\n * @owner Observable\r\n */\r\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return function takeLastOperatorFunction(source: Observable<T>): Observable<T> {\r\n    if (count === 0) {\r\n      return empty();\r\n    } else {\r\n      return source.lift(new TakeLastOperator(count));\r\n    }\r\n  };\r\n}\r\n\r\nclass TakeLastOperator<T> implements Operator<T, T> {\r\n  constructor(private total: number) {\r\n    if (this.total < 0) {\r\n      throw new ArgumentOutOfRangeError;\r\n    }\r\n  }\r\n\r\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\r\n    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\r\n  }\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nclass TakeLastSubscriber<T> extends Subscriber<T> {\r\n  private ring: Array<T> = new Array();\r\n  private count: number = 0;\r\n\r\n  constructor(destination: Subscriber<T>, private total: number) {\r\n    super(destination);\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    const ring = this.ring;\r\n    const total = this.total;\r\n    const count = this.count++;\r\n\r\n    if (ring.length < total) {\r\n      ring.push(value);\r\n    } else {\r\n      const index = count % total;\r\n      ring[index] = value;\r\n    }\r\n  }\r\n\r\n  protected _complete(): void {\r\n    const destination = this.destination;\r\n    let count = this.count;\r\n\r\n    if (count > 0) {\r\n      const total = this.count >= this.total ? this.total : this.count;\r\n      const ring  = this.ring;\r\n\r\n      for (let i = 0; i < total; i++) {\r\n        const idx = (count++) % total;\r\n        destination.next(ring[idx]);\r\n      }\r\n    }\r\n\r\n    destination.complete();\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}