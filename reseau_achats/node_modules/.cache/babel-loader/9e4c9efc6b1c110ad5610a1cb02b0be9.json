{"ast":null,"code":"/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n  var resultSelector;\n  var initialState;\n\n  if (arguments.length == 1) {\n    var options = initialStateOrOptions;\n    initialState = options.initialState;\n    condition = options.condition;\n    iterate = options.iterate;\n    resultSelector = options.resultSelector || identity;\n    scheduler = options.scheduler;\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n    initialState = initialStateOrOptions;\n    resultSelector = identity;\n    scheduler = resultSelectorOrObservable;\n  } else {\n    initialState = initialStateOrOptions;\n    resultSelector = resultSelectorOrObservable;\n  }\n\n  return new Observable(function (subscriber) {\n    var state = initialState;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        subscriber: subscriber,\n        iterate: iterate,\n        condition: condition,\n        resultSelector: resultSelector,\n        state: state\n      });\n    }\n\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return undefined;\n        }\n\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n\n      var value = void 0;\n\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n\n      subscriber.next(value);\n\n      if (subscriber.closed) {\n        break;\n      }\n\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return undefined;\n      }\n    } while (true);\n\n    return undefined;\n  });\n}\n\nfunction dispatch(state) {\n  var subscriber = state.subscriber,\n      condition = state.condition;\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  if (state.needIterate) {\n    try {\n      state.state = state.iterate(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n  } else {\n    state.needIterate = true;\n  }\n\n  if (condition) {\n    var conditionResult = void 0;\n\n    try {\n      conditionResult = condition(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return undefined;\n    }\n\n    if (!conditionResult) {\n      subscriber.complete();\n      return undefined;\n    }\n\n    if (subscriber.closed) {\n      return undefined;\n    }\n  }\n\n  var value;\n\n  try {\n    value = state.resultSelector(state.state);\n  } catch (err) {\n    subscriber.error(err);\n    return undefined;\n  }\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  subscriber.next(value);\n\n  if (subscriber.closed) {\n    return undefined;\n  }\n\n  return this.schedule(state);\n}","map":{"version":3,"mappings":"AAAA;AAEA,SAASA,UAAT,QAAyB,eAAzB;AAEA,SAASC,QAAT,QAAsB,kBAAtB;AA8PA,SAAMC,WAAN,QAA+B,qBAA/B;OAME,SAAIC,QAAJ,CAAqCC,qBAArC,EAAqCC,SAArC,EAAqCC,OAArC,EAAqCC,0BAArC,EAAqCC,SAArC,EAAqC;AACrC,MAAIC,cAAJ;AAEA,MAAIC,YAAJ;;MACEC,SAAM,OAAN,IAAgB;AAChB,kBAAYP,qBAAZ;AACAM,gBAAY,UAAQ,aAApB;AACAL,aAAO,GAAGO,OAAQ,UAAlB;AACAN,qBAAiB,QAAjB;AACAG,kBAAY,UAAQ,eAAR,IAAkBR,QAA9B;AACDO;SACC,8BAAe,KAA0BK,SAAzC,IAA0CX,uCAA1C,EAA0C;AAC1CQ,mBAAcN,qBAAd;AACAK,kBAAY,WAAZ;AACDD;GAHC,MAIA;AACAE,mBAAcN,qBAAd;AACDK;AAED;;SACE,IAAIT,UAAJ,CAAY,UAAac,UAAb,EAAa;AACzB,QAAIC,oBAAJ;;QACEP,WAAO;aACLA,SAAU,SAAV,CAAUQ,QAAV,EAAU,CAAV,EAAU;AACVF,kBAAO,YADG;AAEVR,iBAASA,OAFC;AAGVD,4BAHU;AAIVI,sBAAK,gBAJK;AAKTM;AALS,OAAV;AAQJ;;;UAEIV,WAAI;AACJ,YAAIY,wBAAJ;;YACE;AACDA;AAAC,iBACAC;AACAJ,oBAAO,MAAP,CAAiBI,GAAjB;AACD;AACD;;YACE,kBAAW;AACXJ,oBAAM,SAAN;AACD;AACF;AACD;;AACA,UAAIK,cAAJ;;UACE;AACDA;AAAC,eACAD;AACAJ,kBAAO,MAAP,CAAiBI,GAAjB;AACD;AACD;;AACAJ,gBAAI,KAAJ,CAAeK,KAAf;;UACEL,UAAM;AACP;AACD;;UACE;AACDC;AAAC,eACAG;AACAJ,kBAAO,MAAP,CAAiBI,GAAjB;AACD;AACF;AAED,aAAO;;AACN;AACJ,GA9CG;AAgDJ;;SACUF;AACR,MAAIF,UAAU,GAACC,KAAM,CAAED,UAAvB;AAAA,MAAuBT,2BAAvB;;MACES,UAAO,SAAU;AAClB;AACD;;MACEC,KAAI;QACF;AACDA;AAAC,aACAG;AACAJ,gBAAO,MAAP,CAAiBI,GAAjB;AACD;AACF;SACC;AACDH;AACD;;MACEV,WAAI;AACJ,QAAIY,wBAAJ;;QACE;AACDA;AAAC,aACAC;AACAJ,gBAAO,MAAP,CAAiBI,GAAjB;AACD;AACD;;QACE,kBAAW;AACXJ,gBAAO,SAAP;AACD;AACD;;QACEA,UAAO,SAAU;AAClB;AACF;AACD;;AACA,MAAIK,KAAJ;;MACE;AACDA;AAAC,WACAD;AACAJ,cAAO,MAAP,CAAiBI,GAAjB;AACD;AACD;;MACEJ,UAAO,SAAU;AAClB;AACD;;AACAA,YAAI,KAAJ,CAAeK,KAAf;;MACEL,UAAO,SAAU;AAClB;AACD;;AACD","names":["Observable","identity","isScheduler","generate","initialStateOrOptions","condition","iterate","resultSelectorOrObservable","scheduler","resultSelector","initialState","arguments","options","undefined","subscriber","state","dispatch","conditionResult","err","value"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\generate.ts"],"sourcesContent":["import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { identity } from '../util/identity';\r\nimport { SchedulerAction, SchedulerLike } from '../types';\r\nimport { isScheduler } from '../util/isScheduler';\r\n\r\nexport type ConditionFunc<S> = (state: S) => boolean;\r\nexport type IterateFunc<S> = (state: S) => S;\r\nexport type ResultFunc<S, T> = (state: S) => T;\r\n\r\ninterface SchedulerState<T, S> {\r\n  needIterate?: boolean;\r\n  state: S;\r\n  subscriber: Subscriber<T>;\r\n  condition?: ConditionFunc<S>;\r\n  iterate: IterateFunc<S>;\r\n  resultSelector: ResultFunc<S, T>;\r\n}\r\n\r\nexport interface GenerateBaseOptions<S> {\r\n  /**\r\n   * Initial state.\r\n   */\r\n  initialState: S;\r\n  /**\r\n   * Condition function that accepts state and returns boolean.\r\n   * When it returns false, the generator stops.\r\n   * If not specified, a generator never stops.\r\n   */\r\n  condition?: ConditionFunc<S>;\r\n  /**\r\n   * Iterate function that accepts state and returns new state.\r\n   */\r\n  iterate: IterateFunc<S>;\r\n  /**\r\n   * SchedulerLike to use for generation process.\r\n   * By default, a generator starts immediately.\r\n   */\r\n  scheduler?: SchedulerLike;\r\n}\r\n\r\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\r\n  /**\r\n   * Result selection function that accepts state and returns a value to emit.\r\n   */\r\n  resultSelector: ResultFunc<S, T>;\r\n}\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n *\r\n * ![](generate.png)\r\n *\r\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\r\n * const res = generate(0, x => x < 10, x => x + 1, x => x);\r\n *\r\n * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\r\n * const res = generate(1, x => x < 5, x => x * 2, x => x + 1, asap);\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {S} initialState Initial state.\r\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\r\n * @param {function (state: S): S} iterate Iteration step function.\r\n * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence. (deprecated)\r\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} on which to run the generator loop. If not provided, defaults to emit immediately.\r\n * @returns {Observable<T>} The generated sequence.\r\n */\r\n  export function generate<T, S>(initialState: S,\r\n                                 condition: ConditionFunc<S>,\r\n                                 iterate: IterateFunc<S>,\r\n                                 resultSelector: ResultFunc<S, T>,\r\n                                 scheduler?: SchedulerLike): Observable<T>;\r\n\r\n/**\r\n * Generates an Observable by running a state-driven loop\r\n * that emits an element on each iteration.\r\n *\r\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\r\n *\r\n * <img src=\"./img/generate.png\" width=\"100%\">\r\n *\r\n * `generate` allows you to create stream of values generated with a loop very similar to\r\n * traditional for loop. First argument of `generate` is a beginning value. Second argument\r\n * is a function that accepts this value and tests if some condition still holds. If it does,\r\n * loop continues, if not, it stops. Third value is a function which takes previously defined\r\n * value and modifies it in some way on each iteration. Note how these three parameters\r\n * are direct equivalents of three expressions in regular for loop: first expression\r\n * initializes some state (for example numeric index), second tests if loop can make next\r\n * iteration (for example if index is lower than 10) and third states how defined value\r\n * will be modified on every step (index will be incremented by one).\r\n *\r\n * Return value of a `generate` operator is an Observable that on each loop iteration\r\n * emits a value. First, condition function is ran. If it returned true, Observable\r\n * emits currently stored value (initial value at the first iteration) and then updates\r\n * that value with iterate function. If at some point condition returned false, Observable\r\n * completes at that moment.\r\n *\r\n * Optionally you can pass fourth parameter to `generate` - a result selector function which allows you\r\n * to immediately map value that would normally be emitted by an Observable.\r\n *\r\n * If you find three anonymous functions in `generate` call hard to read, you can provide\r\n * single object to the operator instead. That object has properties: `initialState`,\r\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\r\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\r\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\r\n * condition always holds, so output Observable will never complete.\r\n *\r\n * Both forms of `generate` can optionally accept a scheduler. In case of multi-parameter call,\r\n * scheduler simply comes as a last argument (no matter if there is resultSelector\r\n * function or not). In case of single-parameter call, you can provide it as a\r\n * `scheduler` property on object passed to the operator. In both cases scheduler decides when\r\n * next iteration of the loop will happen and therefore when next value will be emitted\r\n * by the Observable. For example to ensure that each value is pushed to the observer\r\n * on separate task in event loop, you could use `async` scheduler. Note that\r\n * by default (when no scheduler is passed) values are simply emitted synchronously.\r\n *\r\n *\r\n * @example <caption>Use with condition and iterate functions.</caption>\r\n * const generated = generate(0, x => x < 3, x => x + 1);\r\n *\r\n * generated.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('Yo!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // \"Yo!\"\r\n *\r\n *\r\n * @example <caption>Use with condition, iterate and resultSelector functions.</caption>\r\n * const generated = generate(0, x => x < 3, x => x + 1, x => x * 1000);\r\n *\r\n * generated.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('Yo!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // \"Yo!\"\r\n *\r\n *\r\n * @example <caption>Use with options object.</caption>\r\n * const generated = generate({\r\n *   initialState: 0,\r\n *   condition(value) { return value < 3; },\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * generated.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('Yo!')\r\n * );\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // \"Yo!\"\r\n *\r\n * @example <caption>Use options object without condition function.</caption>\r\n * const generated = generate({\r\n *   initialState: 0,\r\n *   iterate(value) { return value + 1; },\r\n *   resultSelector(value) { return value * 1000; }\r\n * });\r\n *\r\n * generated.subscribe(\r\n *   value => console.log(value),\r\n *   err => {},\r\n *   () => console.log('Yo!') // This will never run.\r\n * );\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1000\r\n * // 2000\r\n * // 3000\r\n * // ...and never stops.\r\n *\r\n *\r\n * @see {@link from}\r\n * @see {@link index/Observable.create}\r\n *\r\n * @param {S} initialState Initial state.\r\n * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\r\n * @param {function (state: S): S} iterate Iteration step function.\r\n * @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence.\r\n * @param {Scheduler} [scheduler] A {@link Scheduler} on which to run the generator loop. If not provided, defaults to emitting immediately.\r\n * @return {Observable<T>} The generated sequence.\r\n */\r\nexport function generate<S>(initialState: S,\r\n                            condition: ConditionFunc<S>,\r\n                            iterate: IterateFunc<S>,\r\n                            scheduler?: SchedulerLike): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\r\n * const res = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 10,\r\n *   iterate: x => x + 1,\r\n * });\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\r\n * @returns {Observable<S>} The generated sequence.\r\n */\r\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\r\n\r\n/**\r\n * Generates an observable sequence by running a state-driven loop\r\n * producing the sequence's elements, using the specified scheduler\r\n * to send out observer messages.\r\n * The overload accepts options object that might contain initial state, iterate,\r\n * condition, result selector and scheduler.\r\n *\r\n * ![](generate.png)\r\n *\r\n * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\r\n * const res = generate({\r\n *   initialState: 0,\r\n *   condition: x => x < 10,\r\n *   iterate: x => x + 1,\r\n *   resultSelector: x => x,\r\n * });\r\n *\r\n * @see {@link from}\r\n * @see {@link Observable}\r\n *\r\n * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\r\n * @returns {Observable<T>} The generated sequence.\r\n */\r\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\r\n\r\nexport function generate<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>,\r\n                               condition?: ConditionFunc<S>,\r\n                               iterate?: IterateFunc<S>,\r\n                               resultSelectorOrObservable?: (ResultFunc<S, T>) | SchedulerLike,\r\n                               scheduler?: SchedulerLike): Observable<T> {\r\n\r\n  let resultSelector: ResultFunc<S, T>;\r\n  let initialState: S;\r\n\r\n  if (arguments.length == 1) {\r\n    const options = initialStateOrOptions as GenerateOptions<T, S>;\r\n    initialState = options.initialState;\r\n    condition = options.condition;\r\n    iterate = options.iterate;\r\n    resultSelector = options.resultSelector || identity as ResultFunc<S, T>;\r\n    scheduler = options.scheduler;\r\n  } else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\r\n    initialState = initialStateOrOptions as S;\r\n    resultSelector = identity as ResultFunc<S, T>;\r\n    scheduler = resultSelectorOrObservable as SchedulerLike;\r\n  } else {\r\n    initialState = initialStateOrOptions as S;\r\n    resultSelector = resultSelectorOrObservable as ResultFunc<S, T>;\r\n  }\r\n\r\n  return new Observable<T>(subscriber => {\r\n    let state = initialState;\r\n    if (scheduler) {\r\n      return scheduler.schedule<SchedulerState<T, S>>(dispatch, 0, {\r\n        subscriber,\r\n        iterate,\r\n        condition,\r\n        resultSelector,\r\n        state\r\n      });\r\n    }\r\n\r\n    do {\r\n      if (condition) {\r\n        let conditionResult: boolean;\r\n        try {\r\n          conditionResult = condition(state);\r\n        } catch (err) {\r\n          subscriber.error(err);\r\n          return undefined;\r\n        }\r\n        if (!conditionResult) {\r\n          subscriber.complete();\r\n          break;\r\n        }\r\n      }\r\n      let value: T;\r\n      try {\r\n        value = resultSelector(state);\r\n      } catch (err) {\r\n        subscriber.error(err);\r\n        return undefined;\r\n      }\r\n      subscriber.next(value);\r\n      if (subscriber.closed) {\r\n        break;\r\n      }\r\n      try {\r\n        state = iterate(state);\r\n      } catch (err) {\r\n        subscriber.error(err);\r\n        return undefined;\r\n      }\r\n    } while (true);\r\n\r\n    return undefined;\r\n  });\r\n}\r\n\r\nfunction dispatch<T, S>(this: SchedulerAction<SchedulerState<T, S>>, state: SchedulerState<T, S>) {\r\n  const { subscriber, condition } = state;\r\n  if (subscriber.closed) {\r\n    return undefined;\r\n  }\r\n  if (state.needIterate) {\r\n    try {\r\n      state.state = state.iterate(state.state);\r\n    } catch (err) {\r\n      subscriber.error(err);\r\n      return undefined;\r\n    }\r\n  } else {\r\n    state.needIterate = true;\r\n  }\r\n  if (condition) {\r\n    let conditionResult: boolean;\r\n    try {\r\n      conditionResult = condition(state.state);\r\n    } catch (err) {\r\n      subscriber.error(err);\r\n      return undefined;\r\n    }\r\n    if (!conditionResult) {\r\n      subscriber.complete();\r\n      return undefined;\r\n    }\r\n    if (subscriber.closed) {\r\n      return undefined;\r\n    }\r\n  }\r\n  let value: T;\r\n  try {\r\n    value = state.resultSelector(state.state);\r\n  } catch (err) {\r\n    subscriber.error(err);\r\n    return undefined;\r\n  }\r\n  if (subscriber.closed) {\r\n    return undefined;\r\n  }\r\n  subscriber.next(value);\r\n  if (subscriber.closed) {\r\n    return undefined;\r\n  }\r\n  return this.schedule(state);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}