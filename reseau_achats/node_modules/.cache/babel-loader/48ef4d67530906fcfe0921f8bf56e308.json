{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar channel_1 = require(\"../channel\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar BOLT_MAGIC_PREAMBLE = 0x6060b017;\n\nfunction version(major, minor) {\n  return {\n    major: major,\n    minor: minor\n  };\n}\n\nfunction createHandshakeMessage(versions) {\n  if (versions.length > 4) {\n    throw (0, neo4j_driver_core_1.newError)('It should not have more than 4 versions of the protocol');\n  }\n\n  var handshakeBuffer = (0, channel_1.alloc)(5 * 4);\n  handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE);\n  versions.forEach(function (version) {\n    if (version instanceof Array) {\n      var _a = version[0],\n          major = _a.major,\n          minor = _a.minor;\n      var minMinor = version[1].minor;\n      var range = minor - minMinor;\n      handshakeBuffer.writeInt32(range << 16 | minor << 8 | major);\n    } else {\n      var major = version.major,\n          minor = version.minor;\n      handshakeBuffer.writeInt32(minor << 8 | major);\n    }\n  });\n  handshakeBuffer.reset();\n  return handshakeBuffer;\n}\n\nfunction parseNegotiatedResponse(buffer) {\n  var h = [buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8()];\n\n  if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {\n    throw (0, neo4j_driver_core_1.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' + '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');\n  }\n\n  return Number(h[3] + '.' + h[2]);\n}\n/**\r\n * @return {BaseBuffer}\r\n * @private\r\n */\n\n\nfunction newHandshakeBuffer() {\n  return createHandshakeMessage([[version(4, 4), version(4, 2)], version(4, 1), version(4, 0), version(3, 0)]);\n}\n/**\r\n * This callback is displayed as a global member.\r\n * @callback BufferConsumerCallback\r\n * @param {buffer} buffer the remaining buffer\r\n */\n\n/**\r\n * @typedef HandshakeResult\r\n * @property {number} protocolVersion The protocol version negotiated in the handshake\r\n * @property {function(BufferConsumerCallback)} consumeRemainingBuffer A function to consume the remaining buffer if it exists\r\n */\n\n/**\r\n * Shake hands using the channel and return the protocol version\r\n *\r\n * @param {Channel} channel the channel use to shake hands\r\n * @returns {Promise<HandshakeResult>} Promise of protocol version and consumeRemainingBuffer\r\n */\n\n\nfunction handshake(channel) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    var handshakeErrorHandler = function (error) {\n      reject(error);\n    };\n\n    channel.onerror = handshakeErrorHandler.bind(_this);\n\n    if (channel._error) {\n      handshakeErrorHandler(channel._error);\n    }\n\n    channel.onmessage = function (buffer) {\n      try {\n        // read the response buffer and initialize the protocol\n        var protocolVersion = parseNegotiatedResponse(buffer);\n        resolve({\n          protocolVersion: protocolVersion,\n          consumeRemainingBuffer: function (consumer) {\n            if (buffer.hasRemaining()) {\n              consumer(buffer.readSlice(buffer.remaining()));\n            }\n          }\n        });\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    channel.write(newHandshakeBuffer());\n  });\n}\n\nexports.default = handshake;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-bolt-connection/lib/bolt/handshake.js"],"names":["Object","defineProperty","exports","value","channel_1","require","neo4j_driver_core_1","BOLT_MAGIC_PREAMBLE","version","major","minor","createHandshakeMessage","versions","length","newError","handshakeBuffer","alloc","writeInt32","forEach","Array","_a","minMinor","range","reset","parseNegotiatedResponse","buffer","h","readUInt8","Number","newHandshakeBuffer","handshake","channel","_this","Promise","resolve","reject","handshakeErrorHandler","error","onerror","bind","_error","onmessage","protocolVersion","consumeRemainingBuffer","consumer","hasRemaining","readSlice","remaining","e","write","default"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,YAAD,CAAvB;;AACA,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,mBAAD,CAAjC;;AACA,IAAIE,mBAAmB,GAAG,UAA1B;;AACA,SAASC,OAAT,CAAiBC,KAAjB,EAAwBC,KAAxB,EAA+B;AAC3B,SAAO;AACHD,IAAAA,KAAK,EAAEA,KADJ;AAEHC,IAAAA,KAAK,EAAEA;AAFJ,GAAP;AAIH;;AACD,SAASC,sBAAT,CAAgCC,QAAhC,EAA0C;AACtC,MAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAtB,EAAyB;AACrB,UAAM,CAAC,GAAGP,mBAAmB,CAACQ,QAAxB,EAAkC,yDAAlC,CAAN;AACH;;AACD,MAAIC,eAAe,GAAG,CAAC,GAAGX,SAAS,CAACY,KAAd,EAAqB,IAAI,CAAzB,CAAtB;AACAD,EAAAA,eAAe,CAACE,UAAhB,CAA2BV,mBAA3B;AACAK,EAAAA,QAAQ,CAACM,OAAT,CAAiB,UAAUV,OAAV,EAAmB;AAChC,QAAIA,OAAO,YAAYW,KAAvB,EAA8B;AAC1B,UAAIC,EAAE,GAAGZ,OAAO,CAAC,CAAD,CAAhB;AAAA,UAAqBC,KAAK,GAAGW,EAAE,CAACX,KAAhC;AAAA,UAAuCC,KAAK,GAAGU,EAAE,CAACV,KAAlD;AACA,UAAIW,QAAQ,GAAGb,OAAO,CAAC,CAAD,CAAP,CAAWE,KAA1B;AACA,UAAIY,KAAK,GAAGZ,KAAK,GAAGW,QAApB;AACAN,MAAAA,eAAe,CAACE,UAAhB,CAA4BK,KAAK,IAAI,EAAV,GAAiBZ,KAAK,IAAI,CAA1B,GAA+BD,KAA1D;AACH,KALD,MAMK;AACD,UAAIA,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,UAA2BC,KAAK,GAAGF,OAAO,CAACE,KAA3C;AACAK,MAAAA,eAAe,CAACE,UAAhB,CAA4BP,KAAK,IAAI,CAAV,GAAeD,KAA1C;AACH;AACJ,GAXD;AAYAM,EAAAA,eAAe,CAACQ,KAAhB;AACA,SAAOR,eAAP;AACH;;AACD,SAASS,uBAAT,CAAiCC,MAAjC,EAAyC;AACrC,MAAIC,CAAC,GAAG,CACJD,MAAM,CAACE,SAAP,EADI,EAEJF,MAAM,CAACE,SAAP,EAFI,EAGJF,MAAM,CAACE,SAAP,EAHI,EAIJF,MAAM,CAACE,SAAP,EAJI,CAAR;;AAMA,MAAID,CAAC,CAAC,CAAD,CAAD,KAAS,IAAT,IAAiBA,CAAC,CAAC,CAAD,CAAD,KAAS,IAA1B,IAAkCA,CAAC,CAAC,CAAD,CAAD,KAAS,IAA3C,IAAmDA,CAAC,CAAC,CAAD,CAAD,KAAS,IAAhE,EAAsE;AAClE,UAAM,CAAC,GAAGpB,mBAAmB,CAACQ,QAAxB,EAAkC,yFACpC,iEADE,CAAN;AAEH;;AACD,SAAOc,MAAM,CAACF,CAAC,CAAC,CAAD,CAAD,GAAO,GAAP,GAAaA,CAAC,CAAC,CAAD,CAAf,CAAb;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASG,kBAAT,GAA8B;AAC1B,SAAOlB,sBAAsB,CAAC,CAC1B,CAACH,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAR,EAAgBA,OAAO,CAAC,CAAD,EAAI,CAAJ,CAAvB,CAD0B,EAE1BA,OAAO,CAAC,CAAD,EAAI,CAAJ,CAFmB,EAG1BA,OAAO,CAAC,CAAD,EAAI,CAAJ,CAHmB,EAI1BA,OAAO,CAAC,CAAD,EAAI,CAAJ,CAJmB,CAAD,CAA7B;AAMH;AACD;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASsB,SAAT,CAAmBC,OAAnB,EAA4B;AACxB,MAAIC,KAAK,GAAG,IAAZ;;AACA,SAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC1C,QAAIC,qBAAqB,GAAG,UAAUC,KAAV,EAAiB;AACzCF,MAAAA,MAAM,CAACE,KAAD,CAAN;AACH,KAFD;;AAGAN,IAAAA,OAAO,CAACO,OAAR,GAAkBF,qBAAqB,CAACG,IAAtB,CAA2BP,KAA3B,CAAlB;;AACA,QAAID,OAAO,CAACS,MAAZ,EAAoB;AAChBJ,MAAAA,qBAAqB,CAACL,OAAO,CAACS,MAAT,CAArB;AACH;;AACDT,IAAAA,OAAO,CAACU,SAAR,GAAoB,UAAUhB,MAAV,EAAkB;AAClC,UAAI;AACA;AACA,YAAIiB,eAAe,GAAGlB,uBAAuB,CAACC,MAAD,CAA7C;AACAS,QAAAA,OAAO,CAAC;AACJQ,UAAAA,eAAe,EAAEA,eADb;AAEJC,UAAAA,sBAAsB,EAAE,UAAUC,QAAV,EAAoB;AACxC,gBAAInB,MAAM,CAACoB,YAAP,EAAJ,EAA2B;AACvBD,cAAAA,QAAQ,CAACnB,MAAM,CAACqB,SAAP,CAAiBrB,MAAM,CAACsB,SAAP,EAAjB,CAAD,CAAR;AACH;AACJ;AANG,SAAD,CAAP;AAQH,OAXD,CAYA,OAAOC,CAAP,EAAU;AACNb,QAAAA,MAAM,CAACa,CAAD,CAAN;AACH;AACJ,KAhBD;;AAiBAjB,IAAAA,OAAO,CAACkB,KAAR,CAAcpB,kBAAkB,EAAhC;AACH,GA1BM,CAAP;AA2BH;;AACD3B,OAAO,CAACgD,OAAR,GAAkBpB,SAAlB","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright (c) \"Neo4j\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar channel_1 = require(\"../channel\");\r\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\r\nvar BOLT_MAGIC_PREAMBLE = 0x6060b017;\r\nfunction version(major, minor) {\r\n    return {\r\n        major: major,\r\n        minor: minor\r\n    };\r\n}\r\nfunction createHandshakeMessage(versions) {\r\n    if (versions.length > 4) {\r\n        throw (0, neo4j_driver_core_1.newError)('It should not have more than 4 versions of the protocol');\r\n    }\r\n    var handshakeBuffer = (0, channel_1.alloc)(5 * 4);\r\n    handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE);\r\n    versions.forEach(function (version) {\r\n        if (version instanceof Array) {\r\n            var _a = version[0], major = _a.major, minor = _a.minor;\r\n            var minMinor = version[1].minor;\r\n            var range = minor - minMinor;\r\n            handshakeBuffer.writeInt32((range << 16) | (minor << 8) | major);\r\n        }\r\n        else {\r\n            var major = version.major, minor = version.minor;\r\n            handshakeBuffer.writeInt32((minor << 8) | major);\r\n        }\r\n    });\r\n    handshakeBuffer.reset();\r\n    return handshakeBuffer;\r\n}\r\nfunction parseNegotiatedResponse(buffer) {\r\n    var h = [\r\n        buffer.readUInt8(),\r\n        buffer.readUInt8(),\r\n        buffer.readUInt8(),\r\n        buffer.readUInt8()\r\n    ];\r\n    if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {\r\n        throw (0, neo4j_driver_core_1.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' +\r\n            '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');\r\n    }\r\n    return Number(h[3] + '.' + h[2]);\r\n}\r\n/**\r\n * @return {BaseBuffer}\r\n * @private\r\n */\r\nfunction newHandshakeBuffer() {\r\n    return createHandshakeMessage([\r\n        [version(4, 4), version(4, 2)],\r\n        version(4, 1),\r\n        version(4, 0),\r\n        version(3, 0)\r\n    ]);\r\n}\r\n/**\r\n * This callback is displayed as a global member.\r\n * @callback BufferConsumerCallback\r\n * @param {buffer} buffer the remaining buffer\r\n */\r\n/**\r\n * @typedef HandshakeResult\r\n * @property {number} protocolVersion The protocol version negotiated in the handshake\r\n * @property {function(BufferConsumerCallback)} consumeRemainingBuffer A function to consume the remaining buffer if it exists\r\n */\r\n/**\r\n * Shake hands using the channel and return the protocol version\r\n *\r\n * @param {Channel} channel the channel use to shake hands\r\n * @returns {Promise<HandshakeResult>} Promise of protocol version and consumeRemainingBuffer\r\n */\r\nfunction handshake(channel) {\r\n    var _this = this;\r\n    return new Promise(function (resolve, reject) {\r\n        var handshakeErrorHandler = function (error) {\r\n            reject(error);\r\n        };\r\n        channel.onerror = handshakeErrorHandler.bind(_this);\r\n        if (channel._error) {\r\n            handshakeErrorHandler(channel._error);\r\n        }\r\n        channel.onmessage = function (buffer) {\r\n            try {\r\n                // read the response buffer and initialize the protocol\r\n                var protocolVersion = parseNegotiatedResponse(buffer);\r\n                resolve({\r\n                    protocolVersion: protocolVersion,\r\n                    consumeRemainingBuffer: function (consumer) {\r\n                        if (buffer.hasRemaining()) {\r\n                            consumer(buffer.readSlice(buffer.remaining()));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        };\r\n        channel.write(newHandshakeBuffer());\r\n    });\r\n}\r\nexports.default = handshake;\r\n"]},"metadata":{},"sourceType":"script"}