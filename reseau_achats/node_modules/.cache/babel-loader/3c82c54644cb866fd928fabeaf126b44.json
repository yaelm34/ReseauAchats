{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar util_1 = require(\"./internal/util\");\n\nvar connection_holder_1 = require(\"./internal/connection-holder\");\n\nvar bookmark_1 = require(\"./internal/bookmark\");\n\nvar tx_config_1 = require(\"./internal/tx-config\");\n\nvar observers_1 = require(\"./internal/observers\");\n\nvar error_1 = require(\"./error\");\n\nvar result_1 = __importDefault(require(\"./result\"));\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\n\n\nvar Transaction =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\n   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\n   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\n   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\n   * is not yet released.\n   * @param {boolean} reactive whether this transaction generates reactive streams\n   * @param {number} fetchSize - the record fetch size in each pulling batch.\n   * @param {string} impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n   */\n  function Transaction(_a) {\n    var connectionHolder = _a.connectionHolder,\n        onClose = _a.onClose,\n        onBookmark = _a.onBookmark,\n        onConnection = _a.onConnection,\n        reactive = _a.reactive,\n        fetchSize = _a.fetchSize,\n        impersonatedUser = _a.impersonatedUser;\n    this._connectionHolder = connectionHolder;\n    this._reactive = reactive;\n    this._state = _states.ACTIVE;\n    this._onClose = onClose;\n    this._onBookmark = onBookmark;\n    this._onConnection = onConnection;\n    this._onError = this._onErrorCallback.bind(this);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._fetchSize = fetchSize;\n    this._results = [];\n    this._impersonatedUser = impersonatedUser;\n  }\n  /**\n   * @private\n   * @param {Bookmark | string |  string []} bookmark\n   * @param {TxConfig} txConfig\n   * @returns {void}\n   */\n\n\n  Transaction.prototype._begin = function (bookmark, txConfig) {\n    var _this = this;\n\n    this._connectionHolder.getConnection().then(function (connection) {\n      _this._onConnection();\n\n      if (connection) {\n        return connection.protocol().beginTransaction({\n          bookmark: bookmark,\n          txConfig: txConfig,\n          mode: _this._connectionHolder.mode(),\n          database: _this._connectionHolder.database(),\n          impersonatedUser: _this._impersonatedUser,\n          beforeError: _this._onError,\n          afterComplete: _this._onComplete\n        });\n      } else {\n        throw (0, error_1.newError)('No connection available');\n      }\n    }).catch(function (error) {\n      return _this._onError(error);\n    });\n  };\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @return {Result} New Result\n   */\n\n\n  Transaction.prototype.run = function (query, parameters) {\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n        validatedQuery = _a.validatedQuery,\n        params = _a.params;\n\n    var result = this._state.run(validatedQuery, params, {\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      reactive: this._reactive,\n      fetchSize: this._fetchSize\n    });\n\n    this._results.push(result);\n\n    return result;\n  };\n  /**\n   * Commits the transaction and returns the result.\n   *\n   * After committing the transaction can no longer be used.\n   *\n   * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\n   */\n\n\n  Transaction.prototype.commit = function () {\n    var committed = this._state.commit({\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      pendingResults: this._results\n    });\n\n    this._state = committed.state; // clean up\n\n    this._onClose();\n\n    return new Promise(function (resolve, reject) {\n      committed.result.subscribe({\n        onCompleted: function () {\n          return resolve();\n        },\n        onError: function (error) {\n          return reject(error);\n        }\n      });\n    });\n  };\n  /**\n   * Rollbacks the transaction.\n   *\n   * After rolling back, the transaction can no longer be used.\n   *\n   * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\n   * rollback.\n   */\n\n\n  Transaction.prototype.rollback = function () {\n    var rolledback = this._state.rollback({\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      pendingResults: this._results\n    });\n\n    this._state = rolledback.state; // clean up\n\n    this._onClose();\n\n    return new Promise(function (resolve, reject) {\n      rolledback.result.subscribe({\n        onCompleted: function () {\n          return resolve();\n        },\n        onError: function (error) {\n          return reject(error);\n        }\n      });\n    });\n  };\n  /**\n   * Check if this transaction is active, which means commit and rollback did not happen.\n   * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n   */\n\n\n  Transaction.prototype.isOpen = function () {\n    return this._state === _states.ACTIVE;\n  };\n\n  Transaction.prototype._onErrorCallback = function (err) {\n    // error will be \"acknowledged\" by sending a RESET message\n    // database will then forget about this transaction and cleanup all corresponding resources\n    // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n    this._state = _states.FAILED;\n\n    this._onClose(); // release connection back to the pool\n\n\n    return this._connectionHolder.releaseConnection();\n  };\n  /**\n   * @private\n   * @param {object} meta The meta with bookmark\n   * @returns {void}\n   */\n\n\n  Transaction.prototype._onCompleteCallback = function (meta) {\n    this._onBookmark(new bookmark_1.Bookmark(meta.bookmark));\n  };\n\n  return Transaction;\n}();\n\nvar _states = {\n  // The transaction is running with no explicit success or failure marked\n  ACTIVE: {\n    commit: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete,\n          onConnection = _a.onConnection,\n          pendingResults = _a.pendingResults;\n      return {\n        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete,\n          onConnection = _a.onConnection,\n          pendingResults = _a.pendingResults;\n      return {\n        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function (query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete,\n          onConnection = _a.onConnection,\n          reactive = _a.reactive,\n          fetchSize = _a.fetchSize; // RUN in explicit transaction can't contain bookmarks and transaction configuration\n      // No need to include mode and database name as it shall be inclued in begin\n\n      var observerPromise = connectionHolder.getConnection().then(function (conn) {\n        onConnection();\n\n        if (conn) {\n          return conn.protocol().run(query, parameters, {\n            bookmark: bookmark_1.Bookmark.empty(),\n            txConfig: tx_config_1.TxConfig.empty(),\n            beforeError: onError,\n            afterComplete: onComplete,\n            reactive: reactive,\n            fetchSize: fetchSize\n          });\n        } else {\n          throw (0, error_1.newError)('No connection available');\n        }\n      }).catch(function (error) {\n        return new observers_1.FailedObserver({\n          error: error,\n          onError: onError\n        });\n      });\n      return newCompletedResult(observerPromise, query, parameters, connectionHolder);\n    }\n  },\n  // An error has occurred, transaction can no longer be used and no more messages will\n  // be sent for this transaction.\n  FAILED: {\n    commit: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n          onError: onError\n        }), 'COMMIT', {}, connectionHolder),\n        state: _states.FAILED\n      };\n    },\n    rollback: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.CompletedObserver(), 'ROLLBACK', {}, connectionHolder),\n        state: _states.FAILED\n      };\n    },\n    run: function (query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  },\n  // This transaction has successfully committed\n  SUCCEEDED: {\n    commit: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'COMMIT', {}),\n        state: _states.SUCCEEDED,\n        connectionHolder: connectionHolder\n      };\n    },\n    rollback: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'ROLLBACK', {}),\n        state: _states.SUCCEEDED,\n        connectionHolder: connectionHolder\n      };\n    },\n    run: function (query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been committed.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  },\n  // This transaction has been rolled back\n  ROLLED_BACK: {\n    commit: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n          onError: onError\n        }), 'COMMIT', {}, connectionHolder),\n        state: _states.ROLLED_BACK\n      };\n    },\n    rollback: function (_a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n        }), 'ROLLBACK', {}, connectionHolder),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function (query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n          onError = _a.onError,\n          onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  }\n};\n/**\n *\n * @param {boolean} commit\n * @param {ConnectionHolder} connectionHolder\n * @param {function(err:Error): any} onError\n * @param {function(metadata:object): any} onComplete\n * @param {function() : any} onConnection\n * @param {list<Result>>}pendingResults all run results in this transaction\n */\n\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\n  var observerPromise = connectionHolder.getConnection().then(function (connection) {\n    onConnection();\n    pendingResults.forEach(function (r) {\n      return r._cancel();\n    });\n    return Promise.all(pendingResults).then(function (results) {\n      if (connection) {\n        if (commit) {\n          return connection.protocol().commitTransaction({\n            beforeError: onError,\n            afterComplete: onComplete\n          });\n        } else {\n          return connection.protocol().rollbackTransaction({\n            beforeError: onError,\n            afterComplete: onComplete\n          });\n        }\n      } else {\n        throw (0, error_1.newError)('No connection available');\n      }\n    });\n  }).catch(function (error) {\n    return new observers_1.FailedObserver({\n      error: error,\n      onError: onError\n    });\n  }); // for commit & rollback we need result that uses real connection holder and notifies it when\n  // connection is not needed and can be safely released to the pool\n\n  return new result_1.default(observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {ResultStreamObserver} observer - an observer for the created result.\n * @param {string} query - the cypher query that produced the result.\n * @param {Object} parameters - the parameters for cypher query that produced the result.\n * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result\n * @return {Result} new result.\n * @private\n */\n\n\nfunction newCompletedResult(observerPromise, query, parameters, connectionHolder) {\n  if (connectionHolder === void 0) {\n    connectionHolder = connection_holder_1.EMPTY_CONNECTION_HOLDER;\n  }\n\n  return new result_1.default(Promise.resolve(observerPromise), query, parameters, new connection_holder_1.ReadOnlyConnectionHolder(connectionHolder || connection_holder_1.EMPTY_CONNECTION_HOLDER));\n}\n\nexports.default = Transaction;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/transaction.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","util_1","require","connection_holder_1","bookmark_1","tx_config_1","observers_1","error_1","result_1","Transaction","_a","connectionHolder","onClose","onBookmark","onConnection","reactive","fetchSize","impersonatedUser","_connectionHolder","_reactive","_state","_states","ACTIVE","_onClose","_onBookmark","_onConnection","_onError","_onErrorCallback","bind","_onComplete","_onCompleteCallback","_fetchSize","_results","_impersonatedUser","prototype","_begin","bookmark","txConfig","_this","getConnection","then","connection","protocol","beginTransaction","mode","database","beforeError","afterComplete","newError","catch","error","run","query","parameters","validateQueryAndParameters","validatedQuery","params","result","onError","onComplete","push","commit","committed","pendingResults","state","Promise","resolve","reject","subscribe","onCompleted","rollback","rolledback","isOpen","err","FAILED","releaseConnection","meta","Bookmark","finishTransaction","SUCCEEDED","ROLLED_BACK","observerPromise","conn","empty","TxConfig","FailedObserver","newCompletedResult","CompletedObserver","forEach","r","_cancel","all","results","commitTransaction","rollbackTransaction","default","EMPTY_CONNECTION_HOLDER","ReadOnlyConnectionHolder"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar util_1 = require(\"./internal/util\");\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar observers_1 = require(\"./internal/observers\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\nvar Transaction = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\n     * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\n     * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\n     * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\n     * is not yet released.\n     * @param {boolean} reactive whether this transaction generates reactive streams\n     * @param {number} fetchSize - the record fetch size in each pulling batch.\n     * @param {string} impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n     */\n    function Transaction(_a) {\n        var connectionHolder = _a.connectionHolder, onClose = _a.onClose, onBookmark = _a.onBookmark, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser;\n        this._connectionHolder = connectionHolder;\n        this._reactive = reactive;\n        this._state = _states.ACTIVE;\n        this._onClose = onClose;\n        this._onBookmark = onBookmark;\n        this._onConnection = onConnection;\n        this._onError = this._onErrorCallback.bind(this);\n        this._onComplete = this._onCompleteCallback.bind(this);\n        this._fetchSize = fetchSize;\n        this._results = [];\n        this._impersonatedUser = impersonatedUser;\n    }\n    /**\n     * @private\n     * @param {Bookmark | string |  string []} bookmark\n     * @param {TxConfig} txConfig\n     * @returns {void}\n     */\n    Transaction.prototype._begin = function (bookmark, txConfig) {\n        var _this = this;\n        this._connectionHolder\n            .getConnection()\n            .then(function (connection) {\n            _this._onConnection();\n            if (connection) {\n                return connection.protocol().beginTransaction({\n                    bookmark: bookmark,\n                    txConfig: txConfig,\n                    mode: _this._connectionHolder.mode(),\n                    database: _this._connectionHolder.database(),\n                    impersonatedUser: _this._impersonatedUser,\n                    beforeError: _this._onError,\n                    afterComplete: _this._onComplete\n                });\n            }\n            else {\n                throw (0, error_1.newError)('No connection available');\n            }\n        })\n            .catch(function (error) { return _this._onError(error); });\n    };\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @return {Result} New Result\n     */\n    Transaction.prototype.run = function (query, parameters) {\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var result = this._state.run(validatedQuery, params, {\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            reactive: this._reactive,\n            fetchSize: this._fetchSize\n        });\n        this._results.push(result);\n        return result;\n    };\n    /**\n     * Commits the transaction and returns the result.\n     *\n     * After committing the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\n     */\n    Transaction.prototype.commit = function () {\n        var committed = this._state.commit({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            pendingResults: this._results\n        });\n        this._state = committed.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            committed.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Rollbacks the transaction.\n     *\n     * After rolling back, the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\n     * rollback.\n     */\n    Transaction.prototype.rollback = function () {\n        var rolledback = this._state.rollback({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            pendingResults: this._results\n        });\n        this._state = rolledback.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            rolledback.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Check if this transaction is active, which means commit and rollback did not happen.\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n     */\n    Transaction.prototype.isOpen = function () {\n        return this._state === _states.ACTIVE;\n    };\n    Transaction.prototype._onErrorCallback = function (err) {\n        // error will be \"acknowledged\" by sending a RESET message\n        // database will then forget about this transaction and cleanup all corresponding resources\n        // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n        this._state = _states.FAILED;\n        this._onClose();\n        // release connection back to the pool\n        return this._connectionHolder.releaseConnection();\n    };\n    /**\n     * @private\n     * @param {object} meta The meta with bookmark\n     * @returns {void}\n     */\n    Transaction.prototype._onCompleteCallback = function (meta) {\n        this._onBookmark(new bookmark_1.Bookmark(meta.bookmark));\n    };\n    return Transaction;\n}());\nvar _states = {\n    // The transaction is running with no explicit success or failure marked\n    ACTIVE: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults;\n            return {\n                result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\n                state: _states.SUCCEEDED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults;\n            return {\n                result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize;\n            // RUN in explicit transaction can't contain bookmarks and transaction configuration\n            // No need to include mode and database name as it shall be inclued in begin\n            var observerPromise = connectionHolder\n                .getConnection()\n                .then(function (conn) {\n                onConnection();\n                if (conn) {\n                    return conn.protocol().run(query, parameters, {\n                        bookmark: bookmark_1.Bookmark.empty(),\n                        txConfig: tx_config_1.TxConfig.empty(),\n                        beforeError: onError,\n                        afterComplete: onComplete,\n                        reactive: reactive,\n                        fetchSize: fetchSize,\n                    });\n                }\n                else {\n                    throw (0, error_1.newError)('No connection available');\n                }\n            })\n                .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n            return newCompletedResult(observerPromise, query, parameters, connectionHolder);\n        }\n    },\n    // An error has occurred, transaction can no longer be used and no more messages will\n    // be sent for this transaction.\n    FAILED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder),\n                state: _states.FAILED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.CompletedObserver(), 'ROLLBACK', {}, connectionHolder),\n                state: _states.FAILED\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    },\n    // This transaction has successfully committed\n    SUCCEEDED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'COMMIT', {}),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'ROLLBACK', {}),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been committed.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    },\n    // This transaction has been rolled back\n    ROLLED_BACK: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder),\n                state: _states.ROLLED_BACK\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n                }), 'ROLLBACK', {}, connectionHolder),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    }\n};\n/**\n *\n * @param {boolean} commit\n * @param {ConnectionHolder} connectionHolder\n * @param {function(err:Error): any} onError\n * @param {function(metadata:object): any} onComplete\n * @param {function() : any} onConnection\n * @param {list<Result>>}pendingResults all run results in this transaction\n */\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\n    var observerPromise = connectionHolder\n        .getConnection()\n        .then(function (connection) {\n        onConnection();\n        pendingResults.forEach(function (r) { return r._cancel(); });\n        return Promise.all(pendingResults).then(function (results) {\n            if (connection) {\n                if (commit) {\n                    return connection.protocol().commitTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n                else {\n                    return connection.protocol().rollbackTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n            }\n            else {\n                throw (0, error_1.newError)('No connection available');\n            }\n        });\n    })\n        .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n    // for commit & rollback we need result that uses real connection holder and notifies it when\n    // connection is not needed and can be safely released to the pool\n    return new result_1.default(observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {ResultStreamObserver} observer - an observer for the created result.\n * @param {string} query - the cypher query that produced the result.\n * @param {Object} parameters - the parameters for cypher query that produced the result.\n * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result\n * @return {Result} new result.\n * @private\n */\nfunction newCompletedResult(observerPromise, query, parameters, connectionHolder) {\n    if (connectionHolder === void 0) { connectionHolder = connection_holder_1.EMPTY_CONNECTION_HOLDER; }\n    return new result_1.default(Promise.resolve(observerPromise), query, parameters, new connection_holder_1.ReadOnlyConnectionHolder(connectionHolder || connection_holder_1.EMPTY_CONNECTION_HOLDER));\n}\nexports.default = Transaction;\n"]},"metadata":{},"sourceType":"script"}