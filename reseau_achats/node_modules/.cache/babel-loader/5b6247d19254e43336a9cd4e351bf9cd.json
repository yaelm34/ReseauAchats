{"ast":null,"code":"/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nexport function range(start, count, scheduler) {\n  if (start === void 0) {\n    start = 0;\n  }\n\n  return new Observable(function (subscriber) {\n    if (count === undefined) {\n      count = start;\n      start = 0;\n    }\n\n    var index = 0;\n    var current = start;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        index: index,\n        count: count,\n        start: start,\n        subscriber: subscriber\n      });\n    } else {\n      do {\n        if (index++ >= count) {\n          subscriber.complete();\n          break;\n        }\n\n        subscriber.next(current++);\n\n        if (subscriber.closed) {\n          break;\n        }\n      } while (true);\n    }\n\n    return undefined;\n  });\n}\nexport function dispatch(state) {\n  var start = state.start,\n      index = state.index,\n      count = state.count,\n      subscriber = state.subscriber;\n\n  if (index >= count) {\n    subscriber.complete();\n    return;\n  }\n\n  subscriber.next(start);\n\n  if (subscriber.closed) {\n    return;\n  }\n\n  state.index = index + 1;\n  state.start = start + 1;\n  this.schedule(state);\n}","map":{"version":3,"mappings":"AACA;AAoCA,SAAMA,UAAN,QAAuC,eAAvC;OAAsB,wCAAiB;AAGrC,WAAO,KAAI,MAAX,EAA8B;AAC5BC,SAAI,IAAJ;;;aAEED,WAAU;QACXE;AAEGA,WAAK,GAAGD,KAAR;AACAA,cAAO,CAAP;AAEJ;;QACEE,QAAO;eACL,GAAKF;;mBACJ;AACJ;AAAME,oBAAN;AAAMD,oBAAN;AAAMD,oBAAN;AAAMG;AAAN;;;YAKID;AACDC,oBAAW,CAAIC,QAAf;AACI;;;kBAEH;;AACF,sBAAc,OAAd,EAAc;AAChB;AAEM;AACN;AACJ;;AAGK;AACI;;gBAGNC,SAAWC,OAAW;MACtBN,QAAOM;MAAAJ;MAAAD;MAAAE;;MACRD;AAEDC,cAAW,CAAIC,QAAf;AAEI;;;YAEH;;AAED,gBAAc,OAAd,EAAuB;AACvB;AAEA;;AACDE","names":["Observable","start","count","index","subscriber","complete","dispatch","state"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\observable\\range.ts"],"sourcesContent":["import { SchedulerAction, SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\n\r\n/**\r\n * Creates an Observable that emits a sequence of numbers within a specified\r\n * range.\r\n *\r\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\r\n *\r\n * ![](range.png)\r\n *\r\n * `range` operator emits a range of sequential integers, in order, where you\r\n * select the `start` of the range and its `length`. By default, uses no\r\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\r\n * an optional {@link SchedulerLike} to regulate those deliveries.\r\n *\r\n * ## Example\r\n * Emits the numbers 1 to 10</caption>\r\n * ```ts\r\n * import { range } from 'rxjs';\r\n *\r\n * const numbers = range(1, 10);\r\n * numbers.subscribe(x => console.log(x));\r\n * ```\r\n * @see {@link timer}\r\n * @see {@link index/interval}\r\n *\r\n * @param {number} [start=0] The value of the first integer in the sequence.\r\n * @param {number} count The number of sequential integers to generate.\r\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\r\n * the emissions of the notifications.\r\n * @return {Observable} An Observable of numbers that emits a finite range of\r\n * sequential integers.\r\n * @static true\r\n * @name range\r\n * @owner Observable\r\n */\r\nexport function range(start: number = 0,\r\n                      count?: number,\r\n                      scheduler?: SchedulerLike): Observable<number> {\r\n  return new Observable<number>(subscriber => {\r\n    if (count === undefined) {\r\n      count = start;\r\n      start = 0;\r\n    }\r\n\r\n    let index = 0;\r\n    let current = start;\r\n\r\n    if (scheduler) {\r\n      return scheduler.schedule(dispatch, 0, {\r\n        index, count, start, subscriber\r\n      });\r\n    } else {\r\n      do {\r\n        if (index++ >= count) {\r\n          subscriber.complete();\r\n          break;\r\n        }\r\n        subscriber.next(current++);\r\n        if (subscriber.closed) {\r\n          break;\r\n        }\r\n      } while (true);\r\n    }\r\n\r\n    return undefined;\r\n  });\r\n}\r\n\r\n/** @internal */\r\nexport function dispatch(this: SchedulerAction<any>, state: any) {\r\n  const { start, index, count, subscriber } = state;\r\n\r\n  if (index >= count) {\r\n    subscriber.complete();\r\n    return;\r\n  }\r\n\r\n  subscriber.next(start);\r\n\r\n  if (subscriber.closed) {\r\n    return;\r\n  }\r\n\r\n  state.index = index + 1;\r\n  state.start = start + 1;\r\n\r\n  this.schedule(state);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}