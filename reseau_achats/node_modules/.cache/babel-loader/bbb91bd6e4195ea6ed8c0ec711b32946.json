{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\n\nvar json_1 = require(\"./json\");\n\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\n\nfunction hasIdentifierProperty(obj, property) {\n  return (obj && obj[property]) === true;\n}\n/**\r\n * Class for Node Type.\r\n */\n\n\nvar Node =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer|number} identity - Unique identity\r\n   * @param {Array<string>} labels - Array for all labels\r\n   * @param {Properties} properties - Map with node properties\r\n   */\n  function Node(identity, labels, properties) {\n    /**\r\n     * Identity of the node.\r\n     * @type {Integer|number}\r\n     */\n    this.identity = identity;\n    /**\r\n     * Labels of the node.\r\n     * @type {string[]}\r\n     */\n\n    this.labels = labels;\n    /**\r\n     * Properties of the node.\r\n     * @type {Properties}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  Node.prototype.toString = function () {\n    var s = '(' + this.identity;\n\n    for (var i = 0; i < this.labels.length; i++) {\n      s += ':' + this.labels[i];\n    }\n\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ')';\n    return s;\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Node} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\r\n */\n\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\n\nexports.isNode = isNode;\n/**\r\n * Class for Relationship Type.\r\n */\n\nvar Relationship =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer|number} identity - Unique identity\r\n   * @param {Integer|number} start - Identity of start Node\r\n   * @param {Integer|number} end - Identity of end Node\r\n   * @param {string} type - Relationship type\r\n   * @param {Properties} properties - Map with relationship properties\r\n   */\n  function Relationship(identity, start, end, type, properties) {\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer|number}\r\n     */\n    this.identity = identity;\n    /**\r\n     * Identity of the start node.\r\n     * @type {Integer|number}\r\n     */\n\n    this.start = start;\n    /**\r\n     * Identity of the end node.\r\n     * @type {Integer|number}\r\n     */\n\n    this.end = end;\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\n\n    this.type = type;\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Properties}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  Relationship.prototype.toString = function () {\n    var s = '(' + this.start + ')-[:' + this.type;\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ']->(' + this.end + ')';\n    return s;\n  };\n\n  return Relationship;\n}();\n\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Relationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\r\n */\n\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n\nexports.isRelationship = isRelationship;\n/**\r\n * Class for UnboundRelationship Type.\r\n * @access private\r\n */\n\nvar UnboundRelationship =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer|number} identity - Unique identity\r\n   * @param {string} type - Relationship type\r\n   * @param {Properties} properties - Map with relationship properties\r\n   */\n  function UnboundRelationship(identity, type, properties) {\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer|number}\r\n     */\n    this.identity = identity;\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\n\n    this.type = type;\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Properties}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * Bind relationship\r\n   *\r\n   * @protected\r\n   * @param {Integer} start - Identity of start node\r\n   * @param {Integer} end - Identity of end node\r\n   * @return {Relationship} - Created relationship\r\n   */\n\n\n  UnboundRelationship.prototype.bind = function (start, end) {\n    return new Relationship(this.identity, start, end, this.type, this.properties);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  UnboundRelationship.prototype.toString = function () {\n    var s = '-[:' + this.type;\n    var keys = Object.keys(this.properties);\n\n    if (keys.length > 0) {\n      s += ' {';\n\n      for (var i = 0; i < keys.length; i++) {\n        if (i > 0) s += ',';\n        s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n      }\n\n      s += '}';\n    }\n\n    s += ']->';\n    return s;\n  };\n\n  return UnboundRelationship;\n}();\n\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link UnboundRelationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\r\n */\n\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\r\n * Class for PathSegment Type.\r\n */\n\nvar PathSegment =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Node} start - start node\r\n   * @param {Relationship} rel - relationship that connects start and end node\r\n   * @param {Node} end - end node\r\n   */\n  function PathSegment(start, rel, end) {\n    /**\r\n     * Start node.\r\n     * @type {Node}\r\n     */\n    this.start = start;\n    /**\r\n     * Relationship.\r\n     * @type {Relationship}\r\n     */\n\n    this.relationship = rel;\n    /**\r\n     * End node.\r\n     * @type {Node}\r\n     */\n\n    this.end = end;\n  }\n\n  return PathSegment;\n}();\n\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link PathSegment} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\r\n */\n\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\n\nexports.isPathSegment = isPathSegment;\n/**\r\n * Class for Path Type.\r\n */\n\nvar Path =\n/** @class */\nfunction () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Node} start  - start node\r\n   * @param {Node} end - end node\r\n   * @param {Array<PathSegment>} segments - Array of Segments\r\n   */\n  function Path(start, end, segments) {\n    /**\r\n     * Start node.\r\n     * @type {Node}\r\n     */\n    this.start = start;\n    /**\r\n     * End node.\r\n     * @type {Node}\r\n     */\n\n    this.end = end;\n    /**\r\n     * Segments.\r\n     * @type {Array<PathSegment>}\r\n     */\n\n    this.segments = segments;\n    /**\r\n     * Length of the segments.\r\n     * @type {Number}\r\n     */\n\n    this.length = segments.length;\n  }\n\n  return Path;\n}();\n\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Path} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\r\n */\n\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\n\nexports.isPath = isPath;","map":{"version":3,"sources":["D:/Documents/EMA/Mines A3/NoSQL/ReseauAchats/reseau_achats/node_modules/neo4j-driver-core/lib/graph-types.js"],"names":["Object","defineProperty","exports","value","isPathSegment","PathSegment","isPath","Path","isUnboundRelationship","UnboundRelationship","isRelationship","Relationship","isNode","Node","json_1","require","IDENTIFIER_PROPERTY_ATTRIBUTES","enumerable","configurable","writable","NODE_IDENTIFIER_PROPERTY","RELATIONSHIP_IDENTIFIER_PROPERTY","UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY","PATH_IDENTIFIER_PROPERTY","PATH_SEGMENT_IDENTIFIER_PROPERTY","hasIdentifierProperty","obj","property","identity","labels","properties","prototype","toString","s","i","length","keys","stringify","start","end","type","bind","rel","relationship","segments"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\r\nvar json_1 = require(\"./json\");\r\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\r\n    value: true,\r\n    enumerable: false,\r\n    configurable: false,\r\n    writable: false\r\n};\r\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\r\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\r\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\r\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\r\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\r\nfunction hasIdentifierProperty(obj, property) {\r\n    return (obj && obj[property]) === true;\r\n}\r\n/**\r\n * Class for Node Type.\r\n */\r\nvar Node = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Integer|number} identity - Unique identity\r\n     * @param {Array<string>} labels - Array for all labels\r\n     * @param {Properties} properties - Map with node properties\r\n     */\r\n    function Node(identity, labels, properties) {\r\n        /**\r\n         * Identity of the node.\r\n         * @type {Integer|number}\r\n         */\r\n        this.identity = identity;\r\n        /**\r\n         * Labels of the node.\r\n         * @type {string[]}\r\n         */\r\n        this.labels = labels;\r\n        /**\r\n         * Properties of the node.\r\n         * @type {Properties}\r\n         */\r\n        this.properties = properties;\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    Node.prototype.toString = function () {\r\n        var s = '(' + this.identity;\r\n        for (var i = 0; i < this.labels.length; i++) {\r\n            s += ':' + this.labels[i];\r\n        }\r\n        var keys = Object.keys(this.properties);\r\n        if (keys.length > 0) {\r\n            s += ' {';\r\n            for (var i = 0; i < keys.length; i++) {\r\n                if (i > 0)\r\n                    s += ',';\r\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\r\n            }\r\n            s += '}';\r\n        }\r\n        s += ')';\r\n        return s;\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Node} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\r\n */\r\nfunction isNode(obj) {\r\n    return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\r\n}\r\nexports.isNode = isNode;\r\n/**\r\n * Class for Relationship Type.\r\n */\r\nvar Relationship = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Integer|number} identity - Unique identity\r\n     * @param {Integer|number} start - Identity of start Node\r\n     * @param {Integer|number} end - Identity of end Node\r\n     * @param {string} type - Relationship type\r\n     * @param {Properties} properties - Map with relationship properties\r\n     */\r\n    function Relationship(identity, start, end, type, properties) {\r\n        /**\r\n         * Identity of the relationship.\r\n         * @type {Integer|number}\r\n         */\r\n        this.identity = identity;\r\n        /**\r\n         * Identity of the start node.\r\n         * @type {Integer|number}\r\n         */\r\n        this.start = start;\r\n        /**\r\n         * Identity of the end node.\r\n         * @type {Integer|number}\r\n         */\r\n        this.end = end;\r\n        /**\r\n         * Type of the relationship.\r\n         * @type {string}\r\n         */\r\n        this.type = type;\r\n        /**\r\n         * Properties of the relationship.\r\n         * @type {Properties}\r\n         */\r\n        this.properties = properties;\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    Relationship.prototype.toString = function () {\r\n        var s = '(' + this.start + ')-[:' + this.type;\r\n        var keys = Object.keys(this.properties);\r\n        if (keys.length > 0) {\r\n            s += ' {';\r\n            for (var i = 0; i < keys.length; i++) {\r\n                if (i > 0)\r\n                    s += ',';\r\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\r\n            }\r\n            s += '}';\r\n        }\r\n        s += ']->(' + this.end + ')';\r\n        return s;\r\n    };\r\n    return Relationship;\r\n}());\r\nexports.Relationship = Relationship;\r\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Relationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\r\n */\r\nfunction isRelationship(obj) {\r\n    return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\r\n}\r\nexports.isRelationship = isRelationship;\r\n/**\r\n * Class for UnboundRelationship Type.\r\n * @access private\r\n */\r\nvar UnboundRelationship = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Integer|number} identity - Unique identity\r\n     * @param {string} type - Relationship type\r\n     * @param {Properties} properties - Map with relationship properties\r\n     */\r\n    function UnboundRelationship(identity, type, properties) {\r\n        /**\r\n         * Identity of the relationship.\r\n         * @type {Integer|number}\r\n         */\r\n        this.identity = identity;\r\n        /**\r\n         * Type of the relationship.\r\n         * @type {string}\r\n         */\r\n        this.type = type;\r\n        /**\r\n         * Properties of the relationship.\r\n         * @type {Properties}\r\n         */\r\n        this.properties = properties;\r\n    }\r\n    /**\r\n     * Bind relationship\r\n     *\r\n     * @protected\r\n     * @param {Integer} start - Identity of start node\r\n     * @param {Integer} end - Identity of end node\r\n     * @return {Relationship} - Created relationship\r\n     */\r\n    UnboundRelationship.prototype.bind = function (start, end) {\r\n        return new Relationship(this.identity, start, end, this.type, this.properties);\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    UnboundRelationship.prototype.toString = function () {\r\n        var s = '-[:' + this.type;\r\n        var keys = Object.keys(this.properties);\r\n        if (keys.length > 0) {\r\n            s += ' {';\r\n            for (var i = 0; i < keys.length; i++) {\r\n                if (i > 0)\r\n                    s += ',';\r\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\r\n            }\r\n            s += '}';\r\n        }\r\n        s += ']->';\r\n        return s;\r\n    };\r\n    return UnboundRelationship;\r\n}());\r\nexports.UnboundRelationship = UnboundRelationship;\r\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link UnboundRelationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\r\n */\r\nfunction isUnboundRelationship(obj) {\r\n    return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\r\n}\r\nexports.isUnboundRelationship = isUnboundRelationship;\r\n/**\r\n * Class for PathSegment Type.\r\n */\r\nvar PathSegment = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Node} start - start node\r\n     * @param {Relationship} rel - relationship that connects start and end node\r\n     * @param {Node} end - end node\r\n     */\r\n    function PathSegment(start, rel, end) {\r\n        /**\r\n         * Start node.\r\n         * @type {Node}\r\n         */\r\n        this.start = start;\r\n        /**\r\n         * Relationship.\r\n         * @type {Relationship}\r\n         */\r\n        this.relationship = rel;\r\n        /**\r\n         * End node.\r\n         * @type {Node}\r\n         */\r\n        this.end = end;\r\n    }\r\n    return PathSegment;\r\n}());\r\nexports.PathSegment = PathSegment;\r\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link PathSegment} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\r\n */\r\nfunction isPathSegment(obj) {\r\n    return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\r\n}\r\nexports.isPathSegment = isPathSegment;\r\n/**\r\n * Class for Path Type.\r\n */\r\nvar Path = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @protected\r\n     * @param {Node} start  - start node\r\n     * @param {Node} end - end node\r\n     * @param {Array<PathSegment>} segments - Array of Segments\r\n     */\r\n    function Path(start, end, segments) {\r\n        /**\r\n         * Start node.\r\n         * @type {Node}\r\n         */\r\n        this.start = start;\r\n        /**\r\n         * End node.\r\n         * @type {Node}\r\n         */\r\n        this.end = end;\r\n        /**\r\n         * Segments.\r\n         * @type {Array<PathSegment>}\r\n         */\r\n        this.segments = segments;\r\n        /**\r\n         * Length of the segments.\r\n         * @type {Number}\r\n         */\r\n        this.length = segments.length;\r\n    }\r\n    return Path;\r\n}());\r\nexports.Path = Path;\r\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Path} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\r\n */\r\nfunction isPath(obj) {\r\n    return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\r\n}\r\nexports.isPath = isPath;\r\n"]},"metadata":{},"sourceType":"script"}