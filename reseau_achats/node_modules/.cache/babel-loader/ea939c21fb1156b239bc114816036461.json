{"ast":null,"code":"/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\nimport { async } from '../scheduler/async';\nimport { TimeoutError } from '../util/TimeoutError';\nimport { timeoutWith } from './timeoutWith';\nimport { throwError } from '../observable/throwError';\nexport function timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}","map":{"version":3,"mappings":"AAAA;AAKA,SAASA,KAAT,QAAqB,oBAArB;AAEA,SAASC,YAAT,QAA4B,sBAA5B;AACA,SAASC,WAAT,QAA2B,eAA3B;AAgFA,SAAMC,UAAN,QAA6C,0BAA7C;OAC2B;AACzB,eAAO,KAAW,KAAI,CAAtB,EAAwB;AACzBC","names":["async","TimeoutError","timeoutWith","throwError","scheduler"],"sources":["D:\\Documents\\EMA\\Mines A3\\NoSQL\\ReseauAchats\\reseau_achats\\node_modules\\rxjs\\src\\internal\\operators\\timeout.ts"],"sourcesContent":["import { async } from '../scheduler/async';\r\nimport { isDate } from '../util/isDate';\r\nimport { Operator } from '../Operator';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Observable } from '../Observable';\r\nimport { TimeoutError } from '../util/TimeoutError';\r\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic } from '../types';\r\nimport { timeoutWith } from './timeoutWith';\r\nimport { throwError } from '../observable/throwError';\r\n\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span.\r\n *\r\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * `timeout` operator accepts as an argument either a number or a Date.\r\n *\r\n * If number was provided, it returns an Observable that behaves like a source\r\n * Observable, unless there is a period of time where there is no value emitted.\r\n * So if you provide `100` as argument and first value comes after 50ms from\r\n * the moment of subscription, this value will be simply re-emitted by the resulting\r\n * Observable. If however after that 100ms passes without a second value being emitted,\r\n * stream will end with an error and source Observable will be unsubscribed.\r\n * These checks are performed throughout whole lifecycle of Observable - from the moment\r\n * it was subscribed to, until it completes or errors itself. Thus every value must be\r\n * emitted within specified period since previous value.\r\n *\r\n * If provided argument was Date, returned Observable behaves differently. It throws\r\n * if Observable did not complete before provided Date. This means that periods between\r\n * emission of particular values do not matter in this case. If Observable did not complete\r\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\r\n * stream behaves just as source Observable.\r\n *\r\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\r\n * when returned Observable will check if source stream emitted value or completed.\r\n *\r\n * ## Examples\r\n * Check if ticks are emitted within certain timespan\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { timeout } from 'rxjs/operators';\r\n *\r\n * const seconds = interval(1000);\r\n *\r\n * seconds.pipe(timeout(1100))      // Let's use bigger timespan to be safe,\r\n *                                  // since `interval` might fire a bit later then scheduled.\r\n * .subscribe(\r\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\r\n *     err => console.log(err),     // Will never be called.\r\n * );\r\n *\r\n * seconds.pipe(timeout(900))\r\n * .subscribe(\r\n *     value => console.log(value), // Will never be called.\r\n *     err => console.log(err),     // Will emit error before even first value is emitted,\r\n *                                  // since it did not arrive within 900ms period.\r\n * );\r\n * ```\r\n *\r\n * Use Date to check if Observable completed\r\n * ```ts\r\n * import { interval } from 'rxjs';\r\n * import { timeout } from 'rxjs/operators';\r\n *\r\n * const seconds = interval(1000);\r\n *\r\n * seconds.pipe(\r\n *   timeout(new Date(\"December 17, 2020 03:24:00\")),\r\n * )\r\n * .subscribe(\r\n *     value => console.log(value), // Will emit values as regular `interval` would\r\n *                                  // until December 17, 2020 at 03:24:00.\r\n *     err => console.log(err)      // On December 17, 2020 at 03:24:00 it will emit an error,\r\n *                                  // since Observable did not complete by then.\r\n * );\r\n * ```\r\n * @see {@link timeoutWith}\r\n *\r\n * @param {number|Date} due Number specifying period within which Observable must emit values\r\n *                          or Date specifying before when Observable should complete\r\n * @param {SchedulerLike} [scheduler] Scheduler controlling when timeout checks occur.\r\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\r\n * @method timeout\r\n * @owner Observable\r\n */\r\nexport function timeout<T>(due: number | Date,\r\n                           scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> {\r\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}